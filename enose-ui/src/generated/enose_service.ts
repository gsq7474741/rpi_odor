// @generated by protobuf-ts 2.11.1 with parameter long_type_string,generate_dependencies,client_grpc1,server_grpc1
// @generated from protobuf file "enose_service.proto" (package "enose.service", syntax proto3)
// tslint:disable
//
// 电子鼻 gRPC 服务定义
// 提供控制接口和数据流服务
//
import { AnalysisResult } from "./enose_data";
import { SensorFrame } from "./enose_data";
import { Event } from "./enose_data";
import { Empty } from "./google/protobuf/empty";
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Timestamp } from "./google/protobuf/timestamp";
/**
 * 系统状态响应
 *
 * @generated from protobuf message enose.service.SystemStatus
 */
export interface SystemStatus {
    /**
     * 当前系统状态
     *
     * @generated from protobuf field: enose.service.SystemStateEnum current_state = 1
     */
    currentState: SystemStateEnum;
    /**
     * 所有外设的当前状态
     *
     * @generated from protobuf field: enose.service.PeripheralStatus peripheral_status = 2
     */
    peripheralStatus?: PeripheralStatus;
    /**
     * 系统运行时间 (秒)
     *
     * @generated from protobuf field: uint64 uptime_seconds = 3
     */
    uptimeSeconds: string;
    /**
     * 连接状态
     *
     * @generated from protobuf field: bool moonraker_connected = 4
     */
    moonrakerConnected: boolean;
    /**
     * @generated from protobuf field: bool sensor_connected = 5
     */
    sensorConnected: boolean;
    /**
     * @generated from protobuf field: bool firmware_ready = 7
     */
    firmwareReady: boolean; // Klipper 固件是否就绪 (急停后为 false)    /**
     * 最后更新时间
     *
     * @generated from protobuf field: google.protobuf.Timestamp last_updated = 6
     */
    lastUpdated?: Timestamp;
}
/**
 * 外设状态
 *
 * @generated from protobuf message enose.service.PeripheralStatus
 */
export interface PeripheralStatus {
    /**
     * 阀门状态
     *
     * @generated from protobuf field: float valve_waste = 1
     */
    valveWaste: number; // 0: 关闭, 1: 开启    /**
     * @generated from protobuf field: float valve_pinch = 2
     */
    valvePinch: number; // 0: 气路, 1: 液路    /**
     * @generated from protobuf field: float valve_air = 3
     */
    valveAir: number; // 0: 排气, 1: 气室    /**
     * @generated from protobuf field: float valve_outlet = 4
     */
    valveOutlet: number; // 0: 开启, 1: 关闭 (反向逻辑)    /**
     * 泵状态
     *
     * @generated from protobuf field: float air_pump_pwm = 5
     */
    airPumpPwm: number; // 0.0 - 1.0    /**
     * @generated from protobuf field: float cleaning_pump = 6
     */
    cleaningPump: number; // 0.0 - 1.0    /**
     * @generated from protobuf field: enose.service.PeripheralStatus.PumpRunState pump_2 = 7
     */
    pump2: PeripheralStatus_PumpRunState; // 样品泵 0    /**
     * @generated from protobuf field: enose.service.PeripheralStatus.PumpRunState pump_3 = 8
     */
    pump3: PeripheralStatus_PumpRunState; // 样品泵 1    /**
     * @generated from protobuf field: enose.service.PeripheralStatus.PumpRunState pump_4 = 9
     */
    pump4: PeripheralStatus_PumpRunState; // 样品泵 2    /**
     * @generated from protobuf field: enose.service.PeripheralStatus.PumpRunState pump_5 = 10
     */
    pump5: PeripheralStatus_PumpRunState; // 样品泵 3    /**
     * 加热器状态
     *
     * @generated from protobuf field: float heater_chamber = 11
     */
    heaterChamber: number; // 0.0 - 1.0    /**
     * 传感器读数 (只读)
     *
     * @generated from protobuf field: optional float sensor_chamber_temp = 20
     */
    sensorChamberTemp?: number; // 气室温度 (°C)    /**
     * @generated from protobuf field: optional float scale_weight = 21
     */
    scaleWeight?: number; // 称重值 (g)}
/**
 * @generated from protobuf enum enose.service.PeripheralStatus.PumpRunState
 */
export enum PeripheralStatus_PumpRunState {
    /**
     * @generated from protobuf enum value: PUMP_RUN_STATE_UNSPECIFIED = 0;
     */
    PUMP_RUN_STATE_UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: STOPPED = 1;
     */
    STOPPED = 1,
    /**
     * @generated from protobuf enum value: RUNNING = 2;
     */
    RUNNING = 2
}
/**
 * 设置系统状态请求
 *
 * @generated from protobuf message enose.service.SetSystemStateRequest
 */
export interface SetSystemStateRequest {
    /**
     * @generated from protobuf field: enose.service.SystemStateEnum target_state = 1
     */
    targetState: SystemStateEnum;
}
/**
 * @generated from protobuf message enose.service.SetSystemStateResponse
 */
export interface SetSystemStateResponse {
    /**
     * @generated from protobuf field: bool success = 1
     */
    success: boolean;
    /**
     * @generated from protobuf field: string message = 2
     */
    message: string;
    /**
     * @generated from protobuf field: enose.service.SystemStateEnum new_state = 3
     */
    newState: SystemStateEnum;
}
/**
 * 手动控制请求
 *
 * @generated from protobuf message enose.service.ManualControlRequest
 */
export interface ManualControlRequest {
    /**
     * 外设名称 (valve_waste, valve_pinch, air_pump_pwm, etc.)
     *
     * @generated from protobuf field: string peripheral_name = 1
     */
    peripheralName: string;
    /**
     * 目标值 (对于开关类型: 0/1, 对于PWM: 0.0-1.0)
     *
     * @generated from protobuf field: float value = 2
     */
    value: number;
}
/**
 * @generated from protobuf message enose.service.ManualControlResponse
 */
export interface ManualControlResponse {
    /**
     * @generated from protobuf field: bool success = 1
     */
    success: boolean;
    /**
     * @generated from protobuf field: string message = 2
     */
    message: string;
}
/**
 * 进样请求
 *
 * @generated from protobuf message enose.service.StartInjectionRequest
 */
export interface StartInjectionRequest {
    /**
     * 每个蠕动泵的进样量 (单位待标定，目前为步进电机移动距离 mm)
     *
     * @generated from protobuf field: float pump_2_volume = 1
     */
    pump2Volume: number; // 蠕动泵0    /**
     * @generated from protobuf field: float pump_3_volume = 2
     */
    pump3Volume: number; // 蠕动泵1    /**
     * @generated from protobuf field: float pump_4_volume = 3
     */
    pump4Volume: number; // 蠕动泵2    /**
     * @generated from protobuf field: float pump_5_volume = 4
     */
    pump5Volume: number; // 蠕动泵3    /**
     * 可选参数
     *
     * @generated from protobuf field: optional float speed = 5
     */
    speed?: number; // 进样速度 (mm/s), 默认 10    /**
     * @generated from protobuf field: optional float accel = 6
     */
    accel?: number; // 加速度 (mm/s²), 默认 100}
/**
 * @generated from protobuf message enose.service.StartInjectionResponse
 */
export interface StartInjectionResponse {
    /**
     * @generated from protobuf field: bool success = 1
     */
    success: boolean;
    /**
     * @generated from protobuf field: string message = 2
     */
    message: string;
}
/**
 * @generated from protobuf message enose.service.StopInjectionResponse
 */
export interface StopInjectionResponse {
    /**
     * @generated from protobuf field: bool success = 1
     */
    success: boolean;
    /**
     * @generated from protobuf field: string message = 2
     */
    message: string;
}
/**
 * 紧急停止响应
 *
 * @generated from protobuf message enose.service.EmergencyStopResponse
 */
export interface EmergencyStopResponse {
    /**
     * @generated from protobuf field: bool success = 1
     */
    success: boolean;
    /**
     * @generated from protobuf field: string message = 2
     */
    message: string;
}
/**
 * 固件重启响应
 *
 * @generated from protobuf message enose.service.FirmwareRestartResponse
 */
export interface FirmwareRestartResponse {
    /**
     * @generated from protobuf field: bool success = 1
     */
    success: boolean;
    /**
     * @generated from protobuf field: string message = 2
     */
    message: string;
}
/**
 * 运行泵请求
 *
 * @generated from protobuf message enose.service.RunPumpRequest
 */
export interface RunPumpRequest {
    /**
     * 泵名称 (pump_2, pump_3, pump_4, pump_5, cleaning_pump)
     *
     * @generated from protobuf field: string pump_name = 1
     */
    pumpName: string;
    /**
     * 速度 (步进泵: mm/s, DC泵: 0.0-1.0 PWM)
     *
     * @generated from protobuf field: float speed = 2
     */
    speed: number;
    /**
     * 距离 (仅步进泵需要, 单位: mm)
     *
     * @generated from protobuf field: optional float distance = 3
     */
    distance?: number;
    /**
     * 加速度 (仅步进泵需要, 单位: mm/s²)
     *
     * @generated from protobuf field: optional float accel = 4
     */
    accel?: number;
}
/**
 * @generated from protobuf message enose.service.RunPumpResponse
 */
export interface RunPumpResponse {
    /**
     * @generated from protobuf field: bool success = 1
     */
    success: boolean;
    /**
     * @generated from protobuf field: string message = 2
     */
    message: string;
}
/**
 * @generated from protobuf message enose.service.StopAllPumpsResponse
 */
export interface StopAllPumpsResponse {
    /**
     * @generated from protobuf field: bool success = 1
     */
    success: boolean;
    /**
     * @generated from protobuf field: string message = 2
     */
    message: string;
}
// ============================================================// 传感器服务消息定义// ============================================================

/**
 * 传感器命令请求
 *
 * @generated from protobuf message enose.service.SensorCommandRequest
 */
export interface SensorCommandRequest {
    /**
     * 命令类型: sync, init, start, stop, status, reset
     *
     * @generated from protobuf field: string command = 1
     */
    command: string;
    /**
     * 可选参数 (JSON 格式字符串)
     *
     * @generated from protobuf field: optional string params_json = 2
     */
    paramsJson?: string;
}
/**
 * @generated from protobuf message enose.service.SensorCommandResponse
 */
export interface SensorCommandResponse {
    /**
     * @generated from protobuf field: bool success = 1
     */
    success: boolean;
    /**
     * @generated from protobuf field: string message = 2
     */
    message: string;
    /**
     * 响应数据 (JSON 格式字符串)
     *
     * @generated from protobuf field: optional string data_json = 3
     */
    dataJson?: string;
}
/**
 * 传感器板状态
 *
 * @generated from protobuf message enose.service.SensorBoardStatus
 */
export interface SensorBoardStatus {
    /**
     * @generated from protobuf field: bool connected = 1
     */
    connected: boolean;
    /**
     * @generated from protobuf field: bool running = 2
     */
    running: boolean; // 是否正在采集    /**
     * @generated from protobuf field: uint32 sensor_count = 3
     */
    sensorCount: number; // 传感器数量    /**
     * @generated from protobuf field: string firmware_version = 4
     */
    firmwareVersion: string;
    /**
     * @generated from protobuf field: string port = 5
     */
    port: string;
}
/**
 * 单个传感器读数 (实时数据流)
 *
 * @generated from protobuf message enose.service.SensorReading
 */
export interface SensorReading {
    /**
     * @generated from protobuf field: uint64 tick_ms = 1
     */
    tickMs: string; // 设备时间戳 (毫秒)    /**
     * @generated from protobuf field: uint32 sensor_idx = 2
     */
    sensorIdx: number; // 传感器索引 (0-7)    /**
     * @generated from protobuf field: uint32 sensor_id = 3
     */
    sensorId: number; // 传感器 ID    /**
     * @generated from protobuf field: double value = 4
     */
    value: number; // 主读数 (电阻/电压)    /**
     * @generated from protobuf field: string sensor_type = 5
     */
    sensorType: string; // mox_d, mox_a, pid    /**
     * @generated from protobuf field: optional double temperature = 6
     */
    temperature?: number;
    /**
     * @generated from protobuf field: optional double humidity = 7
     */
    humidity?: number;
    /**
     * @generated from protobuf field: optional double pressure = 8
     */
    pressure?: number;
    /**
     * @generated from protobuf field: uint32 heater_step = 9
     */
    heaterStep: number; // 加热器步进索引    /**
     * @generated from protobuf field: uint32 adc_channel = 10
     */
    adcChannel: number;
}
/**
 * 加热器配置请求
 *
 * @generated from protobuf message enose.service.HeaterConfigRequest
 */
export interface HeaterConfigRequest {
    /**
     * @generated from protobuf field: repeated uint32 temps = 1
     */
    temps: number[]; // 温度列表 (°C)    /**
     * @generated from protobuf field: repeated uint32 durs = 2
     */
    durs: number[]; // 持续时间列表 (×140ms)    /**
     * 目标传感器 (空=所有)
     *
     * @generated from protobuf field: repeated uint32 sensors = 3
     */
    sensors: number[];
}
/**
 * @generated from protobuf message enose.service.HeaterConfigResponse
 */
export interface HeaterConfigResponse {
    /**
     * @generated from protobuf field: bool success = 1
     */
    success: boolean;
    /**
     * @generated from protobuf field: string message = 2
     */
    message: string;
}
/**
 * 加热器预设
 *
 * @generated from protobuf message enose.service.HeaterPreset
 */
export interface HeaterPreset {
    /**
     * @generated from protobuf field: string name = 1
     */
    name: string;
    /**
     * @generated from protobuf field: string description = 2
     */
    description: string;
    /**
     * @generated from protobuf field: repeated uint32 temps = 3
     */
    temps: number[];
    /**
     * @generated from protobuf field: repeated uint32 durs = 4
     */
    durs: number[];
}
// ============================================================// 请求/响应消息定义// ============================================================

/**
 * 系统状态枚举
 *
 * @generated from protobuf enum enose.service.SystemStateEnum
 */
export enum SystemStateEnum {
    /**
     * @generated from protobuf enum value: SYSTEM_STATE_UNSPECIFIED = 0;
     */
    SYSTEM_STATE_UNSPECIFIED = 0,
    /**
     * 开机初始状态
     *
     * @generated from protobuf enum value: INITIAL = 1;
     */
    INITIAL = 1,
    /**
     * 排废状态
     *
     * @generated from protobuf enum value: DRAIN = 2;
     */
    DRAIN = 2,
    /**
     * 清洗状态: 出气阀开, 气体三通阀指向大气, 清洗泵开, 夹管阀液路, 排废阀关
     *
     * @generated from protobuf enum value: CLEAN = 3;
     */
    CLEAN = 3,
    /**
     * 采样状态: 排废关, 夹管阀气路, 出气阀开, 三通阀指向气室, 气泵开
     *
     * @generated from protobuf enum value: SAMPLE = 4;
     */
    SAMPLE = 4,
    /**
     * 进样状态: 阀门同CLEAN, 使用蠕动泵进样
     *
     * @generated from protobuf enum value: INJECT = 5;
     */
    INJECT = 5
}
// @generated message type with reflection information, may provide speed optimized methods
class SystemStatus$Type extends MessageType<SystemStatus> {
    constructor() {
        super("enose.service.SystemStatus", [
            { no: 1, name: "current_state", kind: "enum", T: () => ["enose.service.SystemStateEnum", SystemStateEnum] },
            { no: 2, name: "peripheral_status", kind: "message", T: () => PeripheralStatus },
            { no: 3, name: "uptime_seconds", kind: "scalar", T: 4 /*ScalarType.UINT64*/ },
            { no: 4, name: "moonraker_connected", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "sensor_connected", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "firmware_ready", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "last_updated", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<SystemStatus>): SystemStatus {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.currentState = 0;
        message.uptimeSeconds = "0";
        message.moonrakerConnected = false;
        message.sensorConnected = false;
        message.firmwareReady = false;
        if (value !== undefined)
            reflectionMergePartial<SystemStatus>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SystemStatus): SystemStatus {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* enose.service.SystemStateEnum current_state */ 1:
                    message.currentState = reader.int32();
                    break;
                case /* enose.service.PeripheralStatus peripheral_status */ 2:
                    message.peripheralStatus = PeripheralStatus.internalBinaryRead(reader, reader.uint32(), options, message.peripheralStatus);
                    break;
                case /* uint64 uptime_seconds */ 3:
                    message.uptimeSeconds = reader.uint64().toString();
                    break;
                case /* bool moonraker_connected */ 4:
                    message.moonrakerConnected = reader.bool();
                    break;
                case /* bool sensor_connected */ 5:
                    message.sensorConnected = reader.bool();
                    break;
                case /* bool firmware_ready */ 7:
                    message.firmwareReady = reader.bool();
                    break;
                case /* google.protobuf.Timestamp last_updated */ 6:
                    message.lastUpdated = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.lastUpdated);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SystemStatus, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* enose.service.SystemStateEnum current_state = 1; */
        if (message.currentState !== 0)
            writer.tag(1, WireType.Varint).int32(message.currentState);
        /* enose.service.PeripheralStatus peripheral_status = 2; */
        if (message.peripheralStatus)
            PeripheralStatus.internalBinaryWrite(message.peripheralStatus, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* uint64 uptime_seconds = 3; */
        if (message.uptimeSeconds !== "0")
            writer.tag(3, WireType.Varint).uint64(message.uptimeSeconds);
        /* bool moonraker_connected = 4; */
        if (message.moonrakerConnected !== false)
            writer.tag(4, WireType.Varint).bool(message.moonrakerConnected);
        /* bool sensor_connected = 5; */
        if (message.sensorConnected !== false)
            writer.tag(5, WireType.Varint).bool(message.sensorConnected);
        /* google.protobuf.Timestamp last_updated = 6; */
        if (message.lastUpdated)
            Timestamp.internalBinaryWrite(message.lastUpdated, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* bool firmware_ready = 7; */
        if (message.firmwareReady !== false)
            writer.tag(7, WireType.Varint).bool(message.firmwareReady);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.service.SystemStatus
 */
export const SystemStatus = new SystemStatus$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PeripheralStatus$Type extends MessageType<PeripheralStatus> {
    constructor() {
        super("enose.service.PeripheralStatus", [
            { no: 1, name: "valve_waste", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "valve_pinch", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "valve_air", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "valve_outlet", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "air_pump_pwm", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 6, name: "cleaning_pump", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 7, name: "pump_2", kind: "enum", T: () => ["enose.service.PeripheralStatus.PumpRunState", PeripheralStatus_PumpRunState] },
            { no: 8, name: "pump_3", kind: "enum", T: () => ["enose.service.PeripheralStatus.PumpRunState", PeripheralStatus_PumpRunState] },
            { no: 9, name: "pump_4", kind: "enum", T: () => ["enose.service.PeripheralStatus.PumpRunState", PeripheralStatus_PumpRunState] },
            { no: 10, name: "pump_5", kind: "enum", T: () => ["enose.service.PeripheralStatus.PumpRunState", PeripheralStatus_PumpRunState] },
            { no: 11, name: "heater_chamber", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 20, name: "sensor_chamber_temp", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 21, name: "scale_weight", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<PeripheralStatus>): PeripheralStatus {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.valveWaste = 0;
        message.valvePinch = 0;
        message.valveAir = 0;
        message.valveOutlet = 0;
        message.airPumpPwm = 0;
        message.cleaningPump = 0;
        message.pump2 = 0;
        message.pump3 = 0;
        message.pump4 = 0;
        message.pump5 = 0;
        message.heaterChamber = 0;
        if (value !== undefined)
            reflectionMergePartial<PeripheralStatus>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PeripheralStatus): PeripheralStatus {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float valve_waste */ 1:
                    message.valveWaste = reader.float();
                    break;
                case /* float valve_pinch */ 2:
                    message.valvePinch = reader.float();
                    break;
                case /* float valve_air */ 3:
                    message.valveAir = reader.float();
                    break;
                case /* float valve_outlet */ 4:
                    message.valveOutlet = reader.float();
                    break;
                case /* float air_pump_pwm */ 5:
                    message.airPumpPwm = reader.float();
                    break;
                case /* float cleaning_pump */ 6:
                    message.cleaningPump = reader.float();
                    break;
                case /* enose.service.PeripheralStatus.PumpRunState pump_2 */ 7:
                    message.pump2 = reader.int32();
                    break;
                case /* enose.service.PeripheralStatus.PumpRunState pump_3 */ 8:
                    message.pump3 = reader.int32();
                    break;
                case /* enose.service.PeripheralStatus.PumpRunState pump_4 */ 9:
                    message.pump4 = reader.int32();
                    break;
                case /* enose.service.PeripheralStatus.PumpRunState pump_5 */ 10:
                    message.pump5 = reader.int32();
                    break;
                case /* float heater_chamber */ 11:
                    message.heaterChamber = reader.float();
                    break;
                case /* optional float sensor_chamber_temp */ 20:
                    message.sensorChamberTemp = reader.float();
                    break;
                case /* optional float scale_weight */ 21:
                    message.scaleWeight = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PeripheralStatus, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* float valve_waste = 1; */
        if (message.valveWaste !== 0)
            writer.tag(1, WireType.Bit32).float(message.valveWaste);
        /* float valve_pinch = 2; */
        if (message.valvePinch !== 0)
            writer.tag(2, WireType.Bit32).float(message.valvePinch);
        /* float valve_air = 3; */
        if (message.valveAir !== 0)
            writer.tag(3, WireType.Bit32).float(message.valveAir);
        /* float valve_outlet = 4; */
        if (message.valveOutlet !== 0)
            writer.tag(4, WireType.Bit32).float(message.valveOutlet);
        /* float air_pump_pwm = 5; */
        if (message.airPumpPwm !== 0)
            writer.tag(5, WireType.Bit32).float(message.airPumpPwm);
        /* float cleaning_pump = 6; */
        if (message.cleaningPump !== 0)
            writer.tag(6, WireType.Bit32).float(message.cleaningPump);
        /* enose.service.PeripheralStatus.PumpRunState pump_2 = 7; */
        if (message.pump2 !== 0)
            writer.tag(7, WireType.Varint).int32(message.pump2);
        /* enose.service.PeripheralStatus.PumpRunState pump_3 = 8; */
        if (message.pump3 !== 0)
            writer.tag(8, WireType.Varint).int32(message.pump3);
        /* enose.service.PeripheralStatus.PumpRunState pump_4 = 9; */
        if (message.pump4 !== 0)
            writer.tag(9, WireType.Varint).int32(message.pump4);
        /* enose.service.PeripheralStatus.PumpRunState pump_5 = 10; */
        if (message.pump5 !== 0)
            writer.tag(10, WireType.Varint).int32(message.pump5);
        /* float heater_chamber = 11; */
        if (message.heaterChamber !== 0)
            writer.tag(11, WireType.Bit32).float(message.heaterChamber);
        /* optional float sensor_chamber_temp = 20; */
        if (message.sensorChamberTemp !== undefined)
            writer.tag(20, WireType.Bit32).float(message.sensorChamberTemp);
        /* optional float scale_weight = 21; */
        if (message.scaleWeight !== undefined)
            writer.tag(21, WireType.Bit32).float(message.scaleWeight);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.service.PeripheralStatus
 */
export const PeripheralStatus = new PeripheralStatus$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetSystemStateRequest$Type extends MessageType<SetSystemStateRequest> {
    constructor() {
        super("enose.service.SetSystemStateRequest", [
            { no: 1, name: "target_state", kind: "enum", T: () => ["enose.service.SystemStateEnum", SystemStateEnum] }
        ]);
    }
    create(value?: PartialMessage<SetSystemStateRequest>): SetSystemStateRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.targetState = 0;
        if (value !== undefined)
            reflectionMergePartial<SetSystemStateRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetSystemStateRequest): SetSystemStateRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* enose.service.SystemStateEnum target_state */ 1:
                    message.targetState = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetSystemStateRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* enose.service.SystemStateEnum target_state = 1; */
        if (message.targetState !== 0)
            writer.tag(1, WireType.Varint).int32(message.targetState);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.service.SetSystemStateRequest
 */
export const SetSystemStateRequest = new SetSystemStateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetSystemStateResponse$Type extends MessageType<SetSystemStateResponse> {
    constructor() {
        super("enose.service.SetSystemStateResponse", [
            { no: 1, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "new_state", kind: "enum", T: () => ["enose.service.SystemStateEnum", SystemStateEnum] }
        ]);
    }
    create(value?: PartialMessage<SetSystemStateResponse>): SetSystemStateResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.success = false;
        message.message = "";
        message.newState = 0;
        if (value !== undefined)
            reflectionMergePartial<SetSystemStateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetSystemStateResponse): SetSystemStateResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool success */ 1:
                    message.success = reader.bool();
                    break;
                case /* string message */ 2:
                    message.message = reader.string();
                    break;
                case /* enose.service.SystemStateEnum new_state */ 3:
                    message.newState = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetSystemStateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool success = 1; */
        if (message.success !== false)
            writer.tag(1, WireType.Varint).bool(message.success);
        /* string message = 2; */
        if (message.message !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.message);
        /* enose.service.SystemStateEnum new_state = 3; */
        if (message.newState !== 0)
            writer.tag(3, WireType.Varint).int32(message.newState);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.service.SetSystemStateResponse
 */
export const SetSystemStateResponse = new SetSystemStateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ManualControlRequest$Type extends MessageType<ManualControlRequest> {
    constructor() {
        super("enose.service.ManualControlRequest", [
            { no: 1, name: "peripheral_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "value", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<ManualControlRequest>): ManualControlRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.peripheralName = "";
        message.value = 0;
        if (value !== undefined)
            reflectionMergePartial<ManualControlRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ManualControlRequest): ManualControlRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string peripheral_name */ 1:
                    message.peripheralName = reader.string();
                    break;
                case /* float value */ 2:
                    message.value = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ManualControlRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string peripheral_name = 1; */
        if (message.peripheralName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.peripheralName);
        /* float value = 2; */
        if (message.value !== 0)
            writer.tag(2, WireType.Bit32).float(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.service.ManualControlRequest
 */
export const ManualControlRequest = new ManualControlRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ManualControlResponse$Type extends MessageType<ManualControlResponse> {
    constructor() {
        super("enose.service.ManualControlResponse", [
            { no: 1, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ManualControlResponse>): ManualControlResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.success = false;
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial<ManualControlResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ManualControlResponse): ManualControlResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool success */ 1:
                    message.success = reader.bool();
                    break;
                case /* string message */ 2:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ManualControlResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool success = 1; */
        if (message.success !== false)
            writer.tag(1, WireType.Varint).bool(message.success);
        /* string message = 2; */
        if (message.message !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.service.ManualControlResponse
 */
export const ManualControlResponse = new ManualControlResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StartInjectionRequest$Type extends MessageType<StartInjectionRequest> {
    constructor() {
        super("enose.service.StartInjectionRequest", [
            { no: 1, name: "pump_2_volume", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "pump_3_volume", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "pump_4_volume", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "pump_5_volume", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "speed", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 6, name: "accel", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<StartInjectionRequest>): StartInjectionRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.pump2Volume = 0;
        message.pump3Volume = 0;
        message.pump4Volume = 0;
        message.pump5Volume = 0;
        if (value !== undefined)
            reflectionMergePartial<StartInjectionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StartInjectionRequest): StartInjectionRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float pump_2_volume */ 1:
                    message.pump2Volume = reader.float();
                    break;
                case /* float pump_3_volume */ 2:
                    message.pump3Volume = reader.float();
                    break;
                case /* float pump_4_volume */ 3:
                    message.pump4Volume = reader.float();
                    break;
                case /* float pump_5_volume */ 4:
                    message.pump5Volume = reader.float();
                    break;
                case /* optional float speed */ 5:
                    message.speed = reader.float();
                    break;
                case /* optional float accel */ 6:
                    message.accel = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StartInjectionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* float pump_2_volume = 1; */
        if (message.pump2Volume !== 0)
            writer.tag(1, WireType.Bit32).float(message.pump2Volume);
        /* float pump_3_volume = 2; */
        if (message.pump3Volume !== 0)
            writer.tag(2, WireType.Bit32).float(message.pump3Volume);
        /* float pump_4_volume = 3; */
        if (message.pump4Volume !== 0)
            writer.tag(3, WireType.Bit32).float(message.pump4Volume);
        /* float pump_5_volume = 4; */
        if (message.pump5Volume !== 0)
            writer.tag(4, WireType.Bit32).float(message.pump5Volume);
        /* optional float speed = 5; */
        if (message.speed !== undefined)
            writer.tag(5, WireType.Bit32).float(message.speed);
        /* optional float accel = 6; */
        if (message.accel !== undefined)
            writer.tag(6, WireType.Bit32).float(message.accel);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.service.StartInjectionRequest
 */
export const StartInjectionRequest = new StartInjectionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StartInjectionResponse$Type extends MessageType<StartInjectionResponse> {
    constructor() {
        super("enose.service.StartInjectionResponse", [
            { no: 1, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StartInjectionResponse>): StartInjectionResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.success = false;
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial<StartInjectionResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StartInjectionResponse): StartInjectionResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool success */ 1:
                    message.success = reader.bool();
                    break;
                case /* string message */ 2:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StartInjectionResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool success = 1; */
        if (message.success !== false)
            writer.tag(1, WireType.Varint).bool(message.success);
        /* string message = 2; */
        if (message.message !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.service.StartInjectionResponse
 */
export const StartInjectionResponse = new StartInjectionResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StopInjectionResponse$Type extends MessageType<StopInjectionResponse> {
    constructor() {
        super("enose.service.StopInjectionResponse", [
            { no: 1, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StopInjectionResponse>): StopInjectionResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.success = false;
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial<StopInjectionResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StopInjectionResponse): StopInjectionResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool success */ 1:
                    message.success = reader.bool();
                    break;
                case /* string message */ 2:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StopInjectionResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool success = 1; */
        if (message.success !== false)
            writer.tag(1, WireType.Varint).bool(message.success);
        /* string message = 2; */
        if (message.message !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.service.StopInjectionResponse
 */
export const StopInjectionResponse = new StopInjectionResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EmergencyStopResponse$Type extends MessageType<EmergencyStopResponse> {
    constructor() {
        super("enose.service.EmergencyStopResponse", [
            { no: 1, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<EmergencyStopResponse>): EmergencyStopResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.success = false;
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial<EmergencyStopResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EmergencyStopResponse): EmergencyStopResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool success */ 1:
                    message.success = reader.bool();
                    break;
                case /* string message */ 2:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EmergencyStopResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool success = 1; */
        if (message.success !== false)
            writer.tag(1, WireType.Varint).bool(message.success);
        /* string message = 2; */
        if (message.message !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.service.EmergencyStopResponse
 */
export const EmergencyStopResponse = new EmergencyStopResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FirmwareRestartResponse$Type extends MessageType<FirmwareRestartResponse> {
    constructor() {
        super("enose.service.FirmwareRestartResponse", [
            { no: 1, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<FirmwareRestartResponse>): FirmwareRestartResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.success = false;
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial<FirmwareRestartResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FirmwareRestartResponse): FirmwareRestartResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool success */ 1:
                    message.success = reader.bool();
                    break;
                case /* string message */ 2:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FirmwareRestartResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool success = 1; */
        if (message.success !== false)
            writer.tag(1, WireType.Varint).bool(message.success);
        /* string message = 2; */
        if (message.message !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.service.FirmwareRestartResponse
 */
export const FirmwareRestartResponse = new FirmwareRestartResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RunPumpRequest$Type extends MessageType<RunPumpRequest> {
    constructor() {
        super("enose.service.RunPumpRequest", [
            { no: 1, name: "pump_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "speed", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "distance", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "accel", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<RunPumpRequest>): RunPumpRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.pumpName = "";
        message.speed = 0;
        if (value !== undefined)
            reflectionMergePartial<RunPumpRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RunPumpRequest): RunPumpRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string pump_name */ 1:
                    message.pumpName = reader.string();
                    break;
                case /* float speed */ 2:
                    message.speed = reader.float();
                    break;
                case /* optional float distance */ 3:
                    message.distance = reader.float();
                    break;
                case /* optional float accel */ 4:
                    message.accel = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RunPumpRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string pump_name = 1; */
        if (message.pumpName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.pumpName);
        /* float speed = 2; */
        if (message.speed !== 0)
            writer.tag(2, WireType.Bit32).float(message.speed);
        /* optional float distance = 3; */
        if (message.distance !== undefined)
            writer.tag(3, WireType.Bit32).float(message.distance);
        /* optional float accel = 4; */
        if (message.accel !== undefined)
            writer.tag(4, WireType.Bit32).float(message.accel);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.service.RunPumpRequest
 */
export const RunPumpRequest = new RunPumpRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RunPumpResponse$Type extends MessageType<RunPumpResponse> {
    constructor() {
        super("enose.service.RunPumpResponse", [
            { no: 1, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RunPumpResponse>): RunPumpResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.success = false;
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial<RunPumpResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RunPumpResponse): RunPumpResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool success */ 1:
                    message.success = reader.bool();
                    break;
                case /* string message */ 2:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RunPumpResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool success = 1; */
        if (message.success !== false)
            writer.tag(1, WireType.Varint).bool(message.success);
        /* string message = 2; */
        if (message.message !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.service.RunPumpResponse
 */
export const RunPumpResponse = new RunPumpResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StopAllPumpsResponse$Type extends MessageType<StopAllPumpsResponse> {
    constructor() {
        super("enose.service.StopAllPumpsResponse", [
            { no: 1, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StopAllPumpsResponse>): StopAllPumpsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.success = false;
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial<StopAllPumpsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StopAllPumpsResponse): StopAllPumpsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool success */ 1:
                    message.success = reader.bool();
                    break;
                case /* string message */ 2:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StopAllPumpsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool success = 1; */
        if (message.success !== false)
            writer.tag(1, WireType.Varint).bool(message.success);
        /* string message = 2; */
        if (message.message !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.service.StopAllPumpsResponse
 */
export const StopAllPumpsResponse = new StopAllPumpsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SensorCommandRequest$Type extends MessageType<SensorCommandRequest> {
    constructor() {
        super("enose.service.SensorCommandRequest", [
            { no: 1, name: "command", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "params_json", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SensorCommandRequest>): SensorCommandRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.command = "";
        if (value !== undefined)
            reflectionMergePartial<SensorCommandRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SensorCommandRequest): SensorCommandRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string command */ 1:
                    message.command = reader.string();
                    break;
                case /* optional string params_json */ 2:
                    message.paramsJson = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SensorCommandRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string command = 1; */
        if (message.command !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.command);
        /* optional string params_json = 2; */
        if (message.paramsJson !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.paramsJson);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.service.SensorCommandRequest
 */
export const SensorCommandRequest = new SensorCommandRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SensorCommandResponse$Type extends MessageType<SensorCommandResponse> {
    constructor() {
        super("enose.service.SensorCommandResponse", [
            { no: 1, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "data_json", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SensorCommandResponse>): SensorCommandResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.success = false;
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial<SensorCommandResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SensorCommandResponse): SensorCommandResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool success */ 1:
                    message.success = reader.bool();
                    break;
                case /* string message */ 2:
                    message.message = reader.string();
                    break;
                case /* optional string data_json */ 3:
                    message.dataJson = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SensorCommandResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool success = 1; */
        if (message.success !== false)
            writer.tag(1, WireType.Varint).bool(message.success);
        /* string message = 2; */
        if (message.message !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.message);
        /* optional string data_json = 3; */
        if (message.dataJson !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.dataJson);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.service.SensorCommandResponse
 */
export const SensorCommandResponse = new SensorCommandResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SensorBoardStatus$Type extends MessageType<SensorBoardStatus> {
    constructor() {
        super("enose.service.SensorBoardStatus", [
            { no: 1, name: "connected", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "running", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "sensor_count", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "firmware_version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "port", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SensorBoardStatus>): SensorBoardStatus {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.connected = false;
        message.running = false;
        message.sensorCount = 0;
        message.firmwareVersion = "";
        message.port = "";
        if (value !== undefined)
            reflectionMergePartial<SensorBoardStatus>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SensorBoardStatus): SensorBoardStatus {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool connected */ 1:
                    message.connected = reader.bool();
                    break;
                case /* bool running */ 2:
                    message.running = reader.bool();
                    break;
                case /* uint32 sensor_count */ 3:
                    message.sensorCount = reader.uint32();
                    break;
                case /* string firmware_version */ 4:
                    message.firmwareVersion = reader.string();
                    break;
                case /* string port */ 5:
                    message.port = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SensorBoardStatus, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool connected = 1; */
        if (message.connected !== false)
            writer.tag(1, WireType.Varint).bool(message.connected);
        /* bool running = 2; */
        if (message.running !== false)
            writer.tag(2, WireType.Varint).bool(message.running);
        /* uint32 sensor_count = 3; */
        if (message.sensorCount !== 0)
            writer.tag(3, WireType.Varint).uint32(message.sensorCount);
        /* string firmware_version = 4; */
        if (message.firmwareVersion !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.firmwareVersion);
        /* string port = 5; */
        if (message.port !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.port);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.service.SensorBoardStatus
 */
export const SensorBoardStatus = new SensorBoardStatus$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SensorReading$Type extends MessageType<SensorReading> {
    constructor() {
        super("enose.service.SensorReading", [
            { no: 1, name: "tick_ms", kind: "scalar", T: 4 /*ScalarType.UINT64*/ },
            { no: 2, name: "sensor_idx", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "sensor_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "value", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 5, name: "sensor_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "temperature", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 7, name: "humidity", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 8, name: "pressure", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 9, name: "heater_step", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "adc_channel", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<SensorReading>): SensorReading {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tickMs = "0";
        message.sensorIdx = 0;
        message.sensorId = 0;
        message.value = 0;
        message.sensorType = "";
        message.heaterStep = 0;
        message.adcChannel = 0;
        if (value !== undefined)
            reflectionMergePartial<SensorReading>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SensorReading): SensorReading {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 tick_ms */ 1:
                    message.tickMs = reader.uint64().toString();
                    break;
                case /* uint32 sensor_idx */ 2:
                    message.sensorIdx = reader.uint32();
                    break;
                case /* uint32 sensor_id */ 3:
                    message.sensorId = reader.uint32();
                    break;
                case /* double value */ 4:
                    message.value = reader.double();
                    break;
                case /* string sensor_type */ 5:
                    message.sensorType = reader.string();
                    break;
                case /* optional double temperature */ 6:
                    message.temperature = reader.double();
                    break;
                case /* optional double humidity */ 7:
                    message.humidity = reader.double();
                    break;
                case /* optional double pressure */ 8:
                    message.pressure = reader.double();
                    break;
                case /* uint32 heater_step */ 9:
                    message.heaterStep = reader.uint32();
                    break;
                case /* uint32 adc_channel */ 10:
                    message.adcChannel = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SensorReading, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 tick_ms = 1; */
        if (message.tickMs !== "0")
            writer.tag(1, WireType.Varint).uint64(message.tickMs);
        /* uint32 sensor_idx = 2; */
        if (message.sensorIdx !== 0)
            writer.tag(2, WireType.Varint).uint32(message.sensorIdx);
        /* uint32 sensor_id = 3; */
        if (message.sensorId !== 0)
            writer.tag(3, WireType.Varint).uint32(message.sensorId);
        /* double value = 4; */
        if (message.value !== 0)
            writer.tag(4, WireType.Bit64).double(message.value);
        /* string sensor_type = 5; */
        if (message.sensorType !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.sensorType);
        /* optional double temperature = 6; */
        if (message.temperature !== undefined)
            writer.tag(6, WireType.Bit64).double(message.temperature);
        /* optional double humidity = 7; */
        if (message.humidity !== undefined)
            writer.tag(7, WireType.Bit64).double(message.humidity);
        /* optional double pressure = 8; */
        if (message.pressure !== undefined)
            writer.tag(8, WireType.Bit64).double(message.pressure);
        /* uint32 heater_step = 9; */
        if (message.heaterStep !== 0)
            writer.tag(9, WireType.Varint).uint32(message.heaterStep);
        /* uint32 adc_channel = 10; */
        if (message.adcChannel !== 0)
            writer.tag(10, WireType.Varint).uint32(message.adcChannel);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.service.SensorReading
 */
export const SensorReading = new SensorReading$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HeaterConfigRequest$Type extends MessageType<HeaterConfigRequest> {
    constructor() {
        super("enose.service.HeaterConfigRequest", [
            { no: 1, name: "temps", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "durs", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "sensors", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<HeaterConfigRequest>): HeaterConfigRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.temps = [];
        message.durs = [];
        message.sensors = [];
        if (value !== undefined)
            reflectionMergePartial<HeaterConfigRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HeaterConfigRequest): HeaterConfigRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated uint32 temps */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.temps.push(reader.uint32());
                    else
                        message.temps.push(reader.uint32());
                    break;
                case /* repeated uint32 durs */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.durs.push(reader.uint32());
                    else
                        message.durs.push(reader.uint32());
                    break;
                case /* repeated uint32 sensors */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.sensors.push(reader.uint32());
                    else
                        message.sensors.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HeaterConfigRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated uint32 temps = 1; */
        if (message.temps.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.temps.length; i++)
                writer.uint32(message.temps[i]);
            writer.join();
        }
        /* repeated uint32 durs = 2; */
        if (message.durs.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.durs.length; i++)
                writer.uint32(message.durs[i]);
            writer.join();
        }
        /* repeated uint32 sensors = 3; */
        if (message.sensors.length) {
            writer.tag(3, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.sensors.length; i++)
                writer.uint32(message.sensors[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.service.HeaterConfigRequest
 */
export const HeaterConfigRequest = new HeaterConfigRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HeaterConfigResponse$Type extends MessageType<HeaterConfigResponse> {
    constructor() {
        super("enose.service.HeaterConfigResponse", [
            { no: 1, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<HeaterConfigResponse>): HeaterConfigResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.success = false;
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial<HeaterConfigResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HeaterConfigResponse): HeaterConfigResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool success */ 1:
                    message.success = reader.bool();
                    break;
                case /* string message */ 2:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HeaterConfigResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool success = 1; */
        if (message.success !== false)
            writer.tag(1, WireType.Varint).bool(message.success);
        /* string message = 2; */
        if (message.message !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.service.HeaterConfigResponse
 */
export const HeaterConfigResponse = new HeaterConfigResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HeaterPreset$Type extends MessageType<HeaterPreset> {
    constructor() {
        super("enose.service.HeaterPreset", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "temps", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "durs", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<HeaterPreset>): HeaterPreset {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.description = "";
        message.temps = [];
        message.durs = [];
        if (value !== undefined)
            reflectionMergePartial<HeaterPreset>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HeaterPreset): HeaterPreset {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string description */ 2:
                    message.description = reader.string();
                    break;
                case /* repeated uint32 temps */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.temps.push(reader.uint32());
                    else
                        message.temps.push(reader.uint32());
                    break;
                case /* repeated uint32 durs */ 4:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.durs.push(reader.uint32());
                    else
                        message.durs.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HeaterPreset, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string description = 2; */
        if (message.description !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.description);
        /* repeated uint32 temps = 3; */
        if (message.temps.length) {
            writer.tag(3, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.temps.length; i++)
                writer.uint32(message.temps[i]);
            writer.join();
        }
        /* repeated uint32 durs = 4; */
        if (message.durs.length) {
            writer.tag(4, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.durs.length; i++)
                writer.uint32(message.durs[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.service.HeaterPreset
 */
export const HeaterPreset = new HeaterPreset$Type();
/**
 * @generated ServiceType for protobuf service enose.service.ControlService
 */
export const ControlService = new ServiceType("enose.service.ControlService", [
    { name: "GetStatus", options: {}, I: Empty, O: SystemStatus },
    { name: "SetSystemState", options: {}, I: SetSystemStateRequest, O: SetSystemStateResponse },
    { name: "ManualControl", options: {}, I: ManualControlRequest, O: ManualControlResponse },
    { name: "RunPump", options: {}, I: RunPumpRequest, O: RunPumpResponse },
    { name: "StopAllPumps", options: {}, I: Empty, O: StopAllPumpsResponse },
    { name: "StartInjection", options: {}, I: StartInjectionRequest, O: StartInjectionResponse },
    { name: "StopInjection", options: {}, I: Empty, O: StopInjectionResponse },
    { name: "EmergencyStop", options: {}, I: Empty, O: EmergencyStopResponse },
    { name: "FirmwareRestart", options: {}, I: Empty, O: FirmwareRestartResponse },
    { name: "SubscribeEvents", serverStreaming: true, options: {}, I: Empty, O: Event },
    { name: "SubscribePeripheralStatus", serverStreaming: true, options: {}, I: Empty, O: PeripheralStatus }
]);
/**
 * @generated ServiceType for protobuf service enose.service.DataService
 */
export const DataService = new ServiceType("enose.service.DataService", [
    { name: "SubscribeSensorData", serverStreaming: true, options: {}, I: Empty, O: SensorFrame },
    { name: "SubscribeAnalysisResults", serverStreaming: true, options: {}, I: Empty, O: AnalysisResult }
]);
/**
 * @generated ServiceType for protobuf service enose.service.SensorService
 */
export const SensorService = new ServiceType("enose.service.SensorService", [
    { name: "SendCommand", options: {}, I: SensorCommandRequest, O: SensorCommandResponse },
    { name: "SubscribeSensorReadings", serverStreaming: true, options: {}, I: Empty, O: SensorReading },
    { name: "GetSensorStatus", options: {}, I: Empty, O: SensorBoardStatus },
    { name: "ConfigureHeater", options: {}, I: HeaterConfigRequest, O: HeaterConfigResponse }
]);
