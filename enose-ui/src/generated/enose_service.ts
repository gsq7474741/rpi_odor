// @generated by protobuf-ts 2.11.1 with parameter long_type_string,generate_dependencies,client_grpc1,server_grpc1
// @generated from protobuf file "enose_service.proto" (package "enose.service", syntax proto3)
// tslint:disable
//
// 电子鼻 gRPC 服务定义
// 提供控制接口和数据流服务
//
import { AnalysisResult } from "./enose_data";
import { SensorFrame } from "./enose_data";
import { Event } from "./enose_data";
import { Empty } from "./google/protobuf/empty";
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Timestamp } from "./google/protobuf/timestamp";
/**
 * 系统状态响应
 *
 * @generated from protobuf message enose.service.SystemStatus
 */
export interface SystemStatus {
    /**
     * 当前系统状态
     *
     * @generated from protobuf field: enose.service.SystemStateEnum current_state = 1
     */
    currentState: SystemStateEnum;
    /**
     * 所有外设的当前状态
     *
     * @generated from protobuf field: enose.service.PeripheralStatus peripheral_status = 2
     */
    peripheralStatus?: PeripheralStatus;
    /**
     * 系统运行时间 (秒)
     *
     * @generated from protobuf field: uint64 uptime_seconds = 3
     */
    uptimeSeconds: string;
    /**
     * 连接状态
     *
     * @generated from protobuf field: bool moonraker_connected = 4
     */
    moonrakerConnected: boolean;
    /**
     * @generated from protobuf field: bool sensor_connected = 5
     */
    sensorConnected: boolean;
    /**
     * @generated from protobuf field: bool firmware_ready = 7
     */
    firmwareReady: boolean; // Klipper 固件是否就绪 (急停后为 false)    /**
     * 最后更新时间
     *
     * @generated from protobuf field: google.protobuf.Timestamp last_updated = 6
     */
    lastUpdated?: Timestamp;
}
/**
 * 外设状态
 *
 * @generated from protobuf message enose.service.PeripheralStatus
 */
export interface PeripheralStatus {
    /**
     * 阀门状态
     *
     * @generated from protobuf field: float valve_waste = 1
     */
    valveWaste: number; // 0: 关闭, 1: 开启    /**
     * @generated from protobuf field: float valve_pinch = 2
     */
    valvePinch: number; // 0: 气路, 1: 液路    /**
     * @generated from protobuf field: float valve_air = 3
     */
    valveAir: number; // 0: 排气, 1: 气室    /**
     * @generated from protobuf field: float valve_outlet = 4
     */
    valveOutlet: number; // 0: 开启, 1: 关闭 (反向逻辑)    /**
     * 泵状态
     *
     * @generated from protobuf field: float air_pump_pwm = 5
     */
    airPumpPwm: number; // 0.0 - 1.0    /**
     * @generated from protobuf field: float cleaning_pump = 6
     */
    cleaningPump: number; // 0.0 - 1.0    /**
     * @generated from protobuf field: enose.service.PeripheralStatus.PumpRunState pump_2 = 7
     */
    pump2: PeripheralStatus_PumpRunState; // 样品泵 0    /**
     * @generated from protobuf field: enose.service.PeripheralStatus.PumpRunState pump_3 = 8
     */
    pump3: PeripheralStatus_PumpRunState; // 样品泵 1    /**
     * @generated from protobuf field: enose.service.PeripheralStatus.PumpRunState pump_4 = 9
     */
    pump4: PeripheralStatus_PumpRunState; // 样品泵 2    /**
     * @generated from protobuf field: enose.service.PeripheralStatus.PumpRunState pump_5 = 10
     */
    pump5: PeripheralStatus_PumpRunState; // 样品泵 3    /**
     * 加热器状态
     *
     * @generated from protobuf field: float heater_chamber = 11
     */
    heaterChamber: number; // 0.0 - 1.0    /**
     * 传感器读数 (只读)
     *
     * @generated from protobuf field: optional float sensor_chamber_temp = 20
     */
    sensorChamberTemp?: number; // 气室温度 (°C)    /**
     * @generated from protobuf field: optional float scale_weight = 21
     */
    scaleWeight?: number; // 称重值 (g)}
/**
 * @generated from protobuf enum enose.service.PeripheralStatus.PumpRunState
 */
export enum PeripheralStatus_PumpRunState {
    /**
     * @generated from protobuf enum value: PUMP_RUN_STATE_UNSPECIFIED = 0;
     */
    PUMP_RUN_STATE_UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: STOPPED = 1;
     */
    STOPPED = 1,
    /**
     * @generated from protobuf enum value: RUNNING = 2;
     */
    RUNNING = 2
}
/**
 * 设置系统状态请求
 *
 * @generated from protobuf message enose.service.SetSystemStateRequest
 */
export interface SetSystemStateRequest {
    /**
     * @generated from protobuf field: enose.service.SystemStateEnum target_state = 1
     */
    targetState: SystemStateEnum;
}
/**
 * @generated from protobuf message enose.service.SetSystemStateResponse
 */
export interface SetSystemStateResponse {
    /**
     * @generated from protobuf field: bool success = 1
     */
    success: boolean;
    /**
     * @generated from protobuf field: string message = 2
     */
    message: string;
    /**
     * @generated from protobuf field: enose.service.SystemStateEnum new_state = 3
     */
    newState: SystemStateEnum;
}
/**
 * 手动控制请求
 *
 * @generated from protobuf message enose.service.ManualControlRequest
 */
export interface ManualControlRequest {
    /**
     * 外设名称 (valve_waste, valve_pinch, air_pump_pwm, etc.)
     *
     * @generated from protobuf field: string peripheral_name = 1
     */
    peripheralName: string;
    /**
     * 目标值 (对于开关类型: 0/1, 对于PWM: 0.0-1.0)
     *
     * @generated from protobuf field: float value = 2
     */
    value: number;
}
/**
 * @generated from protobuf message enose.service.ManualControlResponse
 */
export interface ManualControlResponse {
    /**
     * @generated from protobuf field: bool success = 1
     */
    success: boolean;
    /**
     * @generated from protobuf field: string message = 2
     */
    message: string;
}
/**
 * 进样请求
 *
 * @generated from protobuf message enose.service.StartInjectionRequest
 */
export interface StartInjectionRequest {
    /**
     * 每个蠕动泵的进样量 (单位待标定，目前为步进电机移动距离 mm)
     *
     * @generated from protobuf field: float pump_2_volume = 1
     */
    pump2Volume: number; // 蠕动泵0    /**
     * @generated from protobuf field: float pump_3_volume = 2
     */
    pump3Volume: number; // 蠕动泵1    /**
     * @generated from protobuf field: float pump_4_volume = 3
     */
    pump4Volume: number; // 蠕动泵2    /**
     * @generated from protobuf field: float pump_5_volume = 4
     */
    pump5Volume: number; // 蠕动泵3    /**
     * 可选参数
     *
     * @generated from protobuf field: optional float speed = 5
     */
    speed?: number; // 进样速度 (mm/s), 默认 10    /**
     * @generated from protobuf field: optional float accel = 6
     */
    accel?: number; // 加速度 (mm/s²), 默认 100}
/**
 * @generated from protobuf message enose.service.StartInjectionResponse
 */
export interface StartInjectionResponse {
    /**
     * @generated from protobuf field: bool success = 1
     */
    success: boolean;
    /**
     * @generated from protobuf field: string message = 2
     */
    message: string;
}
/**
 * @generated from protobuf message enose.service.StopInjectionResponse
 */
export interface StopInjectionResponse {
    /**
     * @generated from protobuf field: bool success = 1
     */
    success: boolean;
    /**
     * @generated from protobuf field: string message = 2
     */
    message: string;
}
/**
 * 紧急停止响应
 *
 * @generated from protobuf message enose.service.EmergencyStopResponse
 */
export interface EmergencyStopResponse {
    /**
     * @generated from protobuf field: bool success = 1
     */
    success: boolean;
    /**
     * @generated from protobuf field: string message = 2
     */
    message: string;
}
/**
 * 固件重启响应
 *
 * @generated from protobuf message enose.service.FirmwareRestartResponse
 */
export interface FirmwareRestartResponse {
    /**
     * @generated from protobuf field: bool success = 1
     */
    success: boolean;
    /**
     * @generated from protobuf field: string message = 2
     */
    message: string;
}
/**
 * 运行泵请求
 *
 * @generated from protobuf message enose.service.RunPumpRequest
 */
export interface RunPumpRequest {
    /**
     * 泵名称 (pump_2, pump_3, pump_4, pump_5, cleaning_pump)
     *
     * @generated from protobuf field: string pump_name = 1
     */
    pumpName: string;
    /**
     * 速度 (步进泵: mm/s, DC泵: 0.0-1.0 PWM)
     *
     * @generated from protobuf field: float speed = 2
     */
    speed: number;
    /**
     * 距离 (仅步进泵需要, 单位: mm)
     *
     * @generated from protobuf field: optional float distance = 3
     */
    distance?: number;
    /**
     * 加速度 (仅步进泵需要, 单位: mm/s²)
     *
     * @generated from protobuf field: optional float accel = 4
     */
    accel?: number;
}
/**
 * @generated from protobuf message enose.service.RunPumpResponse
 */
export interface RunPumpResponse {
    /**
     * @generated from protobuf field: bool success = 1
     */
    success: boolean;
    /**
     * @generated from protobuf field: string message = 2
     */
    message: string;
}
/**
 * @generated from protobuf message enose.service.StopAllPumpsResponse
 */
export interface StopAllPumpsResponse {
    /**
     * @generated from protobuf field: bool success = 1
     */
    success: boolean;
    /**
     * @generated from protobuf field: string message = 2
     */
    message: string;
}
// ============================================================// 传感器服务消息定义// ============================================================

/**
 * 传感器命令请求
 *
 * @generated from protobuf message enose.service.SensorCommandRequest
 */
export interface SensorCommandRequest {
    /**
     * 命令类型: sync, init, start, stop, status, reset
     *
     * @generated from protobuf field: string command = 1
     */
    command: string;
    /**
     * 可选参数 (JSON 格式字符串)
     *
     * @generated from protobuf field: optional string params_json = 2
     */
    paramsJson?: string;
}
/**
 * @generated from protobuf message enose.service.SensorCommandResponse
 */
export interface SensorCommandResponse {
    /**
     * @generated from protobuf field: bool success = 1
     */
    success: boolean;
    /**
     * @generated from protobuf field: string message = 2
     */
    message: string;
    /**
     * 响应数据 (JSON 格式字符串)
     *
     * @generated from protobuf field: optional string data_json = 3
     */
    dataJson?: string;
}
/**
 * 传感器板状态
 *
 * @generated from protobuf message enose.service.SensorBoardStatus
 */
export interface SensorBoardStatus {
    /**
     * @generated from protobuf field: bool connected = 1
     */
    connected: boolean;
    /**
     * @generated from protobuf field: bool running = 2
     */
    running: boolean; // 是否正在采集    /**
     * @generated from protobuf field: uint32 sensor_count = 3
     */
    sensorCount: number; // 传感器数量    /**
     * @generated from protobuf field: string firmware_version = 4
     */
    firmwareVersion: string;
    /**
     * @generated from protobuf field: string port = 5
     */
    port: string;
}
/**
 * 单个传感器读数 (实时数据流)
 *
 * @generated from protobuf message enose.service.SensorReading
 */
export interface SensorReading {
    /**
     * @generated from protobuf field: uint64 tick_ms = 1
     */
    tickMs: string; // 设备时间戳 (毫秒)    /**
     * @generated from protobuf field: uint32 sensor_idx = 2
     */
    sensorIdx: number; // 传感器索引 (0-7)    /**
     * @generated from protobuf field: uint32 sensor_id = 3
     */
    sensorId: number; // 传感器 ID    /**
     * @generated from protobuf field: double value = 4
     */
    value: number; // 主读数 (电阻/电压)    /**
     * @generated from protobuf field: string sensor_type = 5
     */
    sensorType: string; // mox_d, mox_a, pid    /**
     * @generated from protobuf field: optional double temperature = 6
     */
    temperature?: number;
    /**
     * @generated from protobuf field: optional double humidity = 7
     */
    humidity?: number;
    /**
     * @generated from protobuf field: optional double pressure = 8
     */
    pressure?: number;
    /**
     * @generated from protobuf field: uint32 heater_step = 9
     */
    heaterStep: number; // 加热器步进索引    /**
     * @generated from protobuf field: uint32 adc_channel = 10
     */
    adcChannel: number;
}
/**
 * 加热器配置请求
 *
 * @generated from protobuf message enose.service.HeaterConfigRequest
 */
export interface HeaterConfigRequest {
    /**
     * @generated from protobuf field: repeated uint32 temps = 1
     */
    temps: number[]; // 温度列表 (°C)    /**
     * @generated from protobuf field: repeated uint32 durs = 2
     */
    durs: number[]; // 持续时间列表 (×140ms)    /**
     * 目标传感器 (空=所有)
     *
     * @generated from protobuf field: repeated uint32 sensors = 3
     */
    sensors: number[];
}
/**
 * @generated from protobuf message enose.service.HeaterConfigResponse
 */
export interface HeaterConfigResponse {
    /**
     * @generated from protobuf field: bool success = 1
     */
    success: boolean;
    /**
     * @generated from protobuf field: string message = 2
     */
    message: string;
}
/**
 * 加热器预设
 *
 * @generated from protobuf message enose.service.HeaterPreset
 */
export interface HeaterPreset {
    /**
     * @generated from protobuf field: string name = 1
     */
    name: string;
    /**
     * @generated from protobuf field: string description = 2
     */
    description: string;
    /**
     * @generated from protobuf field: repeated uint32 temps = 3
     */
    temps: number[];
    /**
     * @generated from protobuf field: repeated uint32 durs = 4
     */
    durs: number[];
}
// ============================================================// 称重服务消息定义// ============================================================

/**
 * 称重读数
 *
 * @generated from protobuf message enose.service.LoadCellReading
 */
export interface LoadCellReading {
    /**
     * @generated from protobuf field: float weight_grams = 1
     */
    weightGrams: number; // 标定后的克数    /**
     * @generated from protobuf field: float raw_percent = 2
     */
    rawPercent: number; // 原始百分比 (-100% ~ 100%)    /**
     * @generated from protobuf field: bool is_calibrated = 3
     */
    isCalibrated: boolean; // 是否已完成硬件标定    /**
     * @generated from protobuf field: bool is_stable = 4
     */
    isStable: boolean; // 是否稳定    /**
     * @generated from protobuf field: enose.service.LoadCellReading.WeightTrend trend = 5
     */
    trend: LoadCellReading_WeightTrend; // 重量趋势    /**
     * @generated from protobuf field: google.protobuf.Timestamp timestamp = 6
     */
    timestamp?: Timestamp;
}
/**
 * @generated from protobuf enum enose.service.LoadCellReading.WeightTrend
 */
export enum LoadCellReading_WeightTrend {
    /**
     * @generated from protobuf enum value: WEIGHT_TREND_UNSPECIFIED = 0;
     */
    WEIGHT_TREND_UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: STABLE = 1;
     */
    STABLE = 1,
    /**
     * @generated from protobuf enum value: INCREASING = 2;
     */
    INCREASING = 2,
    /**
     * @generated from protobuf enum value: DECREASING = 3;
     */
    DECREASING = 3
}
/**
 * 标定状态
 *
 * @generated from protobuf message enose.service.CalibrationStatus
 */
export interface CalibrationStatus {
    /**
     * @generated from protobuf field: enose.service.CalibrationStatus.CalibrationStep step = 1
     */
    step: CalibrationStatus_CalibrationStep; // 当前步骤    /**
     * @generated from protobuf field: float current_reading = 2
     */
    currentReading: number; // 当前读数 (原始百分比或克数)    /**
     * @generated from protobuf field: string message = 3
     */
    message: string; // 提示信息    /**
     * @generated from protobuf field: bool success = 4
     */
    success: boolean; // 操作是否成功}
/**
 * @generated from protobuf enum enose.service.CalibrationStatus.CalibrationStep
 */
export enum CalibrationStatus_CalibrationStep {
    /**
     * @generated from protobuf enum value: CALIBRATION_STEP_UNSPECIFIED = 0;
     */
    CALIBRATION_STEP_UNSPECIFIED = 0,
    /**
     * 未在标定
     *
     * @generated from protobuf enum value: IDLE = 1;
     */
    IDLE = 1,
    /**
     * 等待设置零点
     *
     * @generated from protobuf enum value: ZERO_POINT = 2;
     */
    ZERO_POINT = 2,
    /**
     * 等待设置参考重量
     *
     * @generated from protobuf enum value: REFERENCE_WEIGHT = 3;
     */
    REFERENCE_WEIGHT = 3,
    /**
     * 验证阶段
     *
     * @generated from protobuf enum value: VERIFY = 4;
     */
    VERIFY = 4,
    /**
     * 标定完成
     *
     * @generated from protobuf enum value: COMPLETE = 5;
     */
    COMPLETE = 5
}
/**
 * 参考重量请求
 *
 * @generated from protobuf message enose.service.ReferenceWeightRequest
 */
export interface ReferenceWeightRequest {
    /**
     * @generated from protobuf field: float weight_grams = 1
     */
    weightGrams: number; // 用户输入的参考物体重量 (克)}
/**
 * 标定结果
 *
 * @generated from protobuf message enose.service.CalibrationResult
 */
export interface CalibrationResult {
    /**
     * @generated from protobuf field: bool success = 1
     */
    success: boolean;
    /**
     * @generated from protobuf field: string message = 2
     */
    message: string;
    /**
     * @generated from protobuf field: float reference_tare_counts = 3
     */
    referenceTareCounts: number; // 零点计数    /**
     * @generated from protobuf field: float counts_per_gram = 4
     */
    countsPerGram: number; // 每克计数    /**
     * @generated from protobuf field: float total_capacity_kg = 5
     */
    totalCapacityKg: number; // 总量程 (kg)}
/**
 * 阈值请求
 *
 * @generated from protobuf message enose.service.ThresholdRequest
 */
export interface ThresholdRequest {
    /**
     * @generated from protobuf field: float value = 1
     */
    value: number; // 阈值 (克)}
/**
 * 等待空瓶请求
 *
 * @generated from protobuf message enose.service.WaitForEmptyBottleRequest
 */
export interface WaitForEmptyBottleRequest {
    /**
     * @generated from protobuf field: float tolerance = 1
     */
    tolerance: number; // 容差 (g)，默认 30    /**
     * @generated from protobuf field: float timeout_sec = 2
     */
    timeoutSec: number; // 超时时间 (s)，默认 60    /**
     * @generated from protobuf field: float stability_window_sec = 3
     */
    stabilityWindowSec: number; // 稳定窗口 (s)，默认 5}
/**
 * 等待空瓶响应
 *
 * @generated from protobuf message enose.service.WaitForEmptyBottleResponse
 */
export interface WaitForEmptyBottleResponse {
    /**
     * @generated from protobuf field: bool success = 1
     */
    success: boolean; // 是否成功    /**
     * @generated from protobuf field: float empty_weight = 2
     */
    emptyWeight: number; // 稳定后的空瓶重量 (g)    /**
     * @generated from protobuf field: string error_message = 3
     */
    errorMessage: string; // 错误信息（如超时）}
/**
 * 动态空瓶值响应
 *
 * @generated from protobuf message enose.service.DynamicEmptyWeightResponse
 */
export interface DynamicEmptyWeightResponse {
    /**
     * @generated from protobuf field: bool has_value = 1
     */
    hasValue: boolean; // 是否有动态空瓶值    /**
     * @generated from protobuf field: float empty_weight = 2
     */
    emptyWeight: number; // 动态空瓶值 (g)}
/**
 * 称重业务配置
 *
 * @generated from protobuf message enose.service.LoadCellConfig
 */
export interface LoadCellConfig {
    /**
     * @generated from protobuf field: float overflow_threshold = 1
     */
    overflowThreshold: number; // 溢出警告阈值 (g)    /**
     * @generated from protobuf field: float drain_complete_margin = 2
     */
    drainCompleteMargin: number; // 排空完成余量 (g)    /**
     * @generated from protobuf field: float stable_threshold = 3
     */
    stableThreshold: number; // 稳定判断阈值 (g)    /**
     * @generated from protobuf field: string last_calibration_time = 4
     */
    lastCalibrationTime: string; // 最后标定时间}
// ============================================================// 测试服务消息定义// ============================================================

/**
 * 单组参数配置
 *
 * @generated from protobuf message enose.service.ParamSet
 */
export interface ParamSet {
    /**
     * @generated from protobuf field: int32 id = 1
     */
    id: number;
    /**
     * @generated from protobuf field: string name = 2
     */
    name: string;
    /**
     * @generated from protobuf field: float pump2_volume = 3
     */
    pump2Volume: number; // 泵2进样量 (mm)    /**
     * @generated from protobuf field: float pump3_volume = 4
     */
    pump3Volume: number; // 泵3进样量 (mm)    /**
     * @generated from protobuf field: float pump4_volume = 5
     */
    pump4Volume: number; // 泵4进样量 (mm)    /**
     * @generated from protobuf field: float pump5_volume = 6
     */
    pump5Volume: number; // 泵5进样量 (mm)    /**
     * @generated from protobuf field: float speed = 7
     */
    speed: number; // 进样速度 (mm/s)    /**
     * @generated from protobuf field: int32 cycles = 8
     */
    cycles: number; // 循环次数}
/**
 * 启动测试请求
 *
 * @generated from protobuf message enose.service.StartTestRequest
 */
export interface StartTestRequest {
    /**
     * @generated from protobuf field: repeated enose.service.ParamSet param_sets = 1
     */
    paramSets: ParamSet[]; // 参数组列表    /**
     * @generated from protobuf field: float accel = 2
     */
    accel: number; // 加速度 (mm/s²)    /**
     * @generated from protobuf field: float empty_tolerance = 3
     */
    emptyTolerance: number; // 空瓶容差 (g)    /**
     * @generated from protobuf field: float drain_stability_window = 4
     */
    drainStabilityWindow: number; // 排废稳定窗口 (s)}
/**
 * 测试状态响应
 *
 * @generated from protobuf message enose.service.TestStatusResponse
 */
export interface TestStatusResponse {
    /**
     * @generated from protobuf field: enose.service.TestState state = 1
     */
    state: TestState; // 当前状态    /**
     * @generated from protobuf field: int32 current_param_set = 2
     */
    currentParamSet: number; // 当前参数组索引 (1-based)    /**
     * @generated from protobuf field: int32 total_param_sets = 3
     */
    totalParamSets: number; // 总参数组数    /**
     * @generated from protobuf field: int32 current_cycle = 4
     */
    currentCycle: number; // 当前循环 (1-based)    /**
     * @generated from protobuf field: int32 total_cycles = 5
     */
    totalCycles: number; // 当前参数组总循环数    /**
     * @generated from protobuf field: int32 global_cycle = 6
     */
    globalCycle: number; // 全局循环计数    /**
     * @generated from protobuf field: int32 global_total_cycles = 7
     */
    globalTotalCycles: number; // 全局总循环数    /**
     * @generated from protobuf field: string current_param_name = 8
     */
    currentParamName: string; // 当前参数组名称    /**
     * @generated from protobuf field: string message = 9
     */
    message: string; // 状态消息/日志    /**
     * @generated from protobuf field: repeated string logs = 10
     */
    logs: string[]; // 最近日志列表    /**
     * @generated from protobuf field: float dynamic_empty_weight = 11
     */
    dynamicEmptyWeight: number; // 当前动态空瓶值    /**
     * @generated from protobuf field: bool has_dynamic_empty_weight = 12
     */
    hasDynamicEmptyWeight: boolean; // 是否有动态空瓶值}
/**
 * 单次测试结果
 *
 * @generated from protobuf message enose.service.TestResult
 */
export interface TestResult {
    /**
     * @generated from protobuf field: int32 param_set_id = 1
     */
    paramSetId: number;
    /**
     * @generated from protobuf field: string param_set_name = 2
     */
    paramSetName: string;
    /**
     * @generated from protobuf field: int32 cycle = 3
     */
    cycle: number;
    /**
     * @generated from protobuf field: float total_volume = 4
     */
    totalVolume: number; // 设定总量 (mm)    /**
     * @generated from protobuf field: float pump2_volume = 5
     */
    pump2Volume: number;
    /**
     * @generated from protobuf field: float pump3_volume = 6
     */
    pump3Volume: number;
    /**
     * @generated from protobuf field: float pump4_volume = 7
     */
    pump4Volume: number;
    /**
     * @generated from protobuf field: float pump5_volume = 8
     */
    pump5Volume: number;
    /**
     * @generated from protobuf field: float speed = 9
     */
    speed: number;
    /**
     * @generated from protobuf field: float empty_weight = 10
     */
    emptyWeight: number; // 空瓶重量 (g)    /**
     * @generated from protobuf field: float full_weight = 11
     */
    fullWeight: number; // 进样后重量 (g)    /**
     * @generated from protobuf field: float injected_weight = 12
     */
    injectedWeight: number; // 实际进样重量 (g)    /**
     * @generated from protobuf field: int64 drain_duration_ms = 13
     */
    drainDurationMs: string; // 排废耗时 (ms)    /**
     * @generated from protobuf field: int64 wait_empty_duration_ms = 14
     */
    waitEmptyDurationMs: string; // 等待空瓶耗时 (ms)    /**
     * @generated from protobuf field: int64 inject_duration_ms = 15
     */
    injectDurationMs: string; // 进样耗时 (ms)    /**
     * @generated from protobuf field: int64 wait_stable_duration_ms = 16
     */
    waitStableDurationMs: string; // 等待稳定耗时 (ms)    /**
     * @generated from protobuf field: int64 total_duration_ms = 17
     */
    totalDurationMs: string; // 总耗时 (ms)    /**
     * @generated from protobuf field: google.protobuf.Timestamp timestamp = 18
     */
    timestamp?: Timestamp;
}
/**
 * 测试结果响应
 *
 * @generated from protobuf message enose.service.TestResultsResponse
 */
export interface TestResultsResponse {
    /**
     * @generated from protobuf field: repeated enose.service.TestResult results = 1
     */
    results: TestResult[];
    /**
     * @generated from protobuf field: int32 total_count = 2
     */
    totalCount: number;
}
// ============================================================// 请求/响应消息定义// ============================================================

/**
 * 系统状态枚举
 *
 * @generated from protobuf enum enose.service.SystemStateEnum
 */
export enum SystemStateEnum {
    /**
     * @generated from protobuf enum value: SYSTEM_STATE_UNSPECIFIED = 0;
     */
    SYSTEM_STATE_UNSPECIFIED = 0,
    /**
     * 开机初始状态
     *
     * @generated from protobuf enum value: INITIAL = 1;
     */
    INITIAL = 1,
    /**
     * 排废状态
     *
     * @generated from protobuf enum value: DRAIN = 2;
     */
    DRAIN = 2,
    /**
     * 清洗状态: 出气阀开, 气体三通阀指向大气, 清洗泵开, 夹管阀液路, 排废阀关
     *
     * @generated from protobuf enum value: CLEAN = 3;
     */
    CLEAN = 3,
    /**
     * 采样状态: 排废关, 夹管阀气路, 出气阀开, 三通阀指向气室, 气泵开
     *
     * @generated from protobuf enum value: SAMPLE = 4;
     */
    SAMPLE = 4,
    /**
     * 进样状态: 阀门同CLEAN, 使用蠕动泵进样
     *
     * @generated from protobuf enum value: INJECT = 5;
     */
    INJECT = 5
}
/**
 * 测试状态枚举
 *
 * @generated from protobuf enum enose.service.TestState
 */
export enum TestState {
    /**
     * @generated from protobuf enum value: TEST_STATE_UNSPECIFIED = 0;
     */
    TEST_STATE_UNSPECIFIED = 0,
    /**
     * 空闲
     *
     * @generated from protobuf enum value: TEST_IDLE = 1;
     */
    TEST_IDLE = 1,
    /**
     * 排废中
     *
     * @generated from protobuf enum value: TEST_DRAINING = 2;
     */
    TEST_DRAINING = 2,
    /**
     * 等待空瓶稳定
     *
     * @generated from protobuf enum value: TEST_WAITING_EMPTY = 3;
     */
    TEST_WAITING_EMPTY = 3,
    /**
     * 进样中
     *
     * @generated from protobuf enum value: TEST_INJECTING = 4;
     */
    TEST_INJECTING = 4,
    /**
     * 等待称重稳定
     *
     * @generated from protobuf enum value: TEST_WAITING_STABLE = 5;
     */
    TEST_WAITING_STABLE = 5,
    /**
     * 测试完成
     *
     * @generated from protobuf enum value: TEST_COMPLETE = 6;
     */
    TEST_COMPLETE = 6,
    /**
     * 错误状态
     *
     * @generated from protobuf enum value: TEST_ERROR = 7;
     */
    TEST_ERROR = 7,
    /**
     * 正在停止
     *
     * @generated from protobuf enum value: TEST_STOPPING = 8;
     */
    TEST_STOPPING = 8
}
// @generated message type with reflection information, may provide speed optimized methods
class SystemStatus$Type extends MessageType<SystemStatus> {
    constructor() {
        super("enose.service.SystemStatus", [
            { no: 1, name: "current_state", kind: "enum", T: () => ["enose.service.SystemStateEnum", SystemStateEnum] },
            { no: 2, name: "peripheral_status", kind: "message", T: () => PeripheralStatus },
            { no: 3, name: "uptime_seconds", kind: "scalar", T: 4 /*ScalarType.UINT64*/ },
            { no: 4, name: "moonraker_connected", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "sensor_connected", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "firmware_ready", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "last_updated", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<SystemStatus>): SystemStatus {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.currentState = 0;
        message.uptimeSeconds = "0";
        message.moonrakerConnected = false;
        message.sensorConnected = false;
        message.firmwareReady = false;
        if (value !== undefined)
            reflectionMergePartial<SystemStatus>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SystemStatus): SystemStatus {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* enose.service.SystemStateEnum current_state */ 1:
                    message.currentState = reader.int32();
                    break;
                case /* enose.service.PeripheralStatus peripheral_status */ 2:
                    message.peripheralStatus = PeripheralStatus.internalBinaryRead(reader, reader.uint32(), options, message.peripheralStatus);
                    break;
                case /* uint64 uptime_seconds */ 3:
                    message.uptimeSeconds = reader.uint64().toString();
                    break;
                case /* bool moonraker_connected */ 4:
                    message.moonrakerConnected = reader.bool();
                    break;
                case /* bool sensor_connected */ 5:
                    message.sensorConnected = reader.bool();
                    break;
                case /* bool firmware_ready */ 7:
                    message.firmwareReady = reader.bool();
                    break;
                case /* google.protobuf.Timestamp last_updated */ 6:
                    message.lastUpdated = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.lastUpdated);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SystemStatus, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* enose.service.SystemStateEnum current_state = 1; */
        if (message.currentState !== 0)
            writer.tag(1, WireType.Varint).int32(message.currentState);
        /* enose.service.PeripheralStatus peripheral_status = 2; */
        if (message.peripheralStatus)
            PeripheralStatus.internalBinaryWrite(message.peripheralStatus, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* uint64 uptime_seconds = 3; */
        if (message.uptimeSeconds !== "0")
            writer.tag(3, WireType.Varint).uint64(message.uptimeSeconds);
        /* bool moonraker_connected = 4; */
        if (message.moonrakerConnected !== false)
            writer.tag(4, WireType.Varint).bool(message.moonrakerConnected);
        /* bool sensor_connected = 5; */
        if (message.sensorConnected !== false)
            writer.tag(5, WireType.Varint).bool(message.sensorConnected);
        /* google.protobuf.Timestamp last_updated = 6; */
        if (message.lastUpdated)
            Timestamp.internalBinaryWrite(message.lastUpdated, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* bool firmware_ready = 7; */
        if (message.firmwareReady !== false)
            writer.tag(7, WireType.Varint).bool(message.firmwareReady);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.service.SystemStatus
 */
export const SystemStatus = new SystemStatus$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PeripheralStatus$Type extends MessageType<PeripheralStatus> {
    constructor() {
        super("enose.service.PeripheralStatus", [
            { no: 1, name: "valve_waste", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "valve_pinch", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "valve_air", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "valve_outlet", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "air_pump_pwm", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 6, name: "cleaning_pump", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 7, name: "pump_2", kind: "enum", T: () => ["enose.service.PeripheralStatus.PumpRunState", PeripheralStatus_PumpRunState] },
            { no: 8, name: "pump_3", kind: "enum", T: () => ["enose.service.PeripheralStatus.PumpRunState", PeripheralStatus_PumpRunState] },
            { no: 9, name: "pump_4", kind: "enum", T: () => ["enose.service.PeripheralStatus.PumpRunState", PeripheralStatus_PumpRunState] },
            { no: 10, name: "pump_5", kind: "enum", T: () => ["enose.service.PeripheralStatus.PumpRunState", PeripheralStatus_PumpRunState] },
            { no: 11, name: "heater_chamber", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 20, name: "sensor_chamber_temp", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 21, name: "scale_weight", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<PeripheralStatus>): PeripheralStatus {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.valveWaste = 0;
        message.valvePinch = 0;
        message.valveAir = 0;
        message.valveOutlet = 0;
        message.airPumpPwm = 0;
        message.cleaningPump = 0;
        message.pump2 = 0;
        message.pump3 = 0;
        message.pump4 = 0;
        message.pump5 = 0;
        message.heaterChamber = 0;
        if (value !== undefined)
            reflectionMergePartial<PeripheralStatus>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PeripheralStatus): PeripheralStatus {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float valve_waste */ 1:
                    message.valveWaste = reader.float();
                    break;
                case /* float valve_pinch */ 2:
                    message.valvePinch = reader.float();
                    break;
                case /* float valve_air */ 3:
                    message.valveAir = reader.float();
                    break;
                case /* float valve_outlet */ 4:
                    message.valveOutlet = reader.float();
                    break;
                case /* float air_pump_pwm */ 5:
                    message.airPumpPwm = reader.float();
                    break;
                case /* float cleaning_pump */ 6:
                    message.cleaningPump = reader.float();
                    break;
                case /* enose.service.PeripheralStatus.PumpRunState pump_2 */ 7:
                    message.pump2 = reader.int32();
                    break;
                case /* enose.service.PeripheralStatus.PumpRunState pump_3 */ 8:
                    message.pump3 = reader.int32();
                    break;
                case /* enose.service.PeripheralStatus.PumpRunState pump_4 */ 9:
                    message.pump4 = reader.int32();
                    break;
                case /* enose.service.PeripheralStatus.PumpRunState pump_5 */ 10:
                    message.pump5 = reader.int32();
                    break;
                case /* float heater_chamber */ 11:
                    message.heaterChamber = reader.float();
                    break;
                case /* optional float sensor_chamber_temp */ 20:
                    message.sensorChamberTemp = reader.float();
                    break;
                case /* optional float scale_weight */ 21:
                    message.scaleWeight = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PeripheralStatus, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* float valve_waste = 1; */
        if (message.valveWaste !== 0)
            writer.tag(1, WireType.Bit32).float(message.valveWaste);
        /* float valve_pinch = 2; */
        if (message.valvePinch !== 0)
            writer.tag(2, WireType.Bit32).float(message.valvePinch);
        /* float valve_air = 3; */
        if (message.valveAir !== 0)
            writer.tag(3, WireType.Bit32).float(message.valveAir);
        /* float valve_outlet = 4; */
        if (message.valveOutlet !== 0)
            writer.tag(4, WireType.Bit32).float(message.valveOutlet);
        /* float air_pump_pwm = 5; */
        if (message.airPumpPwm !== 0)
            writer.tag(5, WireType.Bit32).float(message.airPumpPwm);
        /* float cleaning_pump = 6; */
        if (message.cleaningPump !== 0)
            writer.tag(6, WireType.Bit32).float(message.cleaningPump);
        /* enose.service.PeripheralStatus.PumpRunState pump_2 = 7; */
        if (message.pump2 !== 0)
            writer.tag(7, WireType.Varint).int32(message.pump2);
        /* enose.service.PeripheralStatus.PumpRunState pump_3 = 8; */
        if (message.pump3 !== 0)
            writer.tag(8, WireType.Varint).int32(message.pump3);
        /* enose.service.PeripheralStatus.PumpRunState pump_4 = 9; */
        if (message.pump4 !== 0)
            writer.tag(9, WireType.Varint).int32(message.pump4);
        /* enose.service.PeripheralStatus.PumpRunState pump_5 = 10; */
        if (message.pump5 !== 0)
            writer.tag(10, WireType.Varint).int32(message.pump5);
        /* float heater_chamber = 11; */
        if (message.heaterChamber !== 0)
            writer.tag(11, WireType.Bit32).float(message.heaterChamber);
        /* optional float sensor_chamber_temp = 20; */
        if (message.sensorChamberTemp !== undefined)
            writer.tag(20, WireType.Bit32).float(message.sensorChamberTemp);
        /* optional float scale_weight = 21; */
        if (message.scaleWeight !== undefined)
            writer.tag(21, WireType.Bit32).float(message.scaleWeight);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.service.PeripheralStatus
 */
export const PeripheralStatus = new PeripheralStatus$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetSystemStateRequest$Type extends MessageType<SetSystemStateRequest> {
    constructor() {
        super("enose.service.SetSystemStateRequest", [
            { no: 1, name: "target_state", kind: "enum", T: () => ["enose.service.SystemStateEnum", SystemStateEnum] }
        ]);
    }
    create(value?: PartialMessage<SetSystemStateRequest>): SetSystemStateRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.targetState = 0;
        if (value !== undefined)
            reflectionMergePartial<SetSystemStateRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetSystemStateRequest): SetSystemStateRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* enose.service.SystemStateEnum target_state */ 1:
                    message.targetState = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetSystemStateRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* enose.service.SystemStateEnum target_state = 1; */
        if (message.targetState !== 0)
            writer.tag(1, WireType.Varint).int32(message.targetState);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.service.SetSystemStateRequest
 */
export const SetSystemStateRequest = new SetSystemStateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetSystemStateResponse$Type extends MessageType<SetSystemStateResponse> {
    constructor() {
        super("enose.service.SetSystemStateResponse", [
            { no: 1, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "new_state", kind: "enum", T: () => ["enose.service.SystemStateEnum", SystemStateEnum] }
        ]);
    }
    create(value?: PartialMessage<SetSystemStateResponse>): SetSystemStateResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.success = false;
        message.message = "";
        message.newState = 0;
        if (value !== undefined)
            reflectionMergePartial<SetSystemStateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetSystemStateResponse): SetSystemStateResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool success */ 1:
                    message.success = reader.bool();
                    break;
                case /* string message */ 2:
                    message.message = reader.string();
                    break;
                case /* enose.service.SystemStateEnum new_state */ 3:
                    message.newState = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetSystemStateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool success = 1; */
        if (message.success !== false)
            writer.tag(1, WireType.Varint).bool(message.success);
        /* string message = 2; */
        if (message.message !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.message);
        /* enose.service.SystemStateEnum new_state = 3; */
        if (message.newState !== 0)
            writer.tag(3, WireType.Varint).int32(message.newState);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.service.SetSystemStateResponse
 */
export const SetSystemStateResponse = new SetSystemStateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ManualControlRequest$Type extends MessageType<ManualControlRequest> {
    constructor() {
        super("enose.service.ManualControlRequest", [
            { no: 1, name: "peripheral_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "value", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<ManualControlRequest>): ManualControlRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.peripheralName = "";
        message.value = 0;
        if (value !== undefined)
            reflectionMergePartial<ManualControlRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ManualControlRequest): ManualControlRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string peripheral_name */ 1:
                    message.peripheralName = reader.string();
                    break;
                case /* float value */ 2:
                    message.value = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ManualControlRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string peripheral_name = 1; */
        if (message.peripheralName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.peripheralName);
        /* float value = 2; */
        if (message.value !== 0)
            writer.tag(2, WireType.Bit32).float(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.service.ManualControlRequest
 */
export const ManualControlRequest = new ManualControlRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ManualControlResponse$Type extends MessageType<ManualControlResponse> {
    constructor() {
        super("enose.service.ManualControlResponse", [
            { no: 1, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ManualControlResponse>): ManualControlResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.success = false;
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial<ManualControlResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ManualControlResponse): ManualControlResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool success */ 1:
                    message.success = reader.bool();
                    break;
                case /* string message */ 2:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ManualControlResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool success = 1; */
        if (message.success !== false)
            writer.tag(1, WireType.Varint).bool(message.success);
        /* string message = 2; */
        if (message.message !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.service.ManualControlResponse
 */
export const ManualControlResponse = new ManualControlResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StartInjectionRequest$Type extends MessageType<StartInjectionRequest> {
    constructor() {
        super("enose.service.StartInjectionRequest", [
            { no: 1, name: "pump_2_volume", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "pump_3_volume", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "pump_4_volume", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "pump_5_volume", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "speed", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 6, name: "accel", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<StartInjectionRequest>): StartInjectionRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.pump2Volume = 0;
        message.pump3Volume = 0;
        message.pump4Volume = 0;
        message.pump5Volume = 0;
        if (value !== undefined)
            reflectionMergePartial<StartInjectionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StartInjectionRequest): StartInjectionRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float pump_2_volume */ 1:
                    message.pump2Volume = reader.float();
                    break;
                case /* float pump_3_volume */ 2:
                    message.pump3Volume = reader.float();
                    break;
                case /* float pump_4_volume */ 3:
                    message.pump4Volume = reader.float();
                    break;
                case /* float pump_5_volume */ 4:
                    message.pump5Volume = reader.float();
                    break;
                case /* optional float speed */ 5:
                    message.speed = reader.float();
                    break;
                case /* optional float accel */ 6:
                    message.accel = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StartInjectionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* float pump_2_volume = 1; */
        if (message.pump2Volume !== 0)
            writer.tag(1, WireType.Bit32).float(message.pump2Volume);
        /* float pump_3_volume = 2; */
        if (message.pump3Volume !== 0)
            writer.tag(2, WireType.Bit32).float(message.pump3Volume);
        /* float pump_4_volume = 3; */
        if (message.pump4Volume !== 0)
            writer.tag(3, WireType.Bit32).float(message.pump4Volume);
        /* float pump_5_volume = 4; */
        if (message.pump5Volume !== 0)
            writer.tag(4, WireType.Bit32).float(message.pump5Volume);
        /* optional float speed = 5; */
        if (message.speed !== undefined)
            writer.tag(5, WireType.Bit32).float(message.speed);
        /* optional float accel = 6; */
        if (message.accel !== undefined)
            writer.tag(6, WireType.Bit32).float(message.accel);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.service.StartInjectionRequest
 */
export const StartInjectionRequest = new StartInjectionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StartInjectionResponse$Type extends MessageType<StartInjectionResponse> {
    constructor() {
        super("enose.service.StartInjectionResponse", [
            { no: 1, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StartInjectionResponse>): StartInjectionResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.success = false;
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial<StartInjectionResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StartInjectionResponse): StartInjectionResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool success */ 1:
                    message.success = reader.bool();
                    break;
                case /* string message */ 2:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StartInjectionResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool success = 1; */
        if (message.success !== false)
            writer.tag(1, WireType.Varint).bool(message.success);
        /* string message = 2; */
        if (message.message !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.service.StartInjectionResponse
 */
export const StartInjectionResponse = new StartInjectionResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StopInjectionResponse$Type extends MessageType<StopInjectionResponse> {
    constructor() {
        super("enose.service.StopInjectionResponse", [
            { no: 1, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StopInjectionResponse>): StopInjectionResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.success = false;
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial<StopInjectionResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StopInjectionResponse): StopInjectionResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool success */ 1:
                    message.success = reader.bool();
                    break;
                case /* string message */ 2:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StopInjectionResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool success = 1; */
        if (message.success !== false)
            writer.tag(1, WireType.Varint).bool(message.success);
        /* string message = 2; */
        if (message.message !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.service.StopInjectionResponse
 */
export const StopInjectionResponse = new StopInjectionResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EmergencyStopResponse$Type extends MessageType<EmergencyStopResponse> {
    constructor() {
        super("enose.service.EmergencyStopResponse", [
            { no: 1, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<EmergencyStopResponse>): EmergencyStopResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.success = false;
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial<EmergencyStopResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EmergencyStopResponse): EmergencyStopResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool success */ 1:
                    message.success = reader.bool();
                    break;
                case /* string message */ 2:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EmergencyStopResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool success = 1; */
        if (message.success !== false)
            writer.tag(1, WireType.Varint).bool(message.success);
        /* string message = 2; */
        if (message.message !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.service.EmergencyStopResponse
 */
export const EmergencyStopResponse = new EmergencyStopResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FirmwareRestartResponse$Type extends MessageType<FirmwareRestartResponse> {
    constructor() {
        super("enose.service.FirmwareRestartResponse", [
            { no: 1, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<FirmwareRestartResponse>): FirmwareRestartResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.success = false;
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial<FirmwareRestartResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FirmwareRestartResponse): FirmwareRestartResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool success */ 1:
                    message.success = reader.bool();
                    break;
                case /* string message */ 2:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FirmwareRestartResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool success = 1; */
        if (message.success !== false)
            writer.tag(1, WireType.Varint).bool(message.success);
        /* string message = 2; */
        if (message.message !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.service.FirmwareRestartResponse
 */
export const FirmwareRestartResponse = new FirmwareRestartResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RunPumpRequest$Type extends MessageType<RunPumpRequest> {
    constructor() {
        super("enose.service.RunPumpRequest", [
            { no: 1, name: "pump_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "speed", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "distance", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "accel", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<RunPumpRequest>): RunPumpRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.pumpName = "";
        message.speed = 0;
        if (value !== undefined)
            reflectionMergePartial<RunPumpRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RunPumpRequest): RunPumpRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string pump_name */ 1:
                    message.pumpName = reader.string();
                    break;
                case /* float speed */ 2:
                    message.speed = reader.float();
                    break;
                case /* optional float distance */ 3:
                    message.distance = reader.float();
                    break;
                case /* optional float accel */ 4:
                    message.accel = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RunPumpRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string pump_name = 1; */
        if (message.pumpName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.pumpName);
        /* float speed = 2; */
        if (message.speed !== 0)
            writer.tag(2, WireType.Bit32).float(message.speed);
        /* optional float distance = 3; */
        if (message.distance !== undefined)
            writer.tag(3, WireType.Bit32).float(message.distance);
        /* optional float accel = 4; */
        if (message.accel !== undefined)
            writer.tag(4, WireType.Bit32).float(message.accel);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.service.RunPumpRequest
 */
export const RunPumpRequest = new RunPumpRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RunPumpResponse$Type extends MessageType<RunPumpResponse> {
    constructor() {
        super("enose.service.RunPumpResponse", [
            { no: 1, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RunPumpResponse>): RunPumpResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.success = false;
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial<RunPumpResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RunPumpResponse): RunPumpResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool success */ 1:
                    message.success = reader.bool();
                    break;
                case /* string message */ 2:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RunPumpResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool success = 1; */
        if (message.success !== false)
            writer.tag(1, WireType.Varint).bool(message.success);
        /* string message = 2; */
        if (message.message !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.service.RunPumpResponse
 */
export const RunPumpResponse = new RunPumpResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StopAllPumpsResponse$Type extends MessageType<StopAllPumpsResponse> {
    constructor() {
        super("enose.service.StopAllPumpsResponse", [
            { no: 1, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StopAllPumpsResponse>): StopAllPumpsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.success = false;
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial<StopAllPumpsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StopAllPumpsResponse): StopAllPumpsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool success */ 1:
                    message.success = reader.bool();
                    break;
                case /* string message */ 2:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StopAllPumpsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool success = 1; */
        if (message.success !== false)
            writer.tag(1, WireType.Varint).bool(message.success);
        /* string message = 2; */
        if (message.message !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.service.StopAllPumpsResponse
 */
export const StopAllPumpsResponse = new StopAllPumpsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SensorCommandRequest$Type extends MessageType<SensorCommandRequest> {
    constructor() {
        super("enose.service.SensorCommandRequest", [
            { no: 1, name: "command", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "params_json", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SensorCommandRequest>): SensorCommandRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.command = "";
        if (value !== undefined)
            reflectionMergePartial<SensorCommandRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SensorCommandRequest): SensorCommandRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string command */ 1:
                    message.command = reader.string();
                    break;
                case /* optional string params_json */ 2:
                    message.paramsJson = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SensorCommandRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string command = 1; */
        if (message.command !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.command);
        /* optional string params_json = 2; */
        if (message.paramsJson !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.paramsJson);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.service.SensorCommandRequest
 */
export const SensorCommandRequest = new SensorCommandRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SensorCommandResponse$Type extends MessageType<SensorCommandResponse> {
    constructor() {
        super("enose.service.SensorCommandResponse", [
            { no: 1, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "data_json", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SensorCommandResponse>): SensorCommandResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.success = false;
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial<SensorCommandResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SensorCommandResponse): SensorCommandResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool success */ 1:
                    message.success = reader.bool();
                    break;
                case /* string message */ 2:
                    message.message = reader.string();
                    break;
                case /* optional string data_json */ 3:
                    message.dataJson = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SensorCommandResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool success = 1; */
        if (message.success !== false)
            writer.tag(1, WireType.Varint).bool(message.success);
        /* string message = 2; */
        if (message.message !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.message);
        /* optional string data_json = 3; */
        if (message.dataJson !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.dataJson);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.service.SensorCommandResponse
 */
export const SensorCommandResponse = new SensorCommandResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SensorBoardStatus$Type extends MessageType<SensorBoardStatus> {
    constructor() {
        super("enose.service.SensorBoardStatus", [
            { no: 1, name: "connected", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "running", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "sensor_count", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "firmware_version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "port", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SensorBoardStatus>): SensorBoardStatus {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.connected = false;
        message.running = false;
        message.sensorCount = 0;
        message.firmwareVersion = "";
        message.port = "";
        if (value !== undefined)
            reflectionMergePartial<SensorBoardStatus>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SensorBoardStatus): SensorBoardStatus {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool connected */ 1:
                    message.connected = reader.bool();
                    break;
                case /* bool running */ 2:
                    message.running = reader.bool();
                    break;
                case /* uint32 sensor_count */ 3:
                    message.sensorCount = reader.uint32();
                    break;
                case /* string firmware_version */ 4:
                    message.firmwareVersion = reader.string();
                    break;
                case /* string port */ 5:
                    message.port = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SensorBoardStatus, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool connected = 1; */
        if (message.connected !== false)
            writer.tag(1, WireType.Varint).bool(message.connected);
        /* bool running = 2; */
        if (message.running !== false)
            writer.tag(2, WireType.Varint).bool(message.running);
        /* uint32 sensor_count = 3; */
        if (message.sensorCount !== 0)
            writer.tag(3, WireType.Varint).uint32(message.sensorCount);
        /* string firmware_version = 4; */
        if (message.firmwareVersion !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.firmwareVersion);
        /* string port = 5; */
        if (message.port !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.port);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.service.SensorBoardStatus
 */
export const SensorBoardStatus = new SensorBoardStatus$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SensorReading$Type extends MessageType<SensorReading> {
    constructor() {
        super("enose.service.SensorReading", [
            { no: 1, name: "tick_ms", kind: "scalar", T: 4 /*ScalarType.UINT64*/ },
            { no: 2, name: "sensor_idx", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "sensor_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "value", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 5, name: "sensor_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "temperature", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 7, name: "humidity", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 8, name: "pressure", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 9, name: "heater_step", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "adc_channel", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<SensorReading>): SensorReading {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tickMs = "0";
        message.sensorIdx = 0;
        message.sensorId = 0;
        message.value = 0;
        message.sensorType = "";
        message.heaterStep = 0;
        message.adcChannel = 0;
        if (value !== undefined)
            reflectionMergePartial<SensorReading>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SensorReading): SensorReading {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 tick_ms */ 1:
                    message.tickMs = reader.uint64().toString();
                    break;
                case /* uint32 sensor_idx */ 2:
                    message.sensorIdx = reader.uint32();
                    break;
                case /* uint32 sensor_id */ 3:
                    message.sensorId = reader.uint32();
                    break;
                case /* double value */ 4:
                    message.value = reader.double();
                    break;
                case /* string sensor_type */ 5:
                    message.sensorType = reader.string();
                    break;
                case /* optional double temperature */ 6:
                    message.temperature = reader.double();
                    break;
                case /* optional double humidity */ 7:
                    message.humidity = reader.double();
                    break;
                case /* optional double pressure */ 8:
                    message.pressure = reader.double();
                    break;
                case /* uint32 heater_step */ 9:
                    message.heaterStep = reader.uint32();
                    break;
                case /* uint32 adc_channel */ 10:
                    message.adcChannel = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SensorReading, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 tick_ms = 1; */
        if (message.tickMs !== "0")
            writer.tag(1, WireType.Varint).uint64(message.tickMs);
        /* uint32 sensor_idx = 2; */
        if (message.sensorIdx !== 0)
            writer.tag(2, WireType.Varint).uint32(message.sensorIdx);
        /* uint32 sensor_id = 3; */
        if (message.sensorId !== 0)
            writer.tag(3, WireType.Varint).uint32(message.sensorId);
        /* double value = 4; */
        if (message.value !== 0)
            writer.tag(4, WireType.Bit64).double(message.value);
        /* string sensor_type = 5; */
        if (message.sensorType !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.sensorType);
        /* optional double temperature = 6; */
        if (message.temperature !== undefined)
            writer.tag(6, WireType.Bit64).double(message.temperature);
        /* optional double humidity = 7; */
        if (message.humidity !== undefined)
            writer.tag(7, WireType.Bit64).double(message.humidity);
        /* optional double pressure = 8; */
        if (message.pressure !== undefined)
            writer.tag(8, WireType.Bit64).double(message.pressure);
        /* uint32 heater_step = 9; */
        if (message.heaterStep !== 0)
            writer.tag(9, WireType.Varint).uint32(message.heaterStep);
        /* uint32 adc_channel = 10; */
        if (message.adcChannel !== 0)
            writer.tag(10, WireType.Varint).uint32(message.adcChannel);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.service.SensorReading
 */
export const SensorReading = new SensorReading$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HeaterConfigRequest$Type extends MessageType<HeaterConfigRequest> {
    constructor() {
        super("enose.service.HeaterConfigRequest", [
            { no: 1, name: "temps", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "durs", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "sensors", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<HeaterConfigRequest>): HeaterConfigRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.temps = [];
        message.durs = [];
        message.sensors = [];
        if (value !== undefined)
            reflectionMergePartial<HeaterConfigRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HeaterConfigRequest): HeaterConfigRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated uint32 temps */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.temps.push(reader.uint32());
                    else
                        message.temps.push(reader.uint32());
                    break;
                case /* repeated uint32 durs */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.durs.push(reader.uint32());
                    else
                        message.durs.push(reader.uint32());
                    break;
                case /* repeated uint32 sensors */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.sensors.push(reader.uint32());
                    else
                        message.sensors.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HeaterConfigRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated uint32 temps = 1; */
        if (message.temps.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.temps.length; i++)
                writer.uint32(message.temps[i]);
            writer.join();
        }
        /* repeated uint32 durs = 2; */
        if (message.durs.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.durs.length; i++)
                writer.uint32(message.durs[i]);
            writer.join();
        }
        /* repeated uint32 sensors = 3; */
        if (message.sensors.length) {
            writer.tag(3, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.sensors.length; i++)
                writer.uint32(message.sensors[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.service.HeaterConfigRequest
 */
export const HeaterConfigRequest = new HeaterConfigRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HeaterConfigResponse$Type extends MessageType<HeaterConfigResponse> {
    constructor() {
        super("enose.service.HeaterConfigResponse", [
            { no: 1, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<HeaterConfigResponse>): HeaterConfigResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.success = false;
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial<HeaterConfigResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HeaterConfigResponse): HeaterConfigResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool success */ 1:
                    message.success = reader.bool();
                    break;
                case /* string message */ 2:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HeaterConfigResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool success = 1; */
        if (message.success !== false)
            writer.tag(1, WireType.Varint).bool(message.success);
        /* string message = 2; */
        if (message.message !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.service.HeaterConfigResponse
 */
export const HeaterConfigResponse = new HeaterConfigResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HeaterPreset$Type extends MessageType<HeaterPreset> {
    constructor() {
        super("enose.service.HeaterPreset", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "temps", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "durs", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<HeaterPreset>): HeaterPreset {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.description = "";
        message.temps = [];
        message.durs = [];
        if (value !== undefined)
            reflectionMergePartial<HeaterPreset>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HeaterPreset): HeaterPreset {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string description */ 2:
                    message.description = reader.string();
                    break;
                case /* repeated uint32 temps */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.temps.push(reader.uint32());
                    else
                        message.temps.push(reader.uint32());
                    break;
                case /* repeated uint32 durs */ 4:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.durs.push(reader.uint32());
                    else
                        message.durs.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HeaterPreset, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string description = 2; */
        if (message.description !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.description);
        /* repeated uint32 temps = 3; */
        if (message.temps.length) {
            writer.tag(3, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.temps.length; i++)
                writer.uint32(message.temps[i]);
            writer.join();
        }
        /* repeated uint32 durs = 4; */
        if (message.durs.length) {
            writer.tag(4, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.durs.length; i++)
                writer.uint32(message.durs[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.service.HeaterPreset
 */
export const HeaterPreset = new HeaterPreset$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LoadCellReading$Type extends MessageType<LoadCellReading> {
    constructor() {
        super("enose.service.LoadCellReading", [
            { no: 1, name: "weight_grams", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "raw_percent", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "is_calibrated", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "is_stable", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "trend", kind: "enum", T: () => ["enose.service.LoadCellReading.WeightTrend", LoadCellReading_WeightTrend] },
            { no: 6, name: "timestamp", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<LoadCellReading>): LoadCellReading {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.weightGrams = 0;
        message.rawPercent = 0;
        message.isCalibrated = false;
        message.isStable = false;
        message.trend = 0;
        if (value !== undefined)
            reflectionMergePartial<LoadCellReading>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LoadCellReading): LoadCellReading {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float weight_grams */ 1:
                    message.weightGrams = reader.float();
                    break;
                case /* float raw_percent */ 2:
                    message.rawPercent = reader.float();
                    break;
                case /* bool is_calibrated */ 3:
                    message.isCalibrated = reader.bool();
                    break;
                case /* bool is_stable */ 4:
                    message.isStable = reader.bool();
                    break;
                case /* enose.service.LoadCellReading.WeightTrend trend */ 5:
                    message.trend = reader.int32();
                    break;
                case /* google.protobuf.Timestamp timestamp */ 6:
                    message.timestamp = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.timestamp);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LoadCellReading, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* float weight_grams = 1; */
        if (message.weightGrams !== 0)
            writer.tag(1, WireType.Bit32).float(message.weightGrams);
        /* float raw_percent = 2; */
        if (message.rawPercent !== 0)
            writer.tag(2, WireType.Bit32).float(message.rawPercent);
        /* bool is_calibrated = 3; */
        if (message.isCalibrated !== false)
            writer.tag(3, WireType.Varint).bool(message.isCalibrated);
        /* bool is_stable = 4; */
        if (message.isStable !== false)
            writer.tag(4, WireType.Varint).bool(message.isStable);
        /* enose.service.LoadCellReading.WeightTrend trend = 5; */
        if (message.trend !== 0)
            writer.tag(5, WireType.Varint).int32(message.trend);
        /* google.protobuf.Timestamp timestamp = 6; */
        if (message.timestamp)
            Timestamp.internalBinaryWrite(message.timestamp, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.service.LoadCellReading
 */
export const LoadCellReading = new LoadCellReading$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CalibrationStatus$Type extends MessageType<CalibrationStatus> {
    constructor() {
        super("enose.service.CalibrationStatus", [
            { no: 1, name: "step", kind: "enum", T: () => ["enose.service.CalibrationStatus.CalibrationStep", CalibrationStatus_CalibrationStep] },
            { no: 2, name: "current_reading", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CalibrationStatus>): CalibrationStatus {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.step = 0;
        message.currentReading = 0;
        message.message = "";
        message.success = false;
        if (value !== undefined)
            reflectionMergePartial<CalibrationStatus>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CalibrationStatus): CalibrationStatus {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* enose.service.CalibrationStatus.CalibrationStep step */ 1:
                    message.step = reader.int32();
                    break;
                case /* float current_reading */ 2:
                    message.currentReading = reader.float();
                    break;
                case /* string message */ 3:
                    message.message = reader.string();
                    break;
                case /* bool success */ 4:
                    message.success = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CalibrationStatus, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* enose.service.CalibrationStatus.CalibrationStep step = 1; */
        if (message.step !== 0)
            writer.tag(1, WireType.Varint).int32(message.step);
        /* float current_reading = 2; */
        if (message.currentReading !== 0)
            writer.tag(2, WireType.Bit32).float(message.currentReading);
        /* string message = 3; */
        if (message.message !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.message);
        /* bool success = 4; */
        if (message.success !== false)
            writer.tag(4, WireType.Varint).bool(message.success);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.service.CalibrationStatus
 */
export const CalibrationStatus = new CalibrationStatus$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReferenceWeightRequest$Type extends MessageType<ReferenceWeightRequest> {
    constructor() {
        super("enose.service.ReferenceWeightRequest", [
            { no: 1, name: "weight_grams", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<ReferenceWeightRequest>): ReferenceWeightRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.weightGrams = 0;
        if (value !== undefined)
            reflectionMergePartial<ReferenceWeightRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReferenceWeightRequest): ReferenceWeightRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float weight_grams */ 1:
                    message.weightGrams = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReferenceWeightRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* float weight_grams = 1; */
        if (message.weightGrams !== 0)
            writer.tag(1, WireType.Bit32).float(message.weightGrams);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.service.ReferenceWeightRequest
 */
export const ReferenceWeightRequest = new ReferenceWeightRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CalibrationResult$Type extends MessageType<CalibrationResult> {
    constructor() {
        super("enose.service.CalibrationResult", [
            { no: 1, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "reference_tare_counts", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "counts_per_gram", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "total_capacity_kg", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<CalibrationResult>): CalibrationResult {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.success = false;
        message.message = "";
        message.referenceTareCounts = 0;
        message.countsPerGram = 0;
        message.totalCapacityKg = 0;
        if (value !== undefined)
            reflectionMergePartial<CalibrationResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CalibrationResult): CalibrationResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool success */ 1:
                    message.success = reader.bool();
                    break;
                case /* string message */ 2:
                    message.message = reader.string();
                    break;
                case /* float reference_tare_counts */ 3:
                    message.referenceTareCounts = reader.float();
                    break;
                case /* float counts_per_gram */ 4:
                    message.countsPerGram = reader.float();
                    break;
                case /* float total_capacity_kg */ 5:
                    message.totalCapacityKg = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CalibrationResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool success = 1; */
        if (message.success !== false)
            writer.tag(1, WireType.Varint).bool(message.success);
        /* string message = 2; */
        if (message.message !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.message);
        /* float reference_tare_counts = 3; */
        if (message.referenceTareCounts !== 0)
            writer.tag(3, WireType.Bit32).float(message.referenceTareCounts);
        /* float counts_per_gram = 4; */
        if (message.countsPerGram !== 0)
            writer.tag(4, WireType.Bit32).float(message.countsPerGram);
        /* float total_capacity_kg = 5; */
        if (message.totalCapacityKg !== 0)
            writer.tag(5, WireType.Bit32).float(message.totalCapacityKg);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.service.CalibrationResult
 */
export const CalibrationResult = new CalibrationResult$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ThresholdRequest$Type extends MessageType<ThresholdRequest> {
    constructor() {
        super("enose.service.ThresholdRequest", [
            { no: 1, name: "value", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<ThresholdRequest>): ThresholdRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.value = 0;
        if (value !== undefined)
            reflectionMergePartial<ThresholdRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ThresholdRequest): ThresholdRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float value */ 1:
                    message.value = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ThresholdRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* float value = 1; */
        if (message.value !== 0)
            writer.tag(1, WireType.Bit32).float(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.service.ThresholdRequest
 */
export const ThresholdRequest = new ThresholdRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WaitForEmptyBottleRequest$Type extends MessageType<WaitForEmptyBottleRequest> {
    constructor() {
        super("enose.service.WaitForEmptyBottleRequest", [
            { no: 1, name: "tolerance", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "timeout_sec", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "stability_window_sec", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<WaitForEmptyBottleRequest>): WaitForEmptyBottleRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tolerance = 0;
        message.timeoutSec = 0;
        message.stabilityWindowSec = 0;
        if (value !== undefined)
            reflectionMergePartial<WaitForEmptyBottleRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WaitForEmptyBottleRequest): WaitForEmptyBottleRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float tolerance */ 1:
                    message.tolerance = reader.float();
                    break;
                case /* float timeout_sec */ 2:
                    message.timeoutSec = reader.float();
                    break;
                case /* float stability_window_sec */ 3:
                    message.stabilityWindowSec = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WaitForEmptyBottleRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* float tolerance = 1; */
        if (message.tolerance !== 0)
            writer.tag(1, WireType.Bit32).float(message.tolerance);
        /* float timeout_sec = 2; */
        if (message.timeoutSec !== 0)
            writer.tag(2, WireType.Bit32).float(message.timeoutSec);
        /* float stability_window_sec = 3; */
        if (message.stabilityWindowSec !== 0)
            writer.tag(3, WireType.Bit32).float(message.stabilityWindowSec);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.service.WaitForEmptyBottleRequest
 */
export const WaitForEmptyBottleRequest = new WaitForEmptyBottleRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WaitForEmptyBottleResponse$Type extends MessageType<WaitForEmptyBottleResponse> {
    constructor() {
        super("enose.service.WaitForEmptyBottleResponse", [
            { no: 1, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "empty_weight", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "error_message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<WaitForEmptyBottleResponse>): WaitForEmptyBottleResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.success = false;
        message.emptyWeight = 0;
        message.errorMessage = "";
        if (value !== undefined)
            reflectionMergePartial<WaitForEmptyBottleResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WaitForEmptyBottleResponse): WaitForEmptyBottleResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool success */ 1:
                    message.success = reader.bool();
                    break;
                case /* float empty_weight */ 2:
                    message.emptyWeight = reader.float();
                    break;
                case /* string error_message */ 3:
                    message.errorMessage = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WaitForEmptyBottleResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool success = 1; */
        if (message.success !== false)
            writer.tag(1, WireType.Varint).bool(message.success);
        /* float empty_weight = 2; */
        if (message.emptyWeight !== 0)
            writer.tag(2, WireType.Bit32).float(message.emptyWeight);
        /* string error_message = 3; */
        if (message.errorMessage !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.errorMessage);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.service.WaitForEmptyBottleResponse
 */
export const WaitForEmptyBottleResponse = new WaitForEmptyBottleResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DynamicEmptyWeightResponse$Type extends MessageType<DynamicEmptyWeightResponse> {
    constructor() {
        super("enose.service.DynamicEmptyWeightResponse", [
            { no: 1, name: "has_value", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "empty_weight", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<DynamicEmptyWeightResponse>): DynamicEmptyWeightResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.hasValue = false;
        message.emptyWeight = 0;
        if (value !== undefined)
            reflectionMergePartial<DynamicEmptyWeightResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DynamicEmptyWeightResponse): DynamicEmptyWeightResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool has_value */ 1:
                    message.hasValue = reader.bool();
                    break;
                case /* float empty_weight */ 2:
                    message.emptyWeight = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DynamicEmptyWeightResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool has_value = 1; */
        if (message.hasValue !== false)
            writer.tag(1, WireType.Varint).bool(message.hasValue);
        /* float empty_weight = 2; */
        if (message.emptyWeight !== 0)
            writer.tag(2, WireType.Bit32).float(message.emptyWeight);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.service.DynamicEmptyWeightResponse
 */
export const DynamicEmptyWeightResponse = new DynamicEmptyWeightResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LoadCellConfig$Type extends MessageType<LoadCellConfig> {
    constructor() {
        super("enose.service.LoadCellConfig", [
            { no: 1, name: "overflow_threshold", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "drain_complete_margin", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "stable_threshold", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "last_calibration_time", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<LoadCellConfig>): LoadCellConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.overflowThreshold = 0;
        message.drainCompleteMargin = 0;
        message.stableThreshold = 0;
        message.lastCalibrationTime = "";
        if (value !== undefined)
            reflectionMergePartial<LoadCellConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LoadCellConfig): LoadCellConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float overflow_threshold */ 1:
                    message.overflowThreshold = reader.float();
                    break;
                case /* float drain_complete_margin */ 2:
                    message.drainCompleteMargin = reader.float();
                    break;
                case /* float stable_threshold */ 3:
                    message.stableThreshold = reader.float();
                    break;
                case /* string last_calibration_time */ 4:
                    message.lastCalibrationTime = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LoadCellConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* float overflow_threshold = 1; */
        if (message.overflowThreshold !== 0)
            writer.tag(1, WireType.Bit32).float(message.overflowThreshold);
        /* float drain_complete_margin = 2; */
        if (message.drainCompleteMargin !== 0)
            writer.tag(2, WireType.Bit32).float(message.drainCompleteMargin);
        /* float stable_threshold = 3; */
        if (message.stableThreshold !== 0)
            writer.tag(3, WireType.Bit32).float(message.stableThreshold);
        /* string last_calibration_time = 4; */
        if (message.lastCalibrationTime !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.lastCalibrationTime);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.service.LoadCellConfig
 */
export const LoadCellConfig = new LoadCellConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ParamSet$Type extends MessageType<ParamSet> {
    constructor() {
        super("enose.service.ParamSet", [
            { no: 1, name: "id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "pump2_volume", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "pump3_volume", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "pump4_volume", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 6, name: "pump5_volume", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 7, name: "speed", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 8, name: "cycles", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ParamSet>): ParamSet {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0;
        message.name = "";
        message.pump2Volume = 0;
        message.pump3Volume = 0;
        message.pump4Volume = 0;
        message.pump5Volume = 0;
        message.speed = 0;
        message.cycles = 0;
        if (value !== undefined)
            reflectionMergePartial<ParamSet>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ParamSet): ParamSet {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 id */ 1:
                    message.id = reader.int32();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* float pump2_volume */ 3:
                    message.pump2Volume = reader.float();
                    break;
                case /* float pump3_volume */ 4:
                    message.pump3Volume = reader.float();
                    break;
                case /* float pump4_volume */ 5:
                    message.pump4Volume = reader.float();
                    break;
                case /* float pump5_volume */ 6:
                    message.pump5Volume = reader.float();
                    break;
                case /* float speed */ 7:
                    message.speed = reader.float();
                    break;
                case /* int32 cycles */ 8:
                    message.cycles = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ParamSet, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).int32(message.id);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* float pump2_volume = 3; */
        if (message.pump2Volume !== 0)
            writer.tag(3, WireType.Bit32).float(message.pump2Volume);
        /* float pump3_volume = 4; */
        if (message.pump3Volume !== 0)
            writer.tag(4, WireType.Bit32).float(message.pump3Volume);
        /* float pump4_volume = 5; */
        if (message.pump4Volume !== 0)
            writer.tag(5, WireType.Bit32).float(message.pump4Volume);
        /* float pump5_volume = 6; */
        if (message.pump5Volume !== 0)
            writer.tag(6, WireType.Bit32).float(message.pump5Volume);
        /* float speed = 7; */
        if (message.speed !== 0)
            writer.tag(7, WireType.Bit32).float(message.speed);
        /* int32 cycles = 8; */
        if (message.cycles !== 0)
            writer.tag(8, WireType.Varint).int32(message.cycles);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.service.ParamSet
 */
export const ParamSet = new ParamSet$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StartTestRequest$Type extends MessageType<StartTestRequest> {
    constructor() {
        super("enose.service.StartTestRequest", [
            { no: 1, name: "param_sets", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ParamSet },
            { no: 2, name: "accel", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "empty_tolerance", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "drain_stability_window", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<StartTestRequest>): StartTestRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.paramSets = [];
        message.accel = 0;
        message.emptyTolerance = 0;
        message.drainStabilityWindow = 0;
        if (value !== undefined)
            reflectionMergePartial<StartTestRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StartTestRequest): StartTestRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated enose.service.ParamSet param_sets */ 1:
                    message.paramSets.push(ParamSet.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* float accel */ 2:
                    message.accel = reader.float();
                    break;
                case /* float empty_tolerance */ 3:
                    message.emptyTolerance = reader.float();
                    break;
                case /* float drain_stability_window */ 4:
                    message.drainStabilityWindow = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StartTestRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated enose.service.ParamSet param_sets = 1; */
        for (let i = 0; i < message.paramSets.length; i++)
            ParamSet.internalBinaryWrite(message.paramSets[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* float accel = 2; */
        if (message.accel !== 0)
            writer.tag(2, WireType.Bit32).float(message.accel);
        /* float empty_tolerance = 3; */
        if (message.emptyTolerance !== 0)
            writer.tag(3, WireType.Bit32).float(message.emptyTolerance);
        /* float drain_stability_window = 4; */
        if (message.drainStabilityWindow !== 0)
            writer.tag(4, WireType.Bit32).float(message.drainStabilityWindow);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.service.StartTestRequest
 */
export const StartTestRequest = new StartTestRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestStatusResponse$Type extends MessageType<TestStatusResponse> {
    constructor() {
        super("enose.service.TestStatusResponse", [
            { no: 1, name: "state", kind: "enum", T: () => ["enose.service.TestState", TestState] },
            { no: 2, name: "current_param_set", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "total_param_sets", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "current_cycle", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "total_cycles", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "global_cycle", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "global_total_cycles", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "current_param_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "logs", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "dynamic_empty_weight", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 12, name: "has_dynamic_empty_weight", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<TestStatusResponse>): TestStatusResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.state = 0;
        message.currentParamSet = 0;
        message.totalParamSets = 0;
        message.currentCycle = 0;
        message.totalCycles = 0;
        message.globalCycle = 0;
        message.globalTotalCycles = 0;
        message.currentParamName = "";
        message.message = "";
        message.logs = [];
        message.dynamicEmptyWeight = 0;
        message.hasDynamicEmptyWeight = false;
        if (value !== undefined)
            reflectionMergePartial<TestStatusResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestStatusResponse): TestStatusResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* enose.service.TestState state */ 1:
                    message.state = reader.int32();
                    break;
                case /* int32 current_param_set */ 2:
                    message.currentParamSet = reader.int32();
                    break;
                case /* int32 total_param_sets */ 3:
                    message.totalParamSets = reader.int32();
                    break;
                case /* int32 current_cycle */ 4:
                    message.currentCycle = reader.int32();
                    break;
                case /* int32 total_cycles */ 5:
                    message.totalCycles = reader.int32();
                    break;
                case /* int32 global_cycle */ 6:
                    message.globalCycle = reader.int32();
                    break;
                case /* int32 global_total_cycles */ 7:
                    message.globalTotalCycles = reader.int32();
                    break;
                case /* string current_param_name */ 8:
                    message.currentParamName = reader.string();
                    break;
                case /* string message */ 9:
                    message.message = reader.string();
                    break;
                case /* repeated string logs */ 10:
                    message.logs.push(reader.string());
                    break;
                case /* float dynamic_empty_weight */ 11:
                    message.dynamicEmptyWeight = reader.float();
                    break;
                case /* bool has_dynamic_empty_weight */ 12:
                    message.hasDynamicEmptyWeight = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestStatusResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* enose.service.TestState state = 1; */
        if (message.state !== 0)
            writer.tag(1, WireType.Varint).int32(message.state);
        /* int32 current_param_set = 2; */
        if (message.currentParamSet !== 0)
            writer.tag(2, WireType.Varint).int32(message.currentParamSet);
        /* int32 total_param_sets = 3; */
        if (message.totalParamSets !== 0)
            writer.tag(3, WireType.Varint).int32(message.totalParamSets);
        /* int32 current_cycle = 4; */
        if (message.currentCycle !== 0)
            writer.tag(4, WireType.Varint).int32(message.currentCycle);
        /* int32 total_cycles = 5; */
        if (message.totalCycles !== 0)
            writer.tag(5, WireType.Varint).int32(message.totalCycles);
        /* int32 global_cycle = 6; */
        if (message.globalCycle !== 0)
            writer.tag(6, WireType.Varint).int32(message.globalCycle);
        /* int32 global_total_cycles = 7; */
        if (message.globalTotalCycles !== 0)
            writer.tag(7, WireType.Varint).int32(message.globalTotalCycles);
        /* string current_param_name = 8; */
        if (message.currentParamName !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.currentParamName);
        /* string message = 9; */
        if (message.message !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.message);
        /* repeated string logs = 10; */
        for (let i = 0; i < message.logs.length; i++)
            writer.tag(10, WireType.LengthDelimited).string(message.logs[i]);
        /* float dynamic_empty_weight = 11; */
        if (message.dynamicEmptyWeight !== 0)
            writer.tag(11, WireType.Bit32).float(message.dynamicEmptyWeight);
        /* bool has_dynamic_empty_weight = 12; */
        if (message.hasDynamicEmptyWeight !== false)
            writer.tag(12, WireType.Varint).bool(message.hasDynamicEmptyWeight);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.service.TestStatusResponse
 */
export const TestStatusResponse = new TestStatusResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestResult$Type extends MessageType<TestResult> {
    constructor() {
        super("enose.service.TestResult", [
            { no: 1, name: "param_set_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "param_set_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "cycle", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "total_volume", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "pump2_volume", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 6, name: "pump3_volume", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 7, name: "pump4_volume", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 8, name: "pump5_volume", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 9, name: "speed", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 10, name: "empty_weight", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 11, name: "full_weight", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 12, name: "injected_weight", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 13, name: "drain_duration_ms", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 14, name: "wait_empty_duration_ms", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 15, name: "inject_duration_ms", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 16, name: "wait_stable_duration_ms", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 17, name: "total_duration_ms", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 18, name: "timestamp", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<TestResult>): TestResult {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.paramSetId = 0;
        message.paramSetName = "";
        message.cycle = 0;
        message.totalVolume = 0;
        message.pump2Volume = 0;
        message.pump3Volume = 0;
        message.pump4Volume = 0;
        message.pump5Volume = 0;
        message.speed = 0;
        message.emptyWeight = 0;
        message.fullWeight = 0;
        message.injectedWeight = 0;
        message.drainDurationMs = "0";
        message.waitEmptyDurationMs = "0";
        message.injectDurationMs = "0";
        message.waitStableDurationMs = "0";
        message.totalDurationMs = "0";
        if (value !== undefined)
            reflectionMergePartial<TestResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestResult): TestResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 param_set_id */ 1:
                    message.paramSetId = reader.int32();
                    break;
                case /* string param_set_name */ 2:
                    message.paramSetName = reader.string();
                    break;
                case /* int32 cycle */ 3:
                    message.cycle = reader.int32();
                    break;
                case /* float total_volume */ 4:
                    message.totalVolume = reader.float();
                    break;
                case /* float pump2_volume */ 5:
                    message.pump2Volume = reader.float();
                    break;
                case /* float pump3_volume */ 6:
                    message.pump3Volume = reader.float();
                    break;
                case /* float pump4_volume */ 7:
                    message.pump4Volume = reader.float();
                    break;
                case /* float pump5_volume */ 8:
                    message.pump5Volume = reader.float();
                    break;
                case /* float speed */ 9:
                    message.speed = reader.float();
                    break;
                case /* float empty_weight */ 10:
                    message.emptyWeight = reader.float();
                    break;
                case /* float full_weight */ 11:
                    message.fullWeight = reader.float();
                    break;
                case /* float injected_weight */ 12:
                    message.injectedWeight = reader.float();
                    break;
                case /* int64 drain_duration_ms */ 13:
                    message.drainDurationMs = reader.int64().toString();
                    break;
                case /* int64 wait_empty_duration_ms */ 14:
                    message.waitEmptyDurationMs = reader.int64().toString();
                    break;
                case /* int64 inject_duration_ms */ 15:
                    message.injectDurationMs = reader.int64().toString();
                    break;
                case /* int64 wait_stable_duration_ms */ 16:
                    message.waitStableDurationMs = reader.int64().toString();
                    break;
                case /* int64 total_duration_ms */ 17:
                    message.totalDurationMs = reader.int64().toString();
                    break;
                case /* google.protobuf.Timestamp timestamp */ 18:
                    message.timestamp = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.timestamp);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 param_set_id = 1; */
        if (message.paramSetId !== 0)
            writer.tag(1, WireType.Varint).int32(message.paramSetId);
        /* string param_set_name = 2; */
        if (message.paramSetName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.paramSetName);
        /* int32 cycle = 3; */
        if (message.cycle !== 0)
            writer.tag(3, WireType.Varint).int32(message.cycle);
        /* float total_volume = 4; */
        if (message.totalVolume !== 0)
            writer.tag(4, WireType.Bit32).float(message.totalVolume);
        /* float pump2_volume = 5; */
        if (message.pump2Volume !== 0)
            writer.tag(5, WireType.Bit32).float(message.pump2Volume);
        /* float pump3_volume = 6; */
        if (message.pump3Volume !== 0)
            writer.tag(6, WireType.Bit32).float(message.pump3Volume);
        /* float pump4_volume = 7; */
        if (message.pump4Volume !== 0)
            writer.tag(7, WireType.Bit32).float(message.pump4Volume);
        /* float pump5_volume = 8; */
        if (message.pump5Volume !== 0)
            writer.tag(8, WireType.Bit32).float(message.pump5Volume);
        /* float speed = 9; */
        if (message.speed !== 0)
            writer.tag(9, WireType.Bit32).float(message.speed);
        /* float empty_weight = 10; */
        if (message.emptyWeight !== 0)
            writer.tag(10, WireType.Bit32).float(message.emptyWeight);
        /* float full_weight = 11; */
        if (message.fullWeight !== 0)
            writer.tag(11, WireType.Bit32).float(message.fullWeight);
        /* float injected_weight = 12; */
        if (message.injectedWeight !== 0)
            writer.tag(12, WireType.Bit32).float(message.injectedWeight);
        /* int64 drain_duration_ms = 13; */
        if (message.drainDurationMs !== "0")
            writer.tag(13, WireType.Varint).int64(message.drainDurationMs);
        /* int64 wait_empty_duration_ms = 14; */
        if (message.waitEmptyDurationMs !== "0")
            writer.tag(14, WireType.Varint).int64(message.waitEmptyDurationMs);
        /* int64 inject_duration_ms = 15; */
        if (message.injectDurationMs !== "0")
            writer.tag(15, WireType.Varint).int64(message.injectDurationMs);
        /* int64 wait_stable_duration_ms = 16; */
        if (message.waitStableDurationMs !== "0")
            writer.tag(16, WireType.Varint).int64(message.waitStableDurationMs);
        /* int64 total_duration_ms = 17; */
        if (message.totalDurationMs !== "0")
            writer.tag(17, WireType.Varint).int64(message.totalDurationMs);
        /* google.protobuf.Timestamp timestamp = 18; */
        if (message.timestamp)
            Timestamp.internalBinaryWrite(message.timestamp, writer.tag(18, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.service.TestResult
 */
export const TestResult = new TestResult$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestResultsResponse$Type extends MessageType<TestResultsResponse> {
    constructor() {
        super("enose.service.TestResultsResponse", [
            { no: 1, name: "results", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TestResult },
            { no: 2, name: "total_count", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<TestResultsResponse>): TestResultsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.results = [];
        message.totalCount = 0;
        if (value !== undefined)
            reflectionMergePartial<TestResultsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestResultsResponse): TestResultsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated enose.service.TestResult results */ 1:
                    message.results.push(TestResult.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* int32 total_count */ 2:
                    message.totalCount = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestResultsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated enose.service.TestResult results = 1; */
        for (let i = 0; i < message.results.length; i++)
            TestResult.internalBinaryWrite(message.results[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* int32 total_count = 2; */
        if (message.totalCount !== 0)
            writer.tag(2, WireType.Varint).int32(message.totalCount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.service.TestResultsResponse
 */
export const TestResultsResponse = new TestResultsResponse$Type();
/**
 * @generated ServiceType for protobuf service enose.service.ControlService
 */
export const ControlService = new ServiceType("enose.service.ControlService", [
    { name: "GetStatus", options: {}, I: Empty, O: SystemStatus },
    { name: "SetSystemState", options: {}, I: SetSystemStateRequest, O: SetSystemStateResponse },
    { name: "ManualControl", options: {}, I: ManualControlRequest, O: ManualControlResponse },
    { name: "RunPump", options: {}, I: RunPumpRequest, O: RunPumpResponse },
    { name: "StopAllPumps", options: {}, I: Empty, O: StopAllPumpsResponse },
    { name: "StartInjection", options: {}, I: StartInjectionRequest, O: StartInjectionResponse },
    { name: "StopInjection", options: {}, I: Empty, O: StopInjectionResponse },
    { name: "EmergencyStop", options: {}, I: Empty, O: EmergencyStopResponse },
    { name: "FirmwareRestart", options: {}, I: Empty, O: FirmwareRestartResponse },
    { name: "SubscribeEvents", serverStreaming: true, options: {}, I: Empty, O: Event },
    { name: "SubscribePeripheralStatus", serverStreaming: true, options: {}, I: Empty, O: PeripheralStatus }
]);
/**
 * @generated ServiceType for protobuf service enose.service.DataService
 */
export const DataService = new ServiceType("enose.service.DataService", [
    { name: "SubscribeSensorData", serverStreaming: true, options: {}, I: Empty, O: SensorFrame },
    { name: "SubscribeAnalysisResults", serverStreaming: true, options: {}, I: Empty, O: AnalysisResult }
]);
/**
 * @generated ServiceType for protobuf service enose.service.SensorService
 */
export const SensorService = new ServiceType("enose.service.SensorService", [
    { name: "SendCommand", options: {}, I: SensorCommandRequest, O: SensorCommandResponse },
    { name: "SubscribeSensorReadings", serverStreaming: true, options: {}, I: Empty, O: SensorReading },
    { name: "GetSensorStatus", options: {}, I: Empty, O: SensorBoardStatus },
    { name: "ConfigureHeater", options: {}, I: HeaterConfigRequest, O: HeaterConfigResponse }
]);
/**
 * @generated ServiceType for protobuf service enose.service.LoadCellService
 */
export const LoadCellService = new ServiceType("enose.service.LoadCellService", [
    { name: "StartCalibration", options: {}, I: Empty, O: CalibrationStatus },
    { name: "SetZeroPoint", options: {}, I: Empty, O: CalibrationStatus },
    { name: "SetReferenceWeight", options: {}, I: ReferenceWeightRequest, O: CalibrationStatus },
    { name: "SaveCalibration", options: {}, I: Empty, O: CalibrationResult },
    { name: "CancelCalibration", options: {}, I: Empty, O: Empty },
    { name: "WaitForEmptyBottle", options: {}, I: WaitForEmptyBottleRequest, O: WaitForEmptyBottleResponse },
    { name: "ResetDynamicEmptyWeight", options: {}, I: Empty, O: Empty },
    { name: "GetDynamicEmptyWeight", options: {}, I: Empty, O: DynamicEmptyWeightResponse },
    { name: "SetOverflowThreshold", options: {}, I: ThresholdRequest, O: Empty },
    { name: "GetLoadCellConfig", options: {}, I: Empty, O: LoadCellConfig },
    { name: "SaveLoadCellConfig", options: {}, I: LoadCellConfig, O: Empty },
    { name: "Tare", options: {}, I: Empty, O: LoadCellReading },
    { name: "GetReading", options: {}, I: Empty, O: LoadCellReading },
    { name: "StreamReadings", serverStreaming: true, options: {}, I: Empty, O: LoadCellReading }
]);
/**
 * @generated ServiceType for protobuf service enose.service.TestService
 */
export const TestService = new ServiceType("enose.service.TestService", [
    { name: "StartTest", options: {}, I: StartTestRequest, O: TestStatusResponse },
    { name: "StopTest", options: {}, I: Empty, O: TestStatusResponse },
    { name: "GetTestStatus", options: {}, I: Empty, O: TestStatusResponse },
    { name: "GetTestResults", options: {}, I: Empty, O: TestResultsResponse },
    { name: "ClearTestResults", options: {}, I: Empty, O: Empty }
]);
