// @generated by protobuf-ts 2.11.1 with parameter long_type_string,generate_dependencies,client_grpc1,server_grpc1
// @generated from protobuf file "enose_consumable.proto" (package "enose.consumable", syntax proto3)
// tslint:disable
import { Empty } from "./google/protobuf/empty";
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Timestamp } from "./google/protobuf/timestamp";
/**
 * @generated from protobuf message enose.consumable.Liquid
 */
export interface Liquid {
    /**
     * @generated from protobuf field: int32 id = 1
     */
    id: number;
    /**
     * @generated from protobuf field: string name = 2
     */
    name: string;
    /**
     * @generated from protobuf field: enose.consumable.LiquidType type = 3
     */
    type: LiquidType;
    /**
     * @generated from protobuf field: string description = 4
     */
    description: string;
    /**
     * @generated from protobuf field: float density = 5
     */
    density: number;
    /**
     * @generated from protobuf field: string metadata_json = 6
     */
    metadataJson: string; // JSON 格式的动态元数据
    /**
     * @generated from protobuf field: bool is_active = 7
     */
    isActive: boolean;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp created_at = 8
     */
    createdAt?: Timestamp;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp updated_at = 9
     */
    updatedAt?: Timestamp;
}
/**
 * @generated from protobuf message enose.consumable.ListLiquidsRequest
 */
export interface ListLiquidsRequest {
    /**
     * @generated from protobuf field: enose.consumable.LiquidType type_filter = 1
     */
    typeFilter: LiquidType; // 可选：按类型过滤
    /**
     * @generated from protobuf field: bool include_inactive = 2
     */
    includeInactive: boolean; // 是否包含已禁用的
    /**
     * @generated from protobuf field: int32 limit = 3
     */
    limit: number;
    /**
     * @generated from protobuf field: int32 offset = 4
     */
    offset: number;
}
/**
 * @generated from protobuf message enose.consumable.LiquidListResponse
 */
export interface LiquidListResponse {
    /**
     * @generated from protobuf field: repeated enose.consumable.Liquid liquids = 1
     */
    liquids: Liquid[];
    /**
     * @generated from protobuf field: int32 total_count = 2
     */
    totalCount: number;
}
/**
 * @generated from protobuf message enose.consumable.GetLiquidRequest
 */
export interface GetLiquidRequest {
    /**
     * @generated from protobuf field: int32 id = 1
     */
    id: number;
}
/**
 * @generated from protobuf message enose.consumable.CreateLiquidRequest
 */
export interface CreateLiquidRequest {
    /**
     * @generated from protobuf field: string name = 1
     */
    name: string;
    /**
     * @generated from protobuf field: enose.consumable.LiquidType type = 2
     */
    type: LiquidType;
    /**
     * @generated from protobuf field: string description = 3
     */
    description: string;
    /**
     * @generated from protobuf field: float density = 4
     */
    density: number;
    /**
     * @generated from protobuf field: string metadata_json = 5
     */
    metadataJson: string;
}
/**
 * @generated from protobuf message enose.consumable.UpdateLiquidRequest
 */
export interface UpdateLiquidRequest {
    /**
     * @generated from protobuf field: int32 id = 1
     */
    id: number;
    /**
     * @generated from protobuf field: string name = 2
     */
    name: string;
    /**
     * @generated from protobuf field: enose.consumable.LiquidType type = 3
     */
    type: LiquidType;
    /**
     * @generated from protobuf field: string description = 4
     */
    description: string;
    /**
     * @generated from protobuf field: float density = 5
     */
    density: number;
    /**
     * @generated from protobuf field: string metadata_json = 6
     */
    metadataJson: string;
    /**
     * @generated from protobuf field: bool is_active = 7
     */
    isActive: boolean;
}
/**
 * @generated from protobuf message enose.consumable.DeleteLiquidRequest
 */
export interface DeleteLiquidRequest {
    /**
     * @generated from protobuf field: int32 id = 1
     */
    id: number;
}
// ============================================================
// 泵配置相关消息
// ============================================================

/**
 * @generated from protobuf message enose.consumable.PumpAssignment
 */
export interface PumpAssignment {
    /**
     * @generated from protobuf field: int32 pump_index = 1
     */
    pumpIndex: number; // 0-7
    /**
     * @generated from protobuf field: optional int32 liquid_id = 2
     */
    liquidId?: number;
    /**
     * @generated from protobuf field: optional enose.consumable.Liquid liquid = 3
     */
    liquid?: Liquid; // 关联的液体信息
    /**
     * @generated from protobuf field: string notes = 4
     */
    notes: string;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp updated_at = 5
     */
    updatedAt?: Timestamp;
    /**
     * 容量相关字段
     *
     * @generated from protobuf field: double initial_volume_ml = 6
     */
    initialVolumeMl: number; // 初始容量 (ml)
    /**
     * @generated from protobuf field: double consumed_volume_ml = 7
     */
    consumedVolumeMl: number; // 已消耗量 (ml)
    /**
     * @generated from protobuf field: double remaining_volume_ml = 8
     */
    remainingVolumeMl: number; // 剩余量 (ml) - 计算值
    /**
     * @generated from protobuf field: double low_volume_threshold_ml = 9
     */
    lowVolumeThresholdMl: number; // 低量预警阈值 (ml)
    /**
     * @generated from protobuf field: bool is_low_volume = 10
     */
    isLowVolume: boolean; // 是否低量
}
/**
 * @generated from protobuf message enose.consumable.PumpAssignmentsResponse
 */
export interface PumpAssignmentsResponse {
    /**
     * @generated from protobuf field: repeated enose.consumable.PumpAssignment assignments = 1
     */
    assignments: PumpAssignment[];
}
/**
 * @generated from protobuf message enose.consumable.SetPumpAssignmentRequest
 */
export interface SetPumpAssignmentRequest {
    /**
     * @generated from protobuf field: int32 pump_index = 1
     */
    pumpIndex: number;
    /**
     * @generated from protobuf field: optional int32 liquid_id = 2
     */
    liquidId?: number; // null 表示清空
    /**
     * @generated from protobuf field: string notes = 3
     */
    notes: string;
    /**
     * @generated from protobuf field: optional double initial_volume_ml = 4
     */
    initialVolumeMl?: number; // 初始容量
    /**
     * @generated from protobuf field: optional double low_volume_threshold_ml = 5
     */
    lowVolumeThresholdMl?: number; // 低量阈值
}
/**
 * @generated from protobuf message enose.consumable.SetPumpVolumeRequest
 */
export interface SetPumpVolumeRequest {
    /**
     * @generated from protobuf field: int32 pump_index = 1
     */
    pumpIndex: number;
    /**
     * @generated from protobuf field: double initial_volume_ml = 2
     */
    initialVolumeMl: number; // 新的初始容量
    /**
     * @generated from protobuf field: optional double low_volume_threshold_ml = 3
     */
    lowVolumeThresholdMl?: number; // 低量阈值
    /**
     * @generated from protobuf field: bool reset_consumed = 4
     */
    resetConsumed: boolean; // 是否重置已消耗量
}
/**
 * @generated from protobuf message enose.consumable.AddPumpConsumptionRequest
 */
export interface AddPumpConsumptionRequest {
    /**
     * @generated from protobuf field: int32 pump_index = 1
     */
    pumpIndex: number;
    /**
     * @generated from protobuf field: double volume_ml = 2
     */
    volumeMl: number; // 消耗量
    /**
     * @generated from protobuf field: optional int32 experiment_id = 3
     */
    experimentId?: number; // 关联实验ID
}
/**
 * @generated from protobuf message enose.consumable.Consumable
 */
export interface Consumable {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * @generated from protobuf field: string name = 2
     */
    name: string;
    /**
     * @generated from protobuf field: enose.consumable.ConsumableType type = 3
     */
    type: ConsumableType;
    /**
     * @generated from protobuf field: int64 accumulated_seconds = 4
     */
    accumulatedSeconds: string;
    /**
     * @generated from protobuf field: int64 lifetime_seconds = 5
     */
    lifetimeSeconds: string;
    /**
     * @generated from protobuf field: float warning_threshold = 6
     */
    warningThreshold: number;
    /**
     * @generated from protobuf field: float critical_threshold = 7
     */
    criticalThreshold: number;
    /**
     * @generated from protobuf field: enose.consumable.ConsumableStatus status = 8
     */
    status: ConsumableStatus;
    /**
     * @generated from protobuf field: float remaining_ratio = 9
     */
    remainingRatio: number; // 剩余比例 (0-1)
    /**
     * @generated from protobuf field: int64 remaining_seconds = 10
     */
    remainingSeconds: string; // 剩余秒数
    /**
     * @generated from protobuf field: google.protobuf.Timestamp last_reset_at = 11
     */
    lastResetAt?: Timestamp;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp updated_at = 12
     */
    updatedAt?: Timestamp;
}
/**
 * @generated from protobuf message enose.consumable.ConsumableStatusResponse
 */
export interface ConsumableStatusResponse {
    /**
     * @generated from protobuf field: repeated enose.consumable.Consumable consumables = 1
     */
    consumables: Consumable[];
    /**
     * 汇总信息
     *
     * @generated from protobuf field: int32 warning_count = 2
     */
    warningCount: number;
    /**
     * @generated from protobuf field: int32 critical_count = 3
     */
    criticalCount: number;
}
/**
 * @generated from protobuf message enose.consumable.ResetConsumableRequest
 */
export interface ResetConsumableRequest {
    /**
     * @generated from protobuf field: string consumable_id = 1
     */
    consumableId: string;
    /**
     * @generated from protobuf field: string notes = 2
     */
    notes: string;
}
/**
 * @generated from protobuf message enose.consumable.UpdateLifetimeRequest
 */
export interface UpdateLifetimeRequest {
    /**
     * @generated from protobuf field: string consumable_id = 1
     */
    consumableId: string;
    /**
     * @generated from protobuf field: int64 lifetime_seconds = 2
     */
    lifetimeSeconds: string;
}
/**
 * @generated from protobuf message enose.consumable.MetadataField
 */
export interface MetadataField {
    /**
     * @generated from protobuf field: int32 id = 1
     */
    id: number;
    /**
     * @generated from protobuf field: string entity_type = 2
     */
    entityType: string;
    /**
     * @generated from protobuf field: string field_key = 3
     */
    fieldKey: string;
    /**
     * @generated from protobuf field: string field_name = 4
     */
    fieldName: string;
    /**
     * @generated from protobuf field: enose.consumable.FieldType field_type = 5
     */
    fieldType: FieldType;
    /**
     * @generated from protobuf field: string description = 6
     */
    description: string;
    /**
     * @generated from protobuf field: bool is_required = 7
     */
    isRequired: boolean;
    /**
     * @generated from protobuf field: string default_value = 8
     */
    defaultValue: string;
    /**
     * @generated from protobuf field: string options_json = 9
     */
    optionsJson: string;
    /**
     * @generated from protobuf field: int32 display_order = 10
     */
    displayOrder: number;
    /**
     * @generated from protobuf field: bool is_active = 11
     */
    isActive: boolean;
}
/**
 * @generated from protobuf message enose.consumable.ListMetadataFieldsRequest
 */
export interface ListMetadataFieldsRequest {
    /**
     * @generated from protobuf field: string entity_type = 1
     */
    entityType: string;
    /**
     * @generated from protobuf field: bool include_inactive = 2
     */
    includeInactive: boolean;
}
/**
 * @generated from protobuf message enose.consumable.MetadataFieldListResponse
 */
export interface MetadataFieldListResponse {
    /**
     * @generated from protobuf field: repeated enose.consumable.MetadataField fields = 1
     */
    fields: MetadataField[];
}
/**
 * @generated from protobuf message enose.consumable.CreateMetadataFieldRequest
 */
export interface CreateMetadataFieldRequest {
    /**
     * @generated from protobuf field: string entity_type = 1
     */
    entityType: string;
    /**
     * @generated from protobuf field: string field_key = 2
     */
    fieldKey: string;
    /**
     * @generated from protobuf field: string field_name = 3
     */
    fieldName: string;
    /**
     * @generated from protobuf field: enose.consumable.FieldType field_type = 4
     */
    fieldType: FieldType;
    /**
     * @generated from protobuf field: string description = 5
     */
    description: string;
    /**
     * @generated from protobuf field: bool is_required = 6
     */
    isRequired: boolean;
    /**
     * @generated from protobuf field: string default_value = 7
     */
    defaultValue: string;
    /**
     * @generated from protobuf field: string options_json = 8
     */
    optionsJson: string;
    /**
     * @generated from protobuf field: int32 display_order = 9
     */
    displayOrder: number;
}
/**
 * @generated from protobuf message enose.consumable.UpdateMetadataFieldRequest
 */
export interface UpdateMetadataFieldRequest {
    /**
     * @generated from protobuf field: int32 id = 1
     */
    id: number;
    /**
     * @generated from protobuf field: string field_name = 2
     */
    fieldName: string;
    /**
     * @generated from protobuf field: string description = 3
     */
    description: string;
    /**
     * @generated from protobuf field: bool is_required = 4
     */
    isRequired: boolean;
    /**
     * @generated from protobuf field: string default_value = 5
     */
    defaultValue: string;
    /**
     * @generated from protobuf field: string options_json = 6
     */
    optionsJson: string;
    /**
     * @generated from protobuf field: int32 display_order = 7
     */
    displayOrder: number;
    /**
     * @generated from protobuf field: bool is_active = 8
     */
    isActive: boolean;
}
/**
 * @generated from protobuf message enose.consumable.DeleteMetadataFieldRequest
 */
export interface DeleteMetadataFieldRequest {
    /**
     * @generated from protobuf field: int32 id = 1
     */
    id: number;
}
// ============================================================
// 液体相关消息
// ============================================================

/**
 * @generated from protobuf enum enose.consumable.LiquidType
 */
export enum LiquidType {
    /**
     * @generated from protobuf enum value: LIQUID_TYPE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: LIQUID_TYPE_SAMPLE = 1;
     */
    SAMPLE = 1,
    /**
     * @generated from protobuf enum value: LIQUID_TYPE_RINSE = 2;
     */
    RINSE = 2,
    /**
     * @generated from protobuf enum value: LIQUID_TYPE_OTHER = 3;
     */
    OTHER = 3
}
// ============================================================
// 耗材相关消息
// ============================================================

/**
 * @generated from protobuf enum enose.consumable.ConsumableType
 */
export enum ConsumableType {
    /**
     * @generated from protobuf enum value: CONSUMABLE_TYPE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: CONSUMABLE_TYPE_PUMP_TUBE = 1;
     */
    PUMP_TUBE = 1,
    /**
     * @generated from protobuf enum value: CONSUMABLE_TYPE_CARBON_FILTER = 2;
     */
    CARBON_FILTER = 2,
    /**
     * @generated from protobuf enum value: CONSUMABLE_TYPE_VACUUM_FILTER = 3;
     */
    VACUUM_FILTER = 3
}
/**
 * @generated from protobuf enum enose.consumable.ConsumableStatus
 */
export enum ConsumableStatus {
    /**
     * @generated from protobuf enum value: CONSUMABLE_STATUS_OK = 0;
     */
    OK = 0,
    /**
     * @generated from protobuf enum value: CONSUMABLE_STATUS_WARNING = 1;
     */
    WARNING = 1,
    /**
     * @generated from protobuf enum value: CONSUMABLE_STATUS_CRITICAL = 2;
     */
    CRITICAL = 2
}
// ============================================================
// 元数据字段相关消息
// ============================================================

/**
 * @generated from protobuf enum enose.consumable.FieldType
 */
export enum FieldType {
    /**
     * @generated from protobuf enum value: FIELD_TYPE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: FIELD_TYPE_STRING = 1;
     */
    STRING = 1,
    /**
     * @generated from protobuf enum value: FIELD_TYPE_NUMBER = 2;
     */
    NUMBER = 2,
    /**
     * @generated from protobuf enum value: FIELD_TYPE_BOOLEAN = 3;
     */
    BOOLEAN = 3,
    /**
     * @generated from protobuf enum value: FIELD_TYPE_SELECT = 4;
     */
    SELECT = 4,
    /**
     * @generated from protobuf enum value: FIELD_TYPE_MULTI_SELECT = 5;
     */
    MULTI_SELECT = 5,
    /**
     * @generated from protobuf enum value: FIELD_TYPE_TAGS = 6;
     */
    TAGS = 6,
    /**
     * @generated from protobuf enum value: FIELD_TYPE_RICH_TEXT = 7;
     */
    RICH_TEXT = 7,
    /**
     * @generated from protobuf enum value: FIELD_TYPE_IMAGE = 8;
     */
    IMAGE = 8,
    /**
     * @generated from protobuf enum value: FIELD_TYPE_IMAGE_GALLERY = 9;
     */
    IMAGE_GALLERY = 9,
    /**
     * @generated from protobuf enum value: FIELD_TYPE_DATE = 10;
     */
    DATE = 10
}
// @generated message type with reflection information, may provide speed optimized methods
class Liquid$Type extends MessageType<Liquid> {
    constructor() {
        super("enose.consumable.Liquid", [
            { no: 1, name: "id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "type", kind: "enum", T: () => ["enose.consumable.LiquidType", LiquidType, "LIQUID_TYPE_"] },
            { no: 4, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "density", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 6, name: "metadata_json", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "is_active", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "created_at", kind: "message", T: () => Timestamp },
            { no: 9, name: "updated_at", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<Liquid>): Liquid {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0;
        message.name = "";
        message.type = 0;
        message.description = "";
        message.density = 0;
        message.metadataJson = "";
        message.isActive = false;
        if (value !== undefined)
            reflectionMergePartial<Liquid>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Liquid): Liquid {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 id */ 1:
                    message.id = reader.int32();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* enose.consumable.LiquidType type */ 3:
                    message.type = reader.int32();
                    break;
                case /* string description */ 4:
                    message.description = reader.string();
                    break;
                case /* float density */ 5:
                    message.density = reader.float();
                    break;
                case /* string metadata_json */ 6:
                    message.metadataJson = reader.string();
                    break;
                case /* bool is_active */ 7:
                    message.isActive = reader.bool();
                    break;
                case /* google.protobuf.Timestamp created_at */ 8:
                    message.createdAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.createdAt);
                    break;
                case /* google.protobuf.Timestamp updated_at */ 9:
                    message.updatedAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.updatedAt);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Liquid, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).int32(message.id);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* enose.consumable.LiquidType type = 3; */
        if (message.type !== 0)
            writer.tag(3, WireType.Varint).int32(message.type);
        /* string description = 4; */
        if (message.description !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.description);
        /* float density = 5; */
        if (message.density !== 0)
            writer.tag(5, WireType.Bit32).float(message.density);
        /* string metadata_json = 6; */
        if (message.metadataJson !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.metadataJson);
        /* bool is_active = 7; */
        if (message.isActive !== false)
            writer.tag(7, WireType.Varint).bool(message.isActive);
        /* google.protobuf.Timestamp created_at = 8; */
        if (message.createdAt)
            Timestamp.internalBinaryWrite(message.createdAt, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp updated_at = 9; */
        if (message.updatedAt)
            Timestamp.internalBinaryWrite(message.updatedAt, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.consumable.Liquid
 */
export const Liquid = new Liquid$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListLiquidsRequest$Type extends MessageType<ListLiquidsRequest> {
    constructor() {
        super("enose.consumable.ListLiquidsRequest", [
            { no: 1, name: "type_filter", kind: "enum", T: () => ["enose.consumable.LiquidType", LiquidType, "LIQUID_TYPE_"] },
            { no: 2, name: "include_inactive", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "limit", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "offset", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ListLiquidsRequest>): ListLiquidsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.typeFilter = 0;
        message.includeInactive = false;
        message.limit = 0;
        message.offset = 0;
        if (value !== undefined)
            reflectionMergePartial<ListLiquidsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListLiquidsRequest): ListLiquidsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* enose.consumable.LiquidType type_filter */ 1:
                    message.typeFilter = reader.int32();
                    break;
                case /* bool include_inactive */ 2:
                    message.includeInactive = reader.bool();
                    break;
                case /* int32 limit */ 3:
                    message.limit = reader.int32();
                    break;
                case /* int32 offset */ 4:
                    message.offset = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListLiquidsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* enose.consumable.LiquidType type_filter = 1; */
        if (message.typeFilter !== 0)
            writer.tag(1, WireType.Varint).int32(message.typeFilter);
        /* bool include_inactive = 2; */
        if (message.includeInactive !== false)
            writer.tag(2, WireType.Varint).bool(message.includeInactive);
        /* int32 limit = 3; */
        if (message.limit !== 0)
            writer.tag(3, WireType.Varint).int32(message.limit);
        /* int32 offset = 4; */
        if (message.offset !== 0)
            writer.tag(4, WireType.Varint).int32(message.offset);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.consumable.ListLiquidsRequest
 */
export const ListLiquidsRequest = new ListLiquidsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LiquidListResponse$Type extends MessageType<LiquidListResponse> {
    constructor() {
        super("enose.consumable.LiquidListResponse", [
            { no: 1, name: "liquids", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Liquid },
            { no: 2, name: "total_count", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<LiquidListResponse>): LiquidListResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.liquids = [];
        message.totalCount = 0;
        if (value !== undefined)
            reflectionMergePartial<LiquidListResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LiquidListResponse): LiquidListResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated enose.consumable.Liquid liquids */ 1:
                    message.liquids.push(Liquid.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* int32 total_count */ 2:
                    message.totalCount = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LiquidListResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated enose.consumable.Liquid liquids = 1; */
        for (let i = 0; i < message.liquids.length; i++)
            Liquid.internalBinaryWrite(message.liquids[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* int32 total_count = 2; */
        if (message.totalCount !== 0)
            writer.tag(2, WireType.Varint).int32(message.totalCount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.consumable.LiquidListResponse
 */
export const LiquidListResponse = new LiquidListResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetLiquidRequest$Type extends MessageType<GetLiquidRequest> {
    constructor() {
        super("enose.consumable.GetLiquidRequest", [
            { no: 1, name: "id", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetLiquidRequest>): GetLiquidRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0;
        if (value !== undefined)
            reflectionMergePartial<GetLiquidRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetLiquidRequest): GetLiquidRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 id */ 1:
                    message.id = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetLiquidRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).int32(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.consumable.GetLiquidRequest
 */
export const GetLiquidRequest = new GetLiquidRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateLiquidRequest$Type extends MessageType<CreateLiquidRequest> {
    constructor() {
        super("enose.consumable.CreateLiquidRequest", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "type", kind: "enum", T: () => ["enose.consumable.LiquidType", LiquidType, "LIQUID_TYPE_"] },
            { no: 3, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "density", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "metadata_json", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CreateLiquidRequest>): CreateLiquidRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.type = 0;
        message.description = "";
        message.density = 0;
        message.metadataJson = "";
        if (value !== undefined)
            reflectionMergePartial<CreateLiquidRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateLiquidRequest): CreateLiquidRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* enose.consumable.LiquidType type */ 2:
                    message.type = reader.int32();
                    break;
                case /* string description */ 3:
                    message.description = reader.string();
                    break;
                case /* float density */ 4:
                    message.density = reader.float();
                    break;
                case /* string metadata_json */ 5:
                    message.metadataJson = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateLiquidRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* enose.consumable.LiquidType type = 2; */
        if (message.type !== 0)
            writer.tag(2, WireType.Varint).int32(message.type);
        /* string description = 3; */
        if (message.description !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.description);
        /* float density = 4; */
        if (message.density !== 0)
            writer.tag(4, WireType.Bit32).float(message.density);
        /* string metadata_json = 5; */
        if (message.metadataJson !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.metadataJson);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.consumable.CreateLiquidRequest
 */
export const CreateLiquidRequest = new CreateLiquidRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateLiquidRequest$Type extends MessageType<UpdateLiquidRequest> {
    constructor() {
        super("enose.consumable.UpdateLiquidRequest", [
            { no: 1, name: "id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "type", kind: "enum", T: () => ["enose.consumable.LiquidType", LiquidType, "LIQUID_TYPE_"] },
            { no: 4, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "density", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 6, name: "metadata_json", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "is_active", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<UpdateLiquidRequest>): UpdateLiquidRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0;
        message.name = "";
        message.type = 0;
        message.description = "";
        message.density = 0;
        message.metadataJson = "";
        message.isActive = false;
        if (value !== undefined)
            reflectionMergePartial<UpdateLiquidRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateLiquidRequest): UpdateLiquidRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 id */ 1:
                    message.id = reader.int32();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* enose.consumable.LiquidType type */ 3:
                    message.type = reader.int32();
                    break;
                case /* string description */ 4:
                    message.description = reader.string();
                    break;
                case /* float density */ 5:
                    message.density = reader.float();
                    break;
                case /* string metadata_json */ 6:
                    message.metadataJson = reader.string();
                    break;
                case /* bool is_active */ 7:
                    message.isActive = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateLiquidRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).int32(message.id);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* enose.consumable.LiquidType type = 3; */
        if (message.type !== 0)
            writer.tag(3, WireType.Varint).int32(message.type);
        /* string description = 4; */
        if (message.description !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.description);
        /* float density = 5; */
        if (message.density !== 0)
            writer.tag(5, WireType.Bit32).float(message.density);
        /* string metadata_json = 6; */
        if (message.metadataJson !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.metadataJson);
        /* bool is_active = 7; */
        if (message.isActive !== false)
            writer.tag(7, WireType.Varint).bool(message.isActive);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.consumable.UpdateLiquidRequest
 */
export const UpdateLiquidRequest = new UpdateLiquidRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteLiquidRequest$Type extends MessageType<DeleteLiquidRequest> {
    constructor() {
        super("enose.consumable.DeleteLiquidRequest", [
            { no: 1, name: "id", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteLiquidRequest>): DeleteLiquidRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0;
        if (value !== undefined)
            reflectionMergePartial<DeleteLiquidRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteLiquidRequest): DeleteLiquidRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 id */ 1:
                    message.id = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteLiquidRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).int32(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.consumable.DeleteLiquidRequest
 */
export const DeleteLiquidRequest = new DeleteLiquidRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PumpAssignment$Type extends MessageType<PumpAssignment> {
    constructor() {
        super("enose.consumable.PumpAssignment", [
            { no: 1, name: "pump_index", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "liquid_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "liquid", kind: "message", T: () => Liquid },
            { no: 4, name: "notes", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "updated_at", kind: "message", T: () => Timestamp },
            { no: 6, name: "initial_volume_ml", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 7, name: "consumed_volume_ml", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 8, name: "remaining_volume_ml", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 9, name: "low_volume_threshold_ml", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 10, name: "is_low_volume", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<PumpAssignment>): PumpAssignment {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.pumpIndex = 0;
        message.notes = "";
        message.initialVolumeMl = 0;
        message.consumedVolumeMl = 0;
        message.remainingVolumeMl = 0;
        message.lowVolumeThresholdMl = 0;
        message.isLowVolume = false;
        if (value !== undefined)
            reflectionMergePartial<PumpAssignment>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PumpAssignment): PumpAssignment {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 pump_index */ 1:
                    message.pumpIndex = reader.int32();
                    break;
                case /* optional int32 liquid_id */ 2:
                    message.liquidId = reader.int32();
                    break;
                case /* optional enose.consumable.Liquid liquid */ 3:
                    message.liquid = Liquid.internalBinaryRead(reader, reader.uint32(), options, message.liquid);
                    break;
                case /* string notes */ 4:
                    message.notes = reader.string();
                    break;
                case /* google.protobuf.Timestamp updated_at */ 5:
                    message.updatedAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.updatedAt);
                    break;
                case /* double initial_volume_ml */ 6:
                    message.initialVolumeMl = reader.double();
                    break;
                case /* double consumed_volume_ml */ 7:
                    message.consumedVolumeMl = reader.double();
                    break;
                case /* double remaining_volume_ml */ 8:
                    message.remainingVolumeMl = reader.double();
                    break;
                case /* double low_volume_threshold_ml */ 9:
                    message.lowVolumeThresholdMl = reader.double();
                    break;
                case /* bool is_low_volume */ 10:
                    message.isLowVolume = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PumpAssignment, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 pump_index = 1; */
        if (message.pumpIndex !== 0)
            writer.tag(1, WireType.Varint).int32(message.pumpIndex);
        /* optional int32 liquid_id = 2; */
        if (message.liquidId !== undefined)
            writer.tag(2, WireType.Varint).int32(message.liquidId);
        /* optional enose.consumable.Liquid liquid = 3; */
        if (message.liquid)
            Liquid.internalBinaryWrite(message.liquid, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* string notes = 4; */
        if (message.notes !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.notes);
        /* google.protobuf.Timestamp updated_at = 5; */
        if (message.updatedAt)
            Timestamp.internalBinaryWrite(message.updatedAt, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* double initial_volume_ml = 6; */
        if (message.initialVolumeMl !== 0)
            writer.tag(6, WireType.Bit64).double(message.initialVolumeMl);
        /* double consumed_volume_ml = 7; */
        if (message.consumedVolumeMl !== 0)
            writer.tag(7, WireType.Bit64).double(message.consumedVolumeMl);
        /* double remaining_volume_ml = 8; */
        if (message.remainingVolumeMl !== 0)
            writer.tag(8, WireType.Bit64).double(message.remainingVolumeMl);
        /* double low_volume_threshold_ml = 9; */
        if (message.lowVolumeThresholdMl !== 0)
            writer.tag(9, WireType.Bit64).double(message.lowVolumeThresholdMl);
        /* bool is_low_volume = 10; */
        if (message.isLowVolume !== false)
            writer.tag(10, WireType.Varint).bool(message.isLowVolume);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.consumable.PumpAssignment
 */
export const PumpAssignment = new PumpAssignment$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PumpAssignmentsResponse$Type extends MessageType<PumpAssignmentsResponse> {
    constructor() {
        super("enose.consumable.PumpAssignmentsResponse", [
            { no: 1, name: "assignments", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => PumpAssignment }
        ]);
    }
    create(value?: PartialMessage<PumpAssignmentsResponse>): PumpAssignmentsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.assignments = [];
        if (value !== undefined)
            reflectionMergePartial<PumpAssignmentsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PumpAssignmentsResponse): PumpAssignmentsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated enose.consumable.PumpAssignment assignments */ 1:
                    message.assignments.push(PumpAssignment.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PumpAssignmentsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated enose.consumable.PumpAssignment assignments = 1; */
        for (let i = 0; i < message.assignments.length; i++)
            PumpAssignment.internalBinaryWrite(message.assignments[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.consumable.PumpAssignmentsResponse
 */
export const PumpAssignmentsResponse = new PumpAssignmentsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetPumpAssignmentRequest$Type extends MessageType<SetPumpAssignmentRequest> {
    constructor() {
        super("enose.consumable.SetPumpAssignmentRequest", [
            { no: 1, name: "pump_index", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "liquid_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "notes", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "initial_volume_ml", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 5, name: "low_volume_threshold_ml", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<SetPumpAssignmentRequest>): SetPumpAssignmentRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.pumpIndex = 0;
        message.notes = "";
        if (value !== undefined)
            reflectionMergePartial<SetPumpAssignmentRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetPumpAssignmentRequest): SetPumpAssignmentRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 pump_index */ 1:
                    message.pumpIndex = reader.int32();
                    break;
                case /* optional int32 liquid_id */ 2:
                    message.liquidId = reader.int32();
                    break;
                case /* string notes */ 3:
                    message.notes = reader.string();
                    break;
                case /* optional double initial_volume_ml */ 4:
                    message.initialVolumeMl = reader.double();
                    break;
                case /* optional double low_volume_threshold_ml */ 5:
                    message.lowVolumeThresholdMl = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetPumpAssignmentRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 pump_index = 1; */
        if (message.pumpIndex !== 0)
            writer.tag(1, WireType.Varint).int32(message.pumpIndex);
        /* optional int32 liquid_id = 2; */
        if (message.liquidId !== undefined)
            writer.tag(2, WireType.Varint).int32(message.liquidId);
        /* string notes = 3; */
        if (message.notes !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.notes);
        /* optional double initial_volume_ml = 4; */
        if (message.initialVolumeMl !== undefined)
            writer.tag(4, WireType.Bit64).double(message.initialVolumeMl);
        /* optional double low_volume_threshold_ml = 5; */
        if (message.lowVolumeThresholdMl !== undefined)
            writer.tag(5, WireType.Bit64).double(message.lowVolumeThresholdMl);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.consumable.SetPumpAssignmentRequest
 */
export const SetPumpAssignmentRequest = new SetPumpAssignmentRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetPumpVolumeRequest$Type extends MessageType<SetPumpVolumeRequest> {
    constructor() {
        super("enose.consumable.SetPumpVolumeRequest", [
            { no: 1, name: "pump_index", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "initial_volume_ml", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "low_volume_threshold_ml", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 4, name: "reset_consumed", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<SetPumpVolumeRequest>): SetPumpVolumeRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.pumpIndex = 0;
        message.initialVolumeMl = 0;
        message.resetConsumed = false;
        if (value !== undefined)
            reflectionMergePartial<SetPumpVolumeRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetPumpVolumeRequest): SetPumpVolumeRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 pump_index */ 1:
                    message.pumpIndex = reader.int32();
                    break;
                case /* double initial_volume_ml */ 2:
                    message.initialVolumeMl = reader.double();
                    break;
                case /* optional double low_volume_threshold_ml */ 3:
                    message.lowVolumeThresholdMl = reader.double();
                    break;
                case /* bool reset_consumed */ 4:
                    message.resetConsumed = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetPumpVolumeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 pump_index = 1; */
        if (message.pumpIndex !== 0)
            writer.tag(1, WireType.Varint).int32(message.pumpIndex);
        /* double initial_volume_ml = 2; */
        if (message.initialVolumeMl !== 0)
            writer.tag(2, WireType.Bit64).double(message.initialVolumeMl);
        /* optional double low_volume_threshold_ml = 3; */
        if (message.lowVolumeThresholdMl !== undefined)
            writer.tag(3, WireType.Bit64).double(message.lowVolumeThresholdMl);
        /* bool reset_consumed = 4; */
        if (message.resetConsumed !== false)
            writer.tag(4, WireType.Varint).bool(message.resetConsumed);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.consumable.SetPumpVolumeRequest
 */
export const SetPumpVolumeRequest = new SetPumpVolumeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AddPumpConsumptionRequest$Type extends MessageType<AddPumpConsumptionRequest> {
    constructor() {
        super("enose.consumable.AddPumpConsumptionRequest", [
            { no: 1, name: "pump_index", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "volume_ml", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "experiment_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<AddPumpConsumptionRequest>): AddPumpConsumptionRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.pumpIndex = 0;
        message.volumeMl = 0;
        if (value !== undefined)
            reflectionMergePartial<AddPumpConsumptionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AddPumpConsumptionRequest): AddPumpConsumptionRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 pump_index */ 1:
                    message.pumpIndex = reader.int32();
                    break;
                case /* double volume_ml */ 2:
                    message.volumeMl = reader.double();
                    break;
                case /* optional int32 experiment_id */ 3:
                    message.experimentId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AddPumpConsumptionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 pump_index = 1; */
        if (message.pumpIndex !== 0)
            writer.tag(1, WireType.Varint).int32(message.pumpIndex);
        /* double volume_ml = 2; */
        if (message.volumeMl !== 0)
            writer.tag(2, WireType.Bit64).double(message.volumeMl);
        /* optional int32 experiment_id = 3; */
        if (message.experimentId !== undefined)
            writer.tag(3, WireType.Varint).int32(message.experimentId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.consumable.AddPumpConsumptionRequest
 */
export const AddPumpConsumptionRequest = new AddPumpConsumptionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Consumable$Type extends MessageType<Consumable> {
    constructor() {
        super("enose.consumable.Consumable", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "type", kind: "enum", T: () => ["enose.consumable.ConsumableType", ConsumableType, "CONSUMABLE_TYPE_"] },
            { no: 4, name: "accumulated_seconds", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 5, name: "lifetime_seconds", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 6, name: "warning_threshold", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 7, name: "critical_threshold", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 8, name: "status", kind: "enum", T: () => ["enose.consumable.ConsumableStatus", ConsumableStatus, "CONSUMABLE_STATUS_"] },
            { no: 9, name: "remaining_ratio", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 10, name: "remaining_seconds", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 11, name: "last_reset_at", kind: "message", T: () => Timestamp },
            { no: 12, name: "updated_at", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<Consumable>): Consumable {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.name = "";
        message.type = 0;
        message.accumulatedSeconds = "0";
        message.lifetimeSeconds = "0";
        message.warningThreshold = 0;
        message.criticalThreshold = 0;
        message.status = 0;
        message.remainingRatio = 0;
        message.remainingSeconds = "0";
        if (value !== undefined)
            reflectionMergePartial<Consumable>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Consumable): Consumable {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* enose.consumable.ConsumableType type */ 3:
                    message.type = reader.int32();
                    break;
                case /* int64 accumulated_seconds */ 4:
                    message.accumulatedSeconds = reader.int64().toString();
                    break;
                case /* int64 lifetime_seconds */ 5:
                    message.lifetimeSeconds = reader.int64().toString();
                    break;
                case /* float warning_threshold */ 6:
                    message.warningThreshold = reader.float();
                    break;
                case /* float critical_threshold */ 7:
                    message.criticalThreshold = reader.float();
                    break;
                case /* enose.consumable.ConsumableStatus status */ 8:
                    message.status = reader.int32();
                    break;
                case /* float remaining_ratio */ 9:
                    message.remainingRatio = reader.float();
                    break;
                case /* int64 remaining_seconds */ 10:
                    message.remainingSeconds = reader.int64().toString();
                    break;
                case /* google.protobuf.Timestamp last_reset_at */ 11:
                    message.lastResetAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.lastResetAt);
                    break;
                case /* google.protobuf.Timestamp updated_at */ 12:
                    message.updatedAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.updatedAt);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Consumable, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* enose.consumable.ConsumableType type = 3; */
        if (message.type !== 0)
            writer.tag(3, WireType.Varint).int32(message.type);
        /* int64 accumulated_seconds = 4; */
        if (message.accumulatedSeconds !== "0")
            writer.tag(4, WireType.Varint).int64(message.accumulatedSeconds);
        /* int64 lifetime_seconds = 5; */
        if (message.lifetimeSeconds !== "0")
            writer.tag(5, WireType.Varint).int64(message.lifetimeSeconds);
        /* float warning_threshold = 6; */
        if (message.warningThreshold !== 0)
            writer.tag(6, WireType.Bit32).float(message.warningThreshold);
        /* float critical_threshold = 7; */
        if (message.criticalThreshold !== 0)
            writer.tag(7, WireType.Bit32).float(message.criticalThreshold);
        /* enose.consumable.ConsumableStatus status = 8; */
        if (message.status !== 0)
            writer.tag(8, WireType.Varint).int32(message.status);
        /* float remaining_ratio = 9; */
        if (message.remainingRatio !== 0)
            writer.tag(9, WireType.Bit32).float(message.remainingRatio);
        /* int64 remaining_seconds = 10; */
        if (message.remainingSeconds !== "0")
            writer.tag(10, WireType.Varint).int64(message.remainingSeconds);
        /* google.protobuf.Timestamp last_reset_at = 11; */
        if (message.lastResetAt)
            Timestamp.internalBinaryWrite(message.lastResetAt, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp updated_at = 12; */
        if (message.updatedAt)
            Timestamp.internalBinaryWrite(message.updatedAt, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.consumable.Consumable
 */
export const Consumable = new Consumable$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConsumableStatusResponse$Type extends MessageType<ConsumableStatusResponse> {
    constructor() {
        super("enose.consumable.ConsumableStatusResponse", [
            { no: 1, name: "consumables", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Consumable },
            { no: 2, name: "warning_count", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "critical_count", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ConsumableStatusResponse>): ConsumableStatusResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.consumables = [];
        message.warningCount = 0;
        message.criticalCount = 0;
        if (value !== undefined)
            reflectionMergePartial<ConsumableStatusResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConsumableStatusResponse): ConsumableStatusResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated enose.consumable.Consumable consumables */ 1:
                    message.consumables.push(Consumable.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* int32 warning_count */ 2:
                    message.warningCount = reader.int32();
                    break;
                case /* int32 critical_count */ 3:
                    message.criticalCount = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ConsumableStatusResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated enose.consumable.Consumable consumables = 1; */
        for (let i = 0; i < message.consumables.length; i++)
            Consumable.internalBinaryWrite(message.consumables[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* int32 warning_count = 2; */
        if (message.warningCount !== 0)
            writer.tag(2, WireType.Varint).int32(message.warningCount);
        /* int32 critical_count = 3; */
        if (message.criticalCount !== 0)
            writer.tag(3, WireType.Varint).int32(message.criticalCount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.consumable.ConsumableStatusResponse
 */
export const ConsumableStatusResponse = new ConsumableStatusResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResetConsumableRequest$Type extends MessageType<ResetConsumableRequest> {
    constructor() {
        super("enose.consumable.ResetConsumableRequest", [
            { no: 1, name: "consumable_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "notes", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ResetConsumableRequest>): ResetConsumableRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.consumableId = "";
        message.notes = "";
        if (value !== undefined)
            reflectionMergePartial<ResetConsumableRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResetConsumableRequest): ResetConsumableRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string consumable_id */ 1:
                    message.consumableId = reader.string();
                    break;
                case /* string notes */ 2:
                    message.notes = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResetConsumableRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string consumable_id = 1; */
        if (message.consumableId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.consumableId);
        /* string notes = 2; */
        if (message.notes !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.notes);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.consumable.ResetConsumableRequest
 */
export const ResetConsumableRequest = new ResetConsumableRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateLifetimeRequest$Type extends MessageType<UpdateLifetimeRequest> {
    constructor() {
        super("enose.consumable.UpdateLifetimeRequest", [
            { no: 1, name: "consumable_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "lifetime_seconds", kind: "scalar", T: 3 /*ScalarType.INT64*/ }
        ]);
    }
    create(value?: PartialMessage<UpdateLifetimeRequest>): UpdateLifetimeRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.consumableId = "";
        message.lifetimeSeconds = "0";
        if (value !== undefined)
            reflectionMergePartial<UpdateLifetimeRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateLifetimeRequest): UpdateLifetimeRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string consumable_id */ 1:
                    message.consumableId = reader.string();
                    break;
                case /* int64 lifetime_seconds */ 2:
                    message.lifetimeSeconds = reader.int64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateLifetimeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string consumable_id = 1; */
        if (message.consumableId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.consumableId);
        /* int64 lifetime_seconds = 2; */
        if (message.lifetimeSeconds !== "0")
            writer.tag(2, WireType.Varint).int64(message.lifetimeSeconds);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.consumable.UpdateLifetimeRequest
 */
export const UpdateLifetimeRequest = new UpdateLifetimeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MetadataField$Type extends MessageType<MetadataField> {
    constructor() {
        super("enose.consumable.MetadataField", [
            { no: 1, name: "id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "entity_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "field_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "field_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "field_type", kind: "enum", T: () => ["enose.consumable.FieldType", FieldType, "FIELD_TYPE_"] },
            { no: 6, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "is_required", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "default_value", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "options_json", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "display_order", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 11, name: "is_active", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<MetadataField>): MetadataField {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0;
        message.entityType = "";
        message.fieldKey = "";
        message.fieldName = "";
        message.fieldType = 0;
        message.description = "";
        message.isRequired = false;
        message.defaultValue = "";
        message.optionsJson = "";
        message.displayOrder = 0;
        message.isActive = false;
        if (value !== undefined)
            reflectionMergePartial<MetadataField>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MetadataField): MetadataField {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 id */ 1:
                    message.id = reader.int32();
                    break;
                case /* string entity_type */ 2:
                    message.entityType = reader.string();
                    break;
                case /* string field_key */ 3:
                    message.fieldKey = reader.string();
                    break;
                case /* string field_name */ 4:
                    message.fieldName = reader.string();
                    break;
                case /* enose.consumable.FieldType field_type */ 5:
                    message.fieldType = reader.int32();
                    break;
                case /* string description */ 6:
                    message.description = reader.string();
                    break;
                case /* bool is_required */ 7:
                    message.isRequired = reader.bool();
                    break;
                case /* string default_value */ 8:
                    message.defaultValue = reader.string();
                    break;
                case /* string options_json */ 9:
                    message.optionsJson = reader.string();
                    break;
                case /* int32 display_order */ 10:
                    message.displayOrder = reader.int32();
                    break;
                case /* bool is_active */ 11:
                    message.isActive = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MetadataField, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).int32(message.id);
        /* string entity_type = 2; */
        if (message.entityType !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.entityType);
        /* string field_key = 3; */
        if (message.fieldKey !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.fieldKey);
        /* string field_name = 4; */
        if (message.fieldName !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.fieldName);
        /* enose.consumable.FieldType field_type = 5; */
        if (message.fieldType !== 0)
            writer.tag(5, WireType.Varint).int32(message.fieldType);
        /* string description = 6; */
        if (message.description !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.description);
        /* bool is_required = 7; */
        if (message.isRequired !== false)
            writer.tag(7, WireType.Varint).bool(message.isRequired);
        /* string default_value = 8; */
        if (message.defaultValue !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.defaultValue);
        /* string options_json = 9; */
        if (message.optionsJson !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.optionsJson);
        /* int32 display_order = 10; */
        if (message.displayOrder !== 0)
            writer.tag(10, WireType.Varint).int32(message.displayOrder);
        /* bool is_active = 11; */
        if (message.isActive !== false)
            writer.tag(11, WireType.Varint).bool(message.isActive);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.consumable.MetadataField
 */
export const MetadataField = new MetadataField$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListMetadataFieldsRequest$Type extends MessageType<ListMetadataFieldsRequest> {
    constructor() {
        super("enose.consumable.ListMetadataFieldsRequest", [
            { no: 1, name: "entity_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "include_inactive", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ListMetadataFieldsRequest>): ListMetadataFieldsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.entityType = "";
        message.includeInactive = false;
        if (value !== undefined)
            reflectionMergePartial<ListMetadataFieldsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListMetadataFieldsRequest): ListMetadataFieldsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string entity_type */ 1:
                    message.entityType = reader.string();
                    break;
                case /* bool include_inactive */ 2:
                    message.includeInactive = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListMetadataFieldsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string entity_type = 1; */
        if (message.entityType !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.entityType);
        /* bool include_inactive = 2; */
        if (message.includeInactive !== false)
            writer.tag(2, WireType.Varint).bool(message.includeInactive);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.consumable.ListMetadataFieldsRequest
 */
export const ListMetadataFieldsRequest = new ListMetadataFieldsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MetadataFieldListResponse$Type extends MessageType<MetadataFieldListResponse> {
    constructor() {
        super("enose.consumable.MetadataFieldListResponse", [
            { no: 1, name: "fields", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => MetadataField }
        ]);
    }
    create(value?: PartialMessage<MetadataFieldListResponse>): MetadataFieldListResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.fields = [];
        if (value !== undefined)
            reflectionMergePartial<MetadataFieldListResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MetadataFieldListResponse): MetadataFieldListResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated enose.consumable.MetadataField fields */ 1:
                    message.fields.push(MetadataField.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MetadataFieldListResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated enose.consumable.MetadataField fields = 1; */
        for (let i = 0; i < message.fields.length; i++)
            MetadataField.internalBinaryWrite(message.fields[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.consumable.MetadataFieldListResponse
 */
export const MetadataFieldListResponse = new MetadataFieldListResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateMetadataFieldRequest$Type extends MessageType<CreateMetadataFieldRequest> {
    constructor() {
        super("enose.consumable.CreateMetadataFieldRequest", [
            { no: 1, name: "entity_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "field_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "field_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "field_type", kind: "enum", T: () => ["enose.consumable.FieldType", FieldType, "FIELD_TYPE_"] },
            { no: 5, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "is_required", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "default_value", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "options_json", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "display_order", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CreateMetadataFieldRequest>): CreateMetadataFieldRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.entityType = "";
        message.fieldKey = "";
        message.fieldName = "";
        message.fieldType = 0;
        message.description = "";
        message.isRequired = false;
        message.defaultValue = "";
        message.optionsJson = "";
        message.displayOrder = 0;
        if (value !== undefined)
            reflectionMergePartial<CreateMetadataFieldRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateMetadataFieldRequest): CreateMetadataFieldRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string entity_type */ 1:
                    message.entityType = reader.string();
                    break;
                case /* string field_key */ 2:
                    message.fieldKey = reader.string();
                    break;
                case /* string field_name */ 3:
                    message.fieldName = reader.string();
                    break;
                case /* enose.consumable.FieldType field_type */ 4:
                    message.fieldType = reader.int32();
                    break;
                case /* string description */ 5:
                    message.description = reader.string();
                    break;
                case /* bool is_required */ 6:
                    message.isRequired = reader.bool();
                    break;
                case /* string default_value */ 7:
                    message.defaultValue = reader.string();
                    break;
                case /* string options_json */ 8:
                    message.optionsJson = reader.string();
                    break;
                case /* int32 display_order */ 9:
                    message.displayOrder = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateMetadataFieldRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string entity_type = 1; */
        if (message.entityType !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.entityType);
        /* string field_key = 2; */
        if (message.fieldKey !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.fieldKey);
        /* string field_name = 3; */
        if (message.fieldName !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.fieldName);
        /* enose.consumable.FieldType field_type = 4; */
        if (message.fieldType !== 0)
            writer.tag(4, WireType.Varint).int32(message.fieldType);
        /* string description = 5; */
        if (message.description !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.description);
        /* bool is_required = 6; */
        if (message.isRequired !== false)
            writer.tag(6, WireType.Varint).bool(message.isRequired);
        /* string default_value = 7; */
        if (message.defaultValue !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.defaultValue);
        /* string options_json = 8; */
        if (message.optionsJson !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.optionsJson);
        /* int32 display_order = 9; */
        if (message.displayOrder !== 0)
            writer.tag(9, WireType.Varint).int32(message.displayOrder);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.consumable.CreateMetadataFieldRequest
 */
export const CreateMetadataFieldRequest = new CreateMetadataFieldRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateMetadataFieldRequest$Type extends MessageType<UpdateMetadataFieldRequest> {
    constructor() {
        super("enose.consumable.UpdateMetadataFieldRequest", [
            { no: 1, name: "id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "field_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "is_required", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "default_value", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "options_json", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "display_order", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "is_active", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<UpdateMetadataFieldRequest>): UpdateMetadataFieldRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0;
        message.fieldName = "";
        message.description = "";
        message.isRequired = false;
        message.defaultValue = "";
        message.optionsJson = "";
        message.displayOrder = 0;
        message.isActive = false;
        if (value !== undefined)
            reflectionMergePartial<UpdateMetadataFieldRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateMetadataFieldRequest): UpdateMetadataFieldRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 id */ 1:
                    message.id = reader.int32();
                    break;
                case /* string field_name */ 2:
                    message.fieldName = reader.string();
                    break;
                case /* string description */ 3:
                    message.description = reader.string();
                    break;
                case /* bool is_required */ 4:
                    message.isRequired = reader.bool();
                    break;
                case /* string default_value */ 5:
                    message.defaultValue = reader.string();
                    break;
                case /* string options_json */ 6:
                    message.optionsJson = reader.string();
                    break;
                case /* int32 display_order */ 7:
                    message.displayOrder = reader.int32();
                    break;
                case /* bool is_active */ 8:
                    message.isActive = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateMetadataFieldRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).int32(message.id);
        /* string field_name = 2; */
        if (message.fieldName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.fieldName);
        /* string description = 3; */
        if (message.description !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.description);
        /* bool is_required = 4; */
        if (message.isRequired !== false)
            writer.tag(4, WireType.Varint).bool(message.isRequired);
        /* string default_value = 5; */
        if (message.defaultValue !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.defaultValue);
        /* string options_json = 6; */
        if (message.optionsJson !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.optionsJson);
        /* int32 display_order = 7; */
        if (message.displayOrder !== 0)
            writer.tag(7, WireType.Varint).int32(message.displayOrder);
        /* bool is_active = 8; */
        if (message.isActive !== false)
            writer.tag(8, WireType.Varint).bool(message.isActive);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.consumable.UpdateMetadataFieldRequest
 */
export const UpdateMetadataFieldRequest = new UpdateMetadataFieldRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteMetadataFieldRequest$Type extends MessageType<DeleteMetadataFieldRequest> {
    constructor() {
        super("enose.consumable.DeleteMetadataFieldRequest", [
            { no: 1, name: "id", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteMetadataFieldRequest>): DeleteMetadataFieldRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0;
        if (value !== undefined)
            reflectionMergePartial<DeleteMetadataFieldRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteMetadataFieldRequest): DeleteMetadataFieldRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 id */ 1:
                    message.id = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteMetadataFieldRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).int32(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.consumable.DeleteMetadataFieldRequest
 */
export const DeleteMetadataFieldRequest = new DeleteMetadataFieldRequest$Type();
/**
 * @generated ServiceType for protobuf service enose.consumable.ConsumableService
 */
export const ConsumableService = new ServiceType("enose.consumable.ConsumableService", [
    { name: "ListLiquids", options: {}, I: ListLiquidsRequest, O: LiquidListResponse },
    { name: "GetLiquid", options: {}, I: GetLiquidRequest, O: Liquid },
    { name: "CreateLiquid", options: {}, I: CreateLiquidRequest, O: Liquid },
    { name: "UpdateLiquid", options: {}, I: UpdateLiquidRequest, O: Liquid },
    { name: "DeleteLiquid", options: {}, I: DeleteLiquidRequest, O: Empty },
    { name: "GetPumpAssignments", options: {}, I: Empty, O: PumpAssignmentsResponse },
    { name: "SetPumpAssignment", options: {}, I: SetPumpAssignmentRequest, O: PumpAssignment },
    { name: "SetPumpVolume", options: {}, I: SetPumpVolumeRequest, O: PumpAssignment },
    { name: "AddPumpConsumption", options: {}, I: AddPumpConsumptionRequest, O: PumpAssignment },
    { name: "GetConsumableStatus", options: {}, I: Empty, O: ConsumableStatusResponse },
    { name: "ResetConsumable", options: {}, I: ResetConsumableRequest, O: Consumable },
    { name: "UpdateConsumableLifetime", options: {}, I: UpdateLifetimeRequest, O: Consumable },
    { name: "ListMetadataFields", options: {}, I: ListMetadataFieldsRequest, O: MetadataFieldListResponse },
    { name: "CreateMetadataField", options: {}, I: CreateMetadataFieldRequest, O: MetadataField },
    { name: "UpdateMetadataField", options: {}, I: UpdateMetadataFieldRequest, O: MetadataField },
    { name: "DeleteMetadataField", options: {}, I: DeleteMetadataFieldRequest, O: Empty }
]);
