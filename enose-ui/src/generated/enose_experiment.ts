// @generated by protobuf-ts 2.11.1 with parameter long_type_string,generate_dependencies,client_grpc1,server_grpc1
// @generated from protobuf file "enose_experiment.proto" (package "enose.experiment", syntax proto3)
// tslint:disable
//
// 电子鼻实验程序定义
// 支持静态验证、资源预计算、安全检查
// 使用 buf validate 进行字段约束验证
//
import { Empty } from "./google/protobuf/empty";
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Timestamp } from "./google/protobuf/timestamp";
/**
 * ============================================================
 * 实验程序 (ExperimentProgram)
 * 完整的实验流程定义，可静态验证
 * ============================================================
 *
 * @generated from protobuf message enose.experiment.ExperimentProgram
 */
export interface ExperimentProgram {
    /**
     * 程序唯一标识
     *
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * 程序名称
     *
     * @generated from protobuf field: string name = 2
     */
    name: string;
    /**
     * 程序描述
     *
     * @generated from protobuf field: string description = 3
     */
    description: string;
    /**
     * 版本号 (语义化版本)
     *
     * @generated from protobuf field: string version = 4
     */
    version: string;
    /**
     * 硬件约束声明
     *
     * @generated from protobuf field: enose.experiment.HardwareConstraints hardware = 5
     */
    hardware?: HardwareConstraints;
    /**
     * 步骤列表 (至少1步)
     *
     * @generated from protobuf field: repeated enose.experiment.Step steps = 6
     */
    steps: Step[];
    /**
     * 元数据
     *
     * @generated from protobuf field: enose.experiment.Metadata metadata = 10
     */
    metadata?: Metadata;
}
/**
 * ============================================================
 * 硬件约束 (HardwareConstraints)
 * 声明实验所需的硬件资源和限制
 * ============================================================
 *
 * @generated from protobuf message enose.experiment.HardwareConstraints
 */
export interface HardwareConstraints {
    /**
     * 洗气瓶容量 (ml)
     *
     * @generated from protobuf field: double bottle_capacity_ml = 1
     */
    bottleCapacityMl: number;
    /**
     * 最大液位 (ml) - 防溢出安全余量
     *
     * @generated from protobuf field: double max_fill_ml = 2
     */
    maxFillMl: number;
    /**
     * 可用液体库存
     *
     * @generated from protobuf field: repeated enose.experiment.LiquidInventory liquids = 3
     */
    liquids: LiquidInventory[];
    /**
     * 气泵最大PWM (%)
     *
     * @generated from protobuf field: int32 max_gas_pump_pwm = 4
     */
    maxGasPumpPwm: number;
    /**
     * 加热器配置ID (可选)
     *
     * @generated from protobuf field: string heater_profile_id = 5
     */
    heaterProfileId: string;
}
/**
 * 液体库存
 *
 * @generated from protobuf message enose.experiment.LiquidInventory
 */
export interface LiquidInventory {
    /**
     * 液体ID
     *
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * 液体名称
     *
     * @generated from protobuf field: string name = 2
     */
    name: string;
    /**
     * 泵编号 (0=清洗泵, 2-5=样品泵)
     *
     * @generated from protobuf field: int32 pump_index = 3
     */
    pumpIndex: number;
    /**
     * 可用量 (ml)
     *
     * @generated from protobuf field: double available_ml = 4
     */
    availableMl: number;
    /**
     * 液体类型
     *
     * @generated from protobuf field: enose.experiment.LiquidType type = 5
     */
    type: LiquidType;
    /**
     * 密度 (g/ml) - 用于体积/重量换算
     *
     * @generated from protobuf field: double density_g_ml = 6
     */
    densityGMl: number;
}
/**
 * ============================================================
 * 步骤 (Step)
 * 实验的基本执行单元
 * ============================================================
 *
 * @generated from protobuf message enose.experiment.Step
 */
export interface Step {
    /**
     * 步骤名称 (用于日志和显示)
     *
     * @generated from protobuf field: string name = 1
     */
    name: string;
    /**
     * 步骤动作 (必须指定一个)
     *
     * @generated from protobuf oneof: action
     */
    action: {
        oneofKind: "inject";
        /**
         * @generated from protobuf field: enose.experiment.InjectAction inject = 10
         */
        inject: InjectAction;
    } | {
        oneofKind: "wait";
        /**
         * @generated from protobuf field: enose.experiment.WaitAction wait = 11
         */
        wait: WaitAction;
    } | {
        oneofKind: "drain";
        /**
         * @generated from protobuf field: enose.experiment.DrainAction drain = 12
         */
        drain: DrainAction;
    } | {
        oneofKind: "acquire";
        /**
         * @generated from protobuf field: enose.experiment.AcquireAction acquire = 13
         */
        acquire: AcquireAction;
    } | {
        oneofKind: "setState";
        /**
         * @generated from protobuf field: enose.experiment.SetStateAction set_state = 14
         */
        setState: SetStateAction;
    } | {
        oneofKind: "setGasPump";
        /**
         * @generated from protobuf field: enose.experiment.SetGasPumpAction set_gas_pump = 15
         */
        setGasPump: SetGasPumpAction;
    } | {
        oneofKind: "loop";
        /**
         * @generated from protobuf field: enose.experiment.LoopAction loop = 16
         */
        loop: LoopAction;
    } | {
        oneofKind: "phaseMarker";
        /**
         * @generated from protobuf field: enose.experiment.PhaseMarkerAction phase_marker = 17
         */
        phaseMarker: PhaseMarkerAction;
    } | {
        oneofKind: undefined;
    };
}
// ============================================================// 动作定义// ============================================================

/**
 * 进样动作 - 按配方注入液体
 *
 * @generated from protobuf message enose.experiment.InjectAction
 */
export interface InjectAction {
    /**
     * 液体成分列表
     *
     * @generated from protobuf field: repeated enose.experiment.LiquidComponent components = 1
     */
    components: LiquidComponent[];
    /**
     * 目标量 (二选一)
     *
     * @generated from protobuf oneof: target
     */
    target: {
        oneofKind: "targetVolumeMl";
        /**
         * @generated from protobuf field: double target_volume_ml = 2
         */
        targetVolumeMl: number; // 目标体积 (ml)    } | {
        oneofKind: "targetWeightG";
        /**
         * @generated from protobuf field: double target_weight_g = 3
         */
        targetWeightG: number; // 目标重量 (g)    } | {
        oneofKind: undefined;
    };
    /**
     * 容差
     *
     * @generated from protobuf field: double tolerance = 4
     */
    tolerance: number;
    /**
     * 流速 (ml/min)
     *
     * @generated from protobuf field: double flow_rate_ml_min = 5
     */
    flowRateMlMin: number;
    /**
     * 等待稳定超时 (秒)
     *
     * @generated from protobuf field: double stable_timeout_s = 6
     */
    stableTimeoutS: number;
}
/**
 * 液体成分
 *
 * @generated from protobuf message enose.experiment.LiquidComponent
 */
export interface LiquidComponent {
    /**
     * 液体ID (引用 HardwareConstraints.liquids)
     *
     * @generated from protobuf field: string liquid_id = 1
     */
    liquidId: string;
    /**
     * 体积比例 (0-1)
     *
     * @generated from protobuf field: double ratio = 2
     */
    ratio: number;
}
/**
 * 等待动作
 *
 * @generated from protobuf message enose.experiment.WaitAction
 */
export interface WaitAction {
    /**
     * 等待条件 (必须指定一个)
     *
     * @generated from protobuf oneof: condition
     */
    condition: {
        oneofKind: "durationS";
        /**
         * @generated from protobuf field: double duration_s = 1
         */
        durationS: number; // 固定时间 (秒)    } | {
        oneofKind: "heaterCycles";
        /**
         * @generated from protobuf field: int32 heater_cycles = 2
         */
        heaterCycles: number; // 加热器循环次数    } | {
        oneofKind: "stability";
        /**
         * @generated from protobuf field: enose.experiment.StabilityCondition stability = 3
         */
        stability: StabilityCondition; // 稳定性条件    } | {
        oneofKind: "weight";
        /**
         * @generated from protobuf field: enose.experiment.WeightCondition weight = 4
         */
        weight: WeightCondition; // 重量条件    } | {
        oneofKind: "empty";
        /**
         * @generated from protobuf field: enose.experiment.EmptyBottleCondition empty = 5
         */
        empty: EmptyBottleCondition; // 空瓶条件    } | {
        oneofKind: undefined;
    };
    /**
     * 最大等待时间 (秒) - 防止无限等待
     *
     * @generated from protobuf field: double timeout_s = 10
     */
    timeoutS: number;
}
/**
 * 稳定性条件
 *
 * @generated from protobuf message enose.experiment.StabilityCondition
 */
export interface StabilityCondition {
    /**
     * 稳定窗口 (秒)
     *
     * @generated from protobuf field: double window_s = 1
     */
    windowS: number;
    /**
     * 变化阈值 (%)
     *
     * @generated from protobuf field: double threshold_percent = 2
     */
    thresholdPercent: number;
}
/**
 * 重量条件
 *
 * @generated from protobuf message enose.experiment.WeightCondition
 */
export interface WeightCondition {
    /**
     * 目标重量 (g)
     *
     * @generated from protobuf field: double target_g = 1
     */
    targetG: number;
    /**
     * 容差 (g)
     *
     * @generated from protobuf field: double tolerance_g = 2
     */
    toleranceG: number;
}
/**
 * 空瓶条件
 *
 * @generated from protobuf message enose.experiment.EmptyBottleCondition
 */
export interface EmptyBottleCondition {
    /**
     * 空瓶容差 (g)
     *
     * @generated from protobuf field: double tolerance_g = 1
     */
    toleranceG: number;
    /**
     * 稳定窗口 (秒)
     *
     * @generated from protobuf field: double stability_window_s = 2
     */
    stabilityWindowS: number;
}
/**
 * 排废动作
 *
 * @generated from protobuf message enose.experiment.DrainAction
 */
export interface DrainAction {
    /**
     * 气泵PWM (%)
     *
     * @generated from protobuf field: int32 gas_pump_pwm = 1
     */
    gasPumpPwm: number;
    /**
     * 空瓶检测容差 (g)
     *
     * @generated from protobuf field: double empty_tolerance_g = 2
     */
    emptyToleranceG: number;
    /**
     * 稳定窗口 (秒)
     *
     * @generated from protobuf field: double stability_window_s = 3
     */
    stabilityWindowS: number;
    /**
     * 超时 (秒)
     *
     * @generated from protobuf field: double timeout_s = 4
     */
    timeoutS: number;
}
/**
 * 采集动作 - 传感器数据采集
 *
 * @generated from protobuf message enose.experiment.AcquireAction
 */
export interface AcquireAction {
    /**
     * 气泵PWM (%)
     *
     * @generated from protobuf field: int32 gas_pump_pwm = 1
     */
    gasPumpPwm: number;
    /**
     * 终止条件
     *
     * @generated from protobuf oneof: termination
     */
    termination: {
        oneofKind: "durationS";
        /**
         * @generated from protobuf field: double duration_s = 2
         */
        durationS: number; // 固定时间    } | {
        oneofKind: "heaterCycles";
        /**
         * @generated from protobuf field: int32 heater_cycles = 3
         */
        heaterCycles: number; // 加热器循环次数    } | {
        oneofKind: "stability";
        /**
         * @generated from protobuf field: enose.experiment.StabilityCondition stability = 4
         */
        stability: StabilityCondition; // 稳定性条件    } | {
        oneofKind: undefined;
    };
    /**
     * 最大时间 (秒)
     *
     * @generated from protobuf field: double max_duration_s = 10
     */
    maxDurationS: number;
}
/**
 * 设置系统状态
 *
 * @generated from protobuf message enose.experiment.SetStateAction
 */
export interface SetStateAction {
    /**
     * @generated from protobuf field: enose.experiment.SystemState state = 1
     */
    state: SystemState;
}
/**
 * 设置气泵PWM
 *
 * @generated from protobuf message enose.experiment.SetGasPumpAction
 */
export interface SetGasPumpAction {
    /**
     * @generated from protobuf field: int32 pwm_percent = 1
     */
    pwmPercent: number;
}
/**
 * 循环动作
 *
 * @generated from protobuf message enose.experiment.LoopAction
 */
export interface LoopAction {
    /**
     * 循环次数
     *
     * @generated from protobuf field: int32 count = 1
     */
    count: number;
    /**
     * 循环体步骤
     *
     * @generated from protobuf field: repeated enose.experiment.Step steps = 2
     */
    steps: Step[];
}
/**
 * 阶段标记 - 用于数据打标签
 *
 * @generated from protobuf message enose.experiment.PhaseMarkerAction
 */
export interface PhaseMarkerAction {
    /**
     * 阶段名称
     *
     * @generated from protobuf field: string phase_name = 1
     */
    phaseName: string;
    /**
     * 是否开始 (true=开始, false=结束)
     *
     * @generated from protobuf field: bool is_start = 2
     */
    isStart: boolean;
}
/**
 * ============================================================
 * 元数据 (Metadata)
 * ============================================================
 *
 * @generated from protobuf message enose.experiment.Metadata
 */
export interface Metadata {
    /**
     * @generated from protobuf field: string author = 1
     */
    author: string;
    /**
     * @generated from protobuf field: string created_at = 2
     */
    createdAt: string; // ISO 8601 格式    /**
     * @generated from protobuf field: string updated_at = 3
     */
    updatedAt: string;
    /**
     * @generated from protobuf field: repeated string tags = 4
     */
    tags: string[];
    /**
     * @generated from protobuf field: string notes = 5
     */
    notes: string;
}
/**
 * ============================================================
 * 验证结果 (ValidationResult)
 * ============================================================
 *
 * @generated from protobuf message enose.experiment.ValidationResult
 */
export interface ValidationResult {
    /**
     * 是否验证通过
     *
     * @generated from protobuf field: bool valid = 1
     */
    valid: boolean;
    /**
     * 错误列表
     *
     * @generated from protobuf field: repeated enose.experiment.ValidationError errors = 2
     */
    errors: ValidationError[];
    /**
     * 警告列表
     *
     * @generated from protobuf field: repeated enose.experiment.ValidationError warnings = 3
     */
    warnings: ValidationError[];
    /**
     * 资源预估
     *
     * @generated from protobuf field: enose.experiment.ResourceEstimate estimate = 4
     */
    estimate?: ResourceEstimate;
}
/**
 * 验证错误
 *
 * @generated from protobuf message enose.experiment.ValidationError
 */
export interface ValidationError {
    /**
     * 错误路径 (e.g., "steps[2].inject")
     *
     * @generated from protobuf field: string path = 1
     */
    path: string;
    /**
     * 错误代码
     *
     * @generated from protobuf field: string code = 2
     */
    code: string;
    /**
     * 错误消息
     *
     * @generated from protobuf field: string message = 3
     */
    message: string;
    /**
     * 严重级别
     *
     * @generated from protobuf field: enose.experiment.ValidationError.Severity severity = 4
     */
    severity: ValidationError_Severity;
}
/**
 * @generated from protobuf enum enose.experiment.ValidationError.Severity
 */
export enum ValidationError_Severity {
    /**
     * @generated from protobuf enum value: SEVERITY_UNSPECIFIED = 0;
     */
    SEVERITY_UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: ERROR = 1;
     */
    ERROR = 1,
    /**
     * @generated from protobuf enum value: WARNING = 2;
     */
    WARNING = 2,
    /**
     * @generated from protobuf enum value: INFO = 3;
     */
    INFO = 3
}
/**
 * 资源预估
 *
 * @generated from protobuf message enose.experiment.ResourceEstimate
 */
export interface ResourceEstimate {
    /**
     * 每个泵的预计消耗量 (ml)
     *
     * @generated from protobuf field: map<int32, double> pump_consumption_ml = 1
     */
    pumpConsumptionMl: {
        [key: number]: number;
    };
    /**
     * 预计峰值液位 (ml)
     *
     * @generated from protobuf field: double peak_liquid_level_ml = 2
     */
    peakLiquidLevelMl: number;
    /**
     * 预计总时长 (秒)
     *
     * @generated from protobuf field: double estimated_duration_s = 3
     */
    estimatedDurationS: number;
    /**
     * 预计加热器循环数
     *
     * @generated from protobuf field: int32 heater_cycles = 4
     */
    heaterCycles: number;
    /**
     * 液体消耗详情
     *
     * @generated from protobuf field: repeated enose.experiment.LiquidConsumption liquid_consumption = 5
     */
    liquidConsumption: LiquidConsumption[];
}
/**
 * 液体消耗详情
 *
 * @generated from protobuf message enose.experiment.LiquidConsumption
 */
export interface LiquidConsumption {
    /**
     * @generated from protobuf field: string liquid_id = 1
     */
    liquidId: string;
    /**
     * @generated from protobuf field: string liquid_name = 2
     */
    liquidName: string;
    /**
     * @generated from protobuf field: int32 pump_index = 3
     */
    pumpIndex: number;
    /**
     * @generated from protobuf field: double required_ml = 4
     */
    requiredMl: number; // 需要量    /**
     * @generated from protobuf field: double available_ml = 5
     */
    availableMl: number; // 可用量    /**
     * @generated from protobuf field: bool sufficient = 6
     */
    sufficient: boolean; // 是否充足}
/**
 * 验证请求
 *
 * @generated from protobuf message enose.experiment.ValidateProgramRequest
 */
export interface ValidateProgramRequest {
    /**
     * @generated from protobuf oneof: source
     */
    source: {
        oneofKind: "program";
        /**
         * @generated from protobuf field: enose.experiment.ExperimentProgram program = 1
         */
        program: ExperimentProgram; // 结构化程序    } | {
        oneofKind: "yamlContent";
        /**
         * @generated from protobuf field: string yaml_content = 2
         */
        yamlContent: string; // YAML 字符串    } | {
        oneofKind: undefined;
    };
}
/**
 * 加载请求
 *
 * @generated from protobuf message enose.experiment.LoadProgramRequest
 */
export interface LoadProgramRequest {
    /**
     * @generated from protobuf oneof: source
     */
    source: {
        oneofKind: "program";
        /**
         * @generated from protobuf field: enose.experiment.ExperimentProgram program = 1
         */
        program: ExperimentProgram; // 结构化程序    } | {
        oneofKind: "yamlContent";
        /**
         * @generated from protobuf field: string yaml_content = 2
         */
        yamlContent: string; // YAML 字符串    } | {
        oneofKind: undefined;
    };
}
/**
 * 加载响应
 *
 * @generated from protobuf message enose.experiment.LoadProgramResponse
 */
export interface LoadProgramResponse {
    /**
     * @generated from protobuf field: bool success = 1
     */
    success: boolean;
    /**
     * @generated from protobuf field: enose.experiment.ValidationResult validation = 2
     */
    validation?: ValidationResult;
    /**
     * @generated from protobuf field: string error_message = 3
     */
    errorMessage: string;
}
/**
 * 实验状态响应
 *
 * @generated from protobuf message enose.experiment.ExperimentStatusResponse
 */
export interface ExperimentStatusResponse {
    /**
     * 实验状态
     *
     * @generated from protobuf field: enose.experiment.ExperimentState state = 1
     */
    state: ExperimentState;
    /**
     * 当前程序ID
     *
     * @generated from protobuf field: string program_id = 2
     */
    programId: string;
    /**
     * 当前步骤索引
     *
     * @generated from protobuf field: int32 current_step_index = 3
     */
    currentStepIndex: number;
    /**
     * 当前步骤名称
     *
     * @generated from protobuf field: string current_step_name = 4
     */
    currentStepName: string;
    /**
     * 循环信息 (如果在循环中)
     *
     * @generated from protobuf field: int32 loop_iteration = 5
     */
    loopIteration: number;
    /**
     * @generated from protobuf field: int32 loop_total = 6
     */
    loopTotal: number;
    /**
     * 进度 (0-100)
     *
     * @generated from protobuf field: int32 progress_percent = 7
     */
    progressPercent: number;
    /**
     * 已运行时间 (秒)
     *
     * @generated from protobuf field: double elapsed_s = 8
     */
    elapsedS: number;
    /**
     * 预计剩余时间 (秒)
     *
     * @generated from protobuf field: double remaining_s = 9
     */
    remainingS: number;
    /**
     * 状态消息
     *
     * @generated from protobuf field: string message = 10
     */
    message: string;
    /**
     * 最近日志
     *
     * @generated from protobuf field: repeated string logs = 11
     */
    logs: string[];
    /**
     * 错误信息 (如果有)
     *
     * @generated from protobuf field: string error = 12
     */
    error: string;
}
/**
 * 实验事件
 *
 * @generated from protobuf message enose.experiment.ExperimentEvent
 */
export interface ExperimentEvent {
    /**
     * 时间戳
     *
     * @generated from protobuf field: google.protobuf.Timestamp timestamp = 1
     */
    timestamp?: Timestamp;
    /**
     * 事件类型
     *
     * @generated from protobuf field: enose.experiment.ExperimentEvent.EventType type = 2
     */
    type: ExperimentEvent_EventType;
    /**
     * 事件数据
     *
     * @generated from protobuf field: string step_name = 3
     */
    stepName: string;
    /**
     * @generated from protobuf field: string phase_name = 4
     */
    phaseName: string;
    /**
     * @generated from protobuf field: string message = 5
     */
    message: string;
    /**
     * 额外数据
     *
     * @generated from protobuf field: map<string, string> data = 10
     */
    data: {
        [key: string]: string;
    };
}
/**
 * @generated from protobuf enum enose.experiment.ExperimentEvent.EventType
 */
export enum ExperimentEvent_EventType {
    /**
     * @generated from protobuf enum value: EVENT_TYPE_UNSPECIFIED = 0;
     */
    EVENT_TYPE_UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: PROGRAM_LOADED = 1;
     */
    PROGRAM_LOADED = 1,
    /**
     * @generated from protobuf enum value: EXPERIMENT_STARTED = 2;
     */
    EXPERIMENT_STARTED = 2,
    /**
     * @generated from protobuf enum value: EXPERIMENT_STOPPED = 3;
     */
    EXPERIMENT_STOPPED = 3,
    /**
     * @generated from protobuf enum value: EXPERIMENT_PAUSED = 4;
     */
    EXPERIMENT_PAUSED = 4,
    /**
     * @generated from protobuf enum value: EXPERIMENT_RESUMED = 5;
     */
    EXPERIMENT_RESUMED = 5,
    /**
     * @generated from protobuf enum value: EXPERIMENT_COMPLETED = 6;
     */
    EXPERIMENT_COMPLETED = 6,
    /**
     * @generated from protobuf enum value: EXPERIMENT_ERROR = 7;
     */
    EXPERIMENT_ERROR = 7,
    /**
     * @generated from protobuf enum value: STEP_STARTED = 10;
     */
    STEP_STARTED = 10,
    /**
     * @generated from protobuf enum value: STEP_COMPLETED = 11;
     */
    STEP_COMPLETED = 11,
    /**
     * @generated from protobuf enum value: PHASE_STARTED = 12;
     */
    PHASE_STARTED = 12,
    /**
     * @generated from protobuf enum value: PHASE_ENDED = 13;
     */
    PHASE_ENDED = 13,
    /**
     * @generated from protobuf enum value: LOOP_ITERATION = 14;
     */
    LOOP_ITERATION = 14,
    /**
     * @generated from protobuf enum value: WEIGHT_READING = 20;
     */
    WEIGHT_READING = 20,
    /**
     * @generated from protobuf enum value: SENSOR_READING = 21;
     */
    SENSOR_READING = 21
}
/**
 * 液体类型
 *
 * @generated from protobuf enum enose.experiment.LiquidType
 */
export enum LiquidType {
    /**
     * @generated from protobuf enum value: LIQUID_TYPE_UNSPECIFIED = 0;
     */
    LIQUID_TYPE_UNSPECIFIED = 0,
    /**
     * 清洗液
     *
     * @generated from protobuf enum value: LIQUID_RINSE = 1;
     */
    LIQUID_RINSE = 1,
    /**
     * 样品液
     *
     * @generated from protobuf enum value: LIQUID_SAMPLE = 2;
     */
    LIQUID_SAMPLE = 2,
    /**
     * 标定液
     *
     * @generated from protobuf enum value: LIQUID_CALIBRATION = 3;
     */
    LIQUID_CALIBRATION = 3
}
/**
 * 系统状态枚举
 *
 * @generated from protobuf enum enose.experiment.SystemState
 */
export enum SystemState {
    /**
     * @generated from protobuf enum value: SYSTEM_STATE_UNSPECIFIED = 0;
     */
    SYSTEM_STATE_UNSPECIFIED = 0,
    /**
     * 初始状态
     *
     * @generated from protobuf enum value: STATE_INITIAL = 1;
     */
    STATE_INITIAL = 1,
    /**
     * 排废状态
     *
     * @generated from protobuf enum value: STATE_DRAIN = 2;
     */
    STATE_DRAIN = 2,
    /**
     * 清洗状态
     *
     * @generated from protobuf enum value: STATE_CLEAN = 3;
     */
    STATE_CLEAN = 3,
    /**
     * 采样状态
     *
     * @generated from protobuf enum value: STATE_SAMPLE = 4;
     */
    STATE_SAMPLE = 4,
    /**
     * 进样状态
     *
     * @generated from protobuf enum value: STATE_INJECT = 5;
     */
    STATE_INJECT = 5
}
/**
 * 实验状态枚举
 *
 * @generated from protobuf enum enose.experiment.ExperimentState
 */
export enum ExperimentState {
    /**
     * @generated from protobuf enum value: EXPERIMENT_STATE_UNSPECIFIED = 0;
     */
    EXPERIMENT_STATE_UNSPECIFIED = 0,
    /**
     * 空闲 (未加载程序)
     *
     * @generated from protobuf enum value: EXP_IDLE = 1;
     */
    EXP_IDLE = 1,
    /**
     * 已加载 (待启动)
     *
     * @generated from protobuf enum value: EXP_LOADED = 2;
     */
    EXP_LOADED = 2,
    /**
     * 运行中
     *
     * @generated from protobuf enum value: EXP_RUNNING = 3;
     */
    EXP_RUNNING = 3,
    /**
     * 已暂停
     *
     * @generated from protobuf enum value: EXP_PAUSED = 4;
     */
    EXP_PAUSED = 4,
    /**
     * 正在完成
     *
     * @generated from protobuf enum value: EXP_COMPLETING = 5;
     */
    EXP_COMPLETING = 5,
    /**
     * 已完成
     *
     * @generated from protobuf enum value: EXP_COMPLETED = 6;
     */
    EXP_COMPLETED = 6,
    /**
     * 错误
     *
     * @generated from protobuf enum value: EXP_ERROR = 7;
     */
    EXP_ERROR = 7,
    /**
     * 正在中止
     *
     * @generated from protobuf enum value: EXP_ABORTING = 8;
     */
    EXP_ABORTING = 8,
    /**
     * 已中止
     *
     * @generated from protobuf enum value: EXP_ABORTED = 9;
     */
    EXP_ABORTED = 9
}
// @generated message type with reflection information, may provide speed optimized methods
class ExperimentProgram$Type extends MessageType<ExperimentProgram> {
    constructor() {
        super("enose.experiment.ExperimentProgram", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "buf.validate.field": { string: { minLen: "1", maxLen: "64", pattern: "^[a-z][a-z0-9_]*$" } } } },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "buf.validate.field": { string: { minLen: "1", maxLen: "128" } } } },
            { no: 3, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "version", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "buf.validate.field": { string: { pattern: "^\\d+\\.\\d+\\.\\d+$" } } } },
            { no: 5, name: "hardware", kind: "message", T: () => HardwareConstraints, options: { "buf.validate.field": { required: true } } },
            { no: 6, name: "steps", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Step, options: { "buf.validate.field": { repeated: { minItems: "1" } } } },
            { no: 10, name: "metadata", kind: "message", T: () => Metadata }
        ]);
    }
    create(value?: PartialMessage<ExperimentProgram>): ExperimentProgram {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.name = "";
        message.description = "";
        message.version = "";
        message.steps = [];
        if (value !== undefined)
            reflectionMergePartial<ExperimentProgram>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExperimentProgram): ExperimentProgram {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* string description */ 3:
                    message.description = reader.string();
                    break;
                case /* string version */ 4:
                    message.version = reader.string();
                    break;
                case /* enose.experiment.HardwareConstraints hardware */ 5:
                    message.hardware = HardwareConstraints.internalBinaryRead(reader, reader.uint32(), options, message.hardware);
                    break;
                case /* repeated enose.experiment.Step steps */ 6:
                    message.steps.push(Step.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* enose.experiment.Metadata metadata */ 10:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExperimentProgram, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* string description = 3; */
        if (message.description !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.description);
        /* string version = 4; */
        if (message.version !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.version);
        /* enose.experiment.HardwareConstraints hardware = 5; */
        if (message.hardware)
            HardwareConstraints.internalBinaryWrite(message.hardware, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* repeated enose.experiment.Step steps = 6; */
        for (let i = 0; i < message.steps.length; i++)
            Step.internalBinaryWrite(message.steps[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* enose.experiment.Metadata metadata = 10; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.experiment.ExperimentProgram
 */
export const ExperimentProgram = new ExperimentProgram$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HardwareConstraints$Type extends MessageType<HardwareConstraints> {
    constructor() {
        super("enose.experiment.HardwareConstraints", [
            { no: 1, name: "bottle_capacity_ml", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/, options: { "buf.validate.field": { double: { lte: 500, gte: 50 } } } },
            { no: 2, name: "max_fill_ml", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/, options: { "buf.validate.field": { double: { lte: 500, gt: 0 } } } },
            { no: 3, name: "liquids", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => LiquidInventory, options: { "buf.validate.field": { repeated: { minItems: "1" } } } },
            { no: 4, name: "max_gas_pump_pwm", kind: "scalar", T: 5 /*ScalarType.INT32*/, options: { "buf.validate.field": { int32: { lte: 100, gte: 0 } } } },
            { no: 5, name: "heater_profile_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { "buf.validate.message": { cel: [{ id: "fill_under_capacity", message: "\u6700\u5927\u6DB2\u4F4D\u5FC5\u987B\u5C0F\u4E8E\u74F6\u5B50\u5BB9\u91CF", expression: "this.max_fill_ml < this.bottle_capacity_ml" }] } });
    }
    create(value?: PartialMessage<HardwareConstraints>): HardwareConstraints {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.bottleCapacityMl = 0;
        message.maxFillMl = 0;
        message.liquids = [];
        message.maxGasPumpPwm = 0;
        message.heaterProfileId = "";
        if (value !== undefined)
            reflectionMergePartial<HardwareConstraints>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HardwareConstraints): HardwareConstraints {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double bottle_capacity_ml */ 1:
                    message.bottleCapacityMl = reader.double();
                    break;
                case /* double max_fill_ml */ 2:
                    message.maxFillMl = reader.double();
                    break;
                case /* repeated enose.experiment.LiquidInventory liquids */ 3:
                    message.liquids.push(LiquidInventory.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* int32 max_gas_pump_pwm */ 4:
                    message.maxGasPumpPwm = reader.int32();
                    break;
                case /* string heater_profile_id */ 5:
                    message.heaterProfileId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HardwareConstraints, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double bottle_capacity_ml = 1; */
        if (message.bottleCapacityMl !== 0)
            writer.tag(1, WireType.Bit64).double(message.bottleCapacityMl);
        /* double max_fill_ml = 2; */
        if (message.maxFillMl !== 0)
            writer.tag(2, WireType.Bit64).double(message.maxFillMl);
        /* repeated enose.experiment.LiquidInventory liquids = 3; */
        for (let i = 0; i < message.liquids.length; i++)
            LiquidInventory.internalBinaryWrite(message.liquids[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* int32 max_gas_pump_pwm = 4; */
        if (message.maxGasPumpPwm !== 0)
            writer.tag(4, WireType.Varint).int32(message.maxGasPumpPwm);
        /* string heater_profile_id = 5; */
        if (message.heaterProfileId !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.heaterProfileId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.experiment.HardwareConstraints
 */
export const HardwareConstraints = new HardwareConstraints$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LiquidInventory$Type extends MessageType<LiquidInventory> {
    constructor() {
        super("enose.experiment.LiquidInventory", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "buf.validate.field": { string: { minLen: "1", maxLen: "64", pattern: "^[a-z][a-z0-9_]*$" } } } },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "pump_index", kind: "scalar", T: 5 /*ScalarType.INT32*/, options: { "buf.validate.field": { int32: { lte: 7, gte: 0 } } } },
            { no: 4, name: "available_ml", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/, options: { "buf.validate.field": { double: { gte: 0 } } } },
            { no: 5, name: "type", kind: "enum", T: () => ["enose.experiment.LiquidType", LiquidType] },
            { no: 6, name: "density_g_ml", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/, options: { "buf.validate.field": { double: { lte: 2, gte: 0.5 } } } }
        ]);
    }
    create(value?: PartialMessage<LiquidInventory>): LiquidInventory {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.name = "";
        message.pumpIndex = 0;
        message.availableMl = 0;
        message.type = 0;
        message.densityGMl = 0;
        if (value !== undefined)
            reflectionMergePartial<LiquidInventory>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LiquidInventory): LiquidInventory {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* int32 pump_index */ 3:
                    message.pumpIndex = reader.int32();
                    break;
                case /* double available_ml */ 4:
                    message.availableMl = reader.double();
                    break;
                case /* enose.experiment.LiquidType type */ 5:
                    message.type = reader.int32();
                    break;
                case /* double density_g_ml */ 6:
                    message.densityGMl = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LiquidInventory, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* int32 pump_index = 3; */
        if (message.pumpIndex !== 0)
            writer.tag(3, WireType.Varint).int32(message.pumpIndex);
        /* double available_ml = 4; */
        if (message.availableMl !== 0)
            writer.tag(4, WireType.Bit64).double(message.availableMl);
        /* enose.experiment.LiquidType type = 5; */
        if (message.type !== 0)
            writer.tag(5, WireType.Varint).int32(message.type);
        /* double density_g_ml = 6; */
        if (message.densityGMl !== 0)
            writer.tag(6, WireType.Bit64).double(message.densityGMl);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.experiment.LiquidInventory
 */
export const LiquidInventory = new LiquidInventory$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Step$Type extends MessageType<Step> {
    constructor() {
        super("enose.experiment.Step", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "buf.validate.field": { string: { minLen: "1" } } } },
            { no: 10, name: "inject", kind: "message", oneof: "action", T: () => InjectAction },
            { no: 11, name: "wait", kind: "message", oneof: "action", T: () => WaitAction },
            { no: 12, name: "drain", kind: "message", oneof: "action", T: () => DrainAction },
            { no: 13, name: "acquire", kind: "message", oneof: "action", T: () => AcquireAction },
            { no: 14, name: "set_state", kind: "message", oneof: "action", T: () => SetStateAction },
            { no: 15, name: "set_gas_pump", kind: "message", oneof: "action", T: () => SetGasPumpAction },
            { no: 16, name: "loop", kind: "message", oneof: "action", T: () => LoopAction },
            { no: 17, name: "phase_marker", kind: "message", oneof: "action", T: () => PhaseMarkerAction }
        ]);
    }
    create(value?: PartialMessage<Step>): Step {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.action = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<Step>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Step): Step {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* enose.experiment.InjectAction inject */ 10:
                    message.action = {
                        oneofKind: "inject",
                        inject: InjectAction.internalBinaryRead(reader, reader.uint32(), options, (message.action as any).inject)
                    };
                    break;
                case /* enose.experiment.WaitAction wait */ 11:
                    message.action = {
                        oneofKind: "wait",
                        wait: WaitAction.internalBinaryRead(reader, reader.uint32(), options, (message.action as any).wait)
                    };
                    break;
                case /* enose.experiment.DrainAction drain */ 12:
                    message.action = {
                        oneofKind: "drain",
                        drain: DrainAction.internalBinaryRead(reader, reader.uint32(), options, (message.action as any).drain)
                    };
                    break;
                case /* enose.experiment.AcquireAction acquire */ 13:
                    message.action = {
                        oneofKind: "acquire",
                        acquire: AcquireAction.internalBinaryRead(reader, reader.uint32(), options, (message.action as any).acquire)
                    };
                    break;
                case /* enose.experiment.SetStateAction set_state */ 14:
                    message.action = {
                        oneofKind: "setState",
                        setState: SetStateAction.internalBinaryRead(reader, reader.uint32(), options, (message.action as any).setState)
                    };
                    break;
                case /* enose.experiment.SetGasPumpAction set_gas_pump */ 15:
                    message.action = {
                        oneofKind: "setGasPump",
                        setGasPump: SetGasPumpAction.internalBinaryRead(reader, reader.uint32(), options, (message.action as any).setGasPump)
                    };
                    break;
                case /* enose.experiment.LoopAction loop */ 16:
                    message.action = {
                        oneofKind: "loop",
                        loop: LoopAction.internalBinaryRead(reader, reader.uint32(), options, (message.action as any).loop)
                    };
                    break;
                case /* enose.experiment.PhaseMarkerAction phase_marker */ 17:
                    message.action = {
                        oneofKind: "phaseMarker",
                        phaseMarker: PhaseMarkerAction.internalBinaryRead(reader, reader.uint32(), options, (message.action as any).phaseMarker)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Step, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* enose.experiment.InjectAction inject = 10; */
        if (message.action.oneofKind === "inject")
            InjectAction.internalBinaryWrite(message.action.inject, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* enose.experiment.WaitAction wait = 11; */
        if (message.action.oneofKind === "wait")
            WaitAction.internalBinaryWrite(message.action.wait, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* enose.experiment.DrainAction drain = 12; */
        if (message.action.oneofKind === "drain")
            DrainAction.internalBinaryWrite(message.action.drain, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* enose.experiment.AcquireAction acquire = 13; */
        if (message.action.oneofKind === "acquire")
            AcquireAction.internalBinaryWrite(message.action.acquire, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* enose.experiment.SetStateAction set_state = 14; */
        if (message.action.oneofKind === "setState")
            SetStateAction.internalBinaryWrite(message.action.setState, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* enose.experiment.SetGasPumpAction set_gas_pump = 15; */
        if (message.action.oneofKind === "setGasPump")
            SetGasPumpAction.internalBinaryWrite(message.action.setGasPump, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        /* enose.experiment.LoopAction loop = 16; */
        if (message.action.oneofKind === "loop")
            LoopAction.internalBinaryWrite(message.action.loop, writer.tag(16, WireType.LengthDelimited).fork(), options).join();
        /* enose.experiment.PhaseMarkerAction phase_marker = 17; */
        if (message.action.oneofKind === "phaseMarker")
            PhaseMarkerAction.internalBinaryWrite(message.action.phaseMarker, writer.tag(17, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.experiment.Step
 */
export const Step = new Step$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InjectAction$Type extends MessageType<InjectAction> {
    constructor() {
        super("enose.experiment.InjectAction", [
            { no: 1, name: "components", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => LiquidComponent, options: { "buf.validate.field": { repeated: { minItems: "1" } } } },
            { no: 2, name: "target_volume_ml", kind: "scalar", oneof: "target", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "target_weight_g", kind: "scalar", oneof: "target", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 4, name: "tolerance", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/, options: { "buf.validate.field": { double: { lte: 10, gt: 0 } } } },
            { no: 5, name: "flow_rate_ml_min", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/, options: { "buf.validate.field": { double: { lte: 20, gte: 0.5 } } } },
            { no: 6, name: "stable_timeout_s", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/, options: { "buf.validate.field": { double: { lte: 300, gte: 5 } } } }
        ], { "buf.validate.message": { cel: [{ id: "ratio_sum_one", message: "\u6240\u6709\u6DB2\u4F53\u6BD4\u4F8B\u4E4B\u548C\u5FC5\u987B\u4E3A1", expression: "math.abs(this.components.map(c, c.ratio).sum() - 1.0) < 0.01" }] } });
    }
    create(value?: PartialMessage<InjectAction>): InjectAction {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.components = [];
        message.target = { oneofKind: undefined };
        message.tolerance = 0;
        message.flowRateMlMin = 0;
        message.stableTimeoutS = 0;
        if (value !== undefined)
            reflectionMergePartial<InjectAction>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InjectAction): InjectAction {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated enose.experiment.LiquidComponent components */ 1:
                    message.components.push(LiquidComponent.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* double target_volume_ml */ 2:
                    message.target = {
                        oneofKind: "targetVolumeMl",
                        targetVolumeMl: reader.double()
                    };
                    break;
                case /* double target_weight_g */ 3:
                    message.target = {
                        oneofKind: "targetWeightG",
                        targetWeightG: reader.double()
                    };
                    break;
                case /* double tolerance */ 4:
                    message.tolerance = reader.double();
                    break;
                case /* double flow_rate_ml_min */ 5:
                    message.flowRateMlMin = reader.double();
                    break;
                case /* double stable_timeout_s */ 6:
                    message.stableTimeoutS = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InjectAction, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated enose.experiment.LiquidComponent components = 1; */
        for (let i = 0; i < message.components.length; i++)
            LiquidComponent.internalBinaryWrite(message.components[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* double target_volume_ml = 2; */
        if (message.target.oneofKind === "targetVolumeMl")
            writer.tag(2, WireType.Bit64).double(message.target.targetVolumeMl);
        /* double target_weight_g = 3; */
        if (message.target.oneofKind === "targetWeightG")
            writer.tag(3, WireType.Bit64).double(message.target.targetWeightG);
        /* double tolerance = 4; */
        if (message.tolerance !== 0)
            writer.tag(4, WireType.Bit64).double(message.tolerance);
        /* double flow_rate_ml_min = 5; */
        if (message.flowRateMlMin !== 0)
            writer.tag(5, WireType.Bit64).double(message.flowRateMlMin);
        /* double stable_timeout_s = 6; */
        if (message.stableTimeoutS !== 0)
            writer.tag(6, WireType.Bit64).double(message.stableTimeoutS);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.experiment.InjectAction
 */
export const InjectAction = new InjectAction$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LiquidComponent$Type extends MessageType<LiquidComponent> {
    constructor() {
        super("enose.experiment.LiquidComponent", [
            { no: 1, name: "liquid_id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "buf.validate.field": { string: { minLen: "1" } } } },
            { no: 2, name: "ratio", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/, options: { "buf.validate.field": { double: { lte: 1, gt: 0 } } } }
        ]);
    }
    create(value?: PartialMessage<LiquidComponent>): LiquidComponent {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.liquidId = "";
        message.ratio = 0;
        if (value !== undefined)
            reflectionMergePartial<LiquidComponent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LiquidComponent): LiquidComponent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string liquid_id */ 1:
                    message.liquidId = reader.string();
                    break;
                case /* double ratio */ 2:
                    message.ratio = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LiquidComponent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string liquid_id = 1; */
        if (message.liquidId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.liquidId);
        /* double ratio = 2; */
        if (message.ratio !== 0)
            writer.tag(2, WireType.Bit64).double(message.ratio);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.experiment.LiquidComponent
 */
export const LiquidComponent = new LiquidComponent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WaitAction$Type extends MessageType<WaitAction> {
    constructor() {
        super("enose.experiment.WaitAction", [
            { no: 1, name: "duration_s", kind: "scalar", oneof: "condition", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "heater_cycles", kind: "scalar", oneof: "condition", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "stability", kind: "message", oneof: "condition", T: () => StabilityCondition },
            { no: 4, name: "weight", kind: "message", oneof: "condition", T: () => WeightCondition },
            { no: 5, name: "empty", kind: "message", oneof: "condition", T: () => EmptyBottleCondition },
            { no: 10, name: "timeout_s", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/, options: { "buf.validate.field": { double: { lte: 3600, gt: 0 } } } }
        ]);
    }
    create(value?: PartialMessage<WaitAction>): WaitAction {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.condition = { oneofKind: undefined };
        message.timeoutS = 0;
        if (value !== undefined)
            reflectionMergePartial<WaitAction>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WaitAction): WaitAction {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double duration_s */ 1:
                    message.condition = {
                        oneofKind: "durationS",
                        durationS: reader.double()
                    };
                    break;
                case /* int32 heater_cycles */ 2:
                    message.condition = {
                        oneofKind: "heaterCycles",
                        heaterCycles: reader.int32()
                    };
                    break;
                case /* enose.experiment.StabilityCondition stability */ 3:
                    message.condition = {
                        oneofKind: "stability",
                        stability: StabilityCondition.internalBinaryRead(reader, reader.uint32(), options, (message.condition as any).stability)
                    };
                    break;
                case /* enose.experiment.WeightCondition weight */ 4:
                    message.condition = {
                        oneofKind: "weight",
                        weight: WeightCondition.internalBinaryRead(reader, reader.uint32(), options, (message.condition as any).weight)
                    };
                    break;
                case /* enose.experiment.EmptyBottleCondition empty */ 5:
                    message.condition = {
                        oneofKind: "empty",
                        empty: EmptyBottleCondition.internalBinaryRead(reader, reader.uint32(), options, (message.condition as any).empty)
                    };
                    break;
                case /* double timeout_s */ 10:
                    message.timeoutS = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WaitAction, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double duration_s = 1; */
        if (message.condition.oneofKind === "durationS")
            writer.tag(1, WireType.Bit64).double(message.condition.durationS);
        /* int32 heater_cycles = 2; */
        if (message.condition.oneofKind === "heaterCycles")
            writer.tag(2, WireType.Varint).int32(message.condition.heaterCycles);
        /* enose.experiment.StabilityCondition stability = 3; */
        if (message.condition.oneofKind === "stability")
            StabilityCondition.internalBinaryWrite(message.condition.stability, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* enose.experiment.WeightCondition weight = 4; */
        if (message.condition.oneofKind === "weight")
            WeightCondition.internalBinaryWrite(message.condition.weight, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* enose.experiment.EmptyBottleCondition empty = 5; */
        if (message.condition.oneofKind === "empty")
            EmptyBottleCondition.internalBinaryWrite(message.condition.empty, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* double timeout_s = 10; */
        if (message.timeoutS !== 0)
            writer.tag(10, WireType.Bit64).double(message.timeoutS);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.experiment.WaitAction
 */
export const WaitAction = new WaitAction$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StabilityCondition$Type extends MessageType<StabilityCondition> {
    constructor() {
        super("enose.experiment.StabilityCondition", [
            { no: 1, name: "window_s", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/, options: { "buf.validate.field": { double: { lte: 300, gte: 5 } } } },
            { no: 2, name: "threshold_percent", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/, options: { "buf.validate.field": { double: { lte: 20, gt: 0 } } } }
        ]);
    }
    create(value?: PartialMessage<StabilityCondition>): StabilityCondition {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.windowS = 0;
        message.thresholdPercent = 0;
        if (value !== undefined)
            reflectionMergePartial<StabilityCondition>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StabilityCondition): StabilityCondition {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double window_s */ 1:
                    message.windowS = reader.double();
                    break;
                case /* double threshold_percent */ 2:
                    message.thresholdPercent = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StabilityCondition, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double window_s = 1; */
        if (message.windowS !== 0)
            writer.tag(1, WireType.Bit64).double(message.windowS);
        /* double threshold_percent = 2; */
        if (message.thresholdPercent !== 0)
            writer.tag(2, WireType.Bit64).double(message.thresholdPercent);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.experiment.StabilityCondition
 */
export const StabilityCondition = new StabilityCondition$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WeightCondition$Type extends MessageType<WeightCondition> {
    constructor() {
        super("enose.experiment.WeightCondition", [
            { no: 1, name: "target_g", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "tolerance_g", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/, options: { "buf.validate.field": { double: { gt: 0 } } } }
        ]);
    }
    create(value?: PartialMessage<WeightCondition>): WeightCondition {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.targetG = 0;
        message.toleranceG = 0;
        if (value !== undefined)
            reflectionMergePartial<WeightCondition>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WeightCondition): WeightCondition {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double target_g */ 1:
                    message.targetG = reader.double();
                    break;
                case /* double tolerance_g */ 2:
                    message.toleranceG = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WeightCondition, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double target_g = 1; */
        if (message.targetG !== 0)
            writer.tag(1, WireType.Bit64).double(message.targetG);
        /* double tolerance_g = 2; */
        if (message.toleranceG !== 0)
            writer.tag(2, WireType.Bit64).double(message.toleranceG);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.experiment.WeightCondition
 */
export const WeightCondition = new WeightCondition$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EmptyBottleCondition$Type extends MessageType<EmptyBottleCondition> {
    constructor() {
        super("enose.experiment.EmptyBottleCondition", [
            { no: 1, name: "tolerance_g", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/, options: { "buf.validate.field": { double: { lte: 100, gt: 0 } } } },
            { no: 2, name: "stability_window_s", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/, options: { "buf.validate.field": { double: { lte: 60, gte: 1 } } } }
        ]);
    }
    create(value?: PartialMessage<EmptyBottleCondition>): EmptyBottleCondition {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.toleranceG = 0;
        message.stabilityWindowS = 0;
        if (value !== undefined)
            reflectionMergePartial<EmptyBottleCondition>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EmptyBottleCondition): EmptyBottleCondition {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double tolerance_g */ 1:
                    message.toleranceG = reader.double();
                    break;
                case /* double stability_window_s */ 2:
                    message.stabilityWindowS = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EmptyBottleCondition, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double tolerance_g = 1; */
        if (message.toleranceG !== 0)
            writer.tag(1, WireType.Bit64).double(message.toleranceG);
        /* double stability_window_s = 2; */
        if (message.stabilityWindowS !== 0)
            writer.tag(2, WireType.Bit64).double(message.stabilityWindowS);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.experiment.EmptyBottleCondition
 */
export const EmptyBottleCondition = new EmptyBottleCondition$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DrainAction$Type extends MessageType<DrainAction> {
    constructor() {
        super("enose.experiment.DrainAction", [
            { no: 1, name: "gas_pump_pwm", kind: "scalar", T: 5 /*ScalarType.INT32*/, options: { "buf.validate.field": { int32: { lte: 100, gte: 0 } } } },
            { no: 2, name: "empty_tolerance_g", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/, options: { "buf.validate.field": { double: { lte: 100, gt: 0 } } } },
            { no: 3, name: "stability_window_s", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/, options: { "buf.validate.field": { double: { lte: 60, gte: 1 } } } },
            { no: 4, name: "timeout_s", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/, options: { "buf.validate.field": { double: { lte: 300, gt: 0 } } } }
        ]);
    }
    create(value?: PartialMessage<DrainAction>): DrainAction {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.gasPumpPwm = 0;
        message.emptyToleranceG = 0;
        message.stabilityWindowS = 0;
        message.timeoutS = 0;
        if (value !== undefined)
            reflectionMergePartial<DrainAction>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DrainAction): DrainAction {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 gas_pump_pwm */ 1:
                    message.gasPumpPwm = reader.int32();
                    break;
                case /* double empty_tolerance_g */ 2:
                    message.emptyToleranceG = reader.double();
                    break;
                case /* double stability_window_s */ 3:
                    message.stabilityWindowS = reader.double();
                    break;
                case /* double timeout_s */ 4:
                    message.timeoutS = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DrainAction, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 gas_pump_pwm = 1; */
        if (message.gasPumpPwm !== 0)
            writer.tag(1, WireType.Varint).int32(message.gasPumpPwm);
        /* double empty_tolerance_g = 2; */
        if (message.emptyToleranceG !== 0)
            writer.tag(2, WireType.Bit64).double(message.emptyToleranceG);
        /* double stability_window_s = 3; */
        if (message.stabilityWindowS !== 0)
            writer.tag(3, WireType.Bit64).double(message.stabilityWindowS);
        /* double timeout_s = 4; */
        if (message.timeoutS !== 0)
            writer.tag(4, WireType.Bit64).double(message.timeoutS);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.experiment.DrainAction
 */
export const DrainAction = new DrainAction$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AcquireAction$Type extends MessageType<AcquireAction> {
    constructor() {
        super("enose.experiment.AcquireAction", [
            { no: 1, name: "gas_pump_pwm", kind: "scalar", T: 5 /*ScalarType.INT32*/, options: { "buf.validate.field": { int32: { lte: 100, gte: 0 } } } },
            { no: 2, name: "duration_s", kind: "scalar", oneof: "termination", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "heater_cycles", kind: "scalar", oneof: "termination", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "stability", kind: "message", oneof: "termination", T: () => StabilityCondition },
            { no: 10, name: "max_duration_s", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/, options: { "buf.validate.field": { double: { lte: 3600, gt: 0 } } } }
        ]);
    }
    create(value?: PartialMessage<AcquireAction>): AcquireAction {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.gasPumpPwm = 0;
        message.termination = { oneofKind: undefined };
        message.maxDurationS = 0;
        if (value !== undefined)
            reflectionMergePartial<AcquireAction>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AcquireAction): AcquireAction {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 gas_pump_pwm */ 1:
                    message.gasPumpPwm = reader.int32();
                    break;
                case /* double duration_s */ 2:
                    message.termination = {
                        oneofKind: "durationS",
                        durationS: reader.double()
                    };
                    break;
                case /* int32 heater_cycles */ 3:
                    message.termination = {
                        oneofKind: "heaterCycles",
                        heaterCycles: reader.int32()
                    };
                    break;
                case /* enose.experiment.StabilityCondition stability */ 4:
                    message.termination = {
                        oneofKind: "stability",
                        stability: StabilityCondition.internalBinaryRead(reader, reader.uint32(), options, (message.termination as any).stability)
                    };
                    break;
                case /* double max_duration_s */ 10:
                    message.maxDurationS = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AcquireAction, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 gas_pump_pwm = 1; */
        if (message.gasPumpPwm !== 0)
            writer.tag(1, WireType.Varint).int32(message.gasPumpPwm);
        /* double duration_s = 2; */
        if (message.termination.oneofKind === "durationS")
            writer.tag(2, WireType.Bit64).double(message.termination.durationS);
        /* int32 heater_cycles = 3; */
        if (message.termination.oneofKind === "heaterCycles")
            writer.tag(3, WireType.Varint).int32(message.termination.heaterCycles);
        /* enose.experiment.StabilityCondition stability = 4; */
        if (message.termination.oneofKind === "stability")
            StabilityCondition.internalBinaryWrite(message.termination.stability, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* double max_duration_s = 10; */
        if (message.maxDurationS !== 0)
            writer.tag(10, WireType.Bit64).double(message.maxDurationS);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.experiment.AcquireAction
 */
export const AcquireAction = new AcquireAction$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetStateAction$Type extends MessageType<SetStateAction> {
    constructor() {
        super("enose.experiment.SetStateAction", [
            { no: 1, name: "state", kind: "enum", T: () => ["enose.experiment.SystemState", SystemState], options: { "buf.validate.field": { enum: { definedOnly: true, notIn: [0] } } } }
        ]);
    }
    create(value?: PartialMessage<SetStateAction>): SetStateAction {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.state = 0;
        if (value !== undefined)
            reflectionMergePartial<SetStateAction>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetStateAction): SetStateAction {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* enose.experiment.SystemState state */ 1:
                    message.state = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetStateAction, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* enose.experiment.SystemState state = 1; */
        if (message.state !== 0)
            writer.tag(1, WireType.Varint).int32(message.state);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.experiment.SetStateAction
 */
export const SetStateAction = new SetStateAction$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetGasPumpAction$Type extends MessageType<SetGasPumpAction> {
    constructor() {
        super("enose.experiment.SetGasPumpAction", [
            { no: 1, name: "pwm_percent", kind: "scalar", T: 5 /*ScalarType.INT32*/, options: { "buf.validate.field": { int32: { lte: 100, gte: 0 } } } }
        ]);
    }
    create(value?: PartialMessage<SetGasPumpAction>): SetGasPumpAction {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.pwmPercent = 0;
        if (value !== undefined)
            reflectionMergePartial<SetGasPumpAction>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetGasPumpAction): SetGasPumpAction {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 pwm_percent */ 1:
                    message.pwmPercent = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetGasPumpAction, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 pwm_percent = 1; */
        if (message.pwmPercent !== 0)
            writer.tag(1, WireType.Varint).int32(message.pwmPercent);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.experiment.SetGasPumpAction
 */
export const SetGasPumpAction = new SetGasPumpAction$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LoopAction$Type extends MessageType<LoopAction> {
    constructor() {
        super("enose.experiment.LoopAction", [
            { no: 1, name: "count", kind: "scalar", T: 5 /*ScalarType.INT32*/, options: { "buf.validate.field": { int32: { lte: 100, gte: 1 } } } },
            { no: 2, name: "steps", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Step, options: { "buf.validate.field": { repeated: { minItems: "1" } } } }
        ]);
    }
    create(value?: PartialMessage<LoopAction>): LoopAction {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.count = 0;
        message.steps = [];
        if (value !== undefined)
            reflectionMergePartial<LoopAction>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LoopAction): LoopAction {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 count */ 1:
                    message.count = reader.int32();
                    break;
                case /* repeated enose.experiment.Step steps */ 2:
                    message.steps.push(Step.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LoopAction, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 count = 1; */
        if (message.count !== 0)
            writer.tag(1, WireType.Varint).int32(message.count);
        /* repeated enose.experiment.Step steps = 2; */
        for (let i = 0; i < message.steps.length; i++)
            Step.internalBinaryWrite(message.steps[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.experiment.LoopAction
 */
export const LoopAction = new LoopAction$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PhaseMarkerAction$Type extends MessageType<PhaseMarkerAction> {
    constructor() {
        super("enose.experiment.PhaseMarkerAction", [
            { no: 1, name: "phase_name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "buf.validate.field": { string: { minLen: "1" } } } },
            { no: 2, name: "is_start", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<PhaseMarkerAction>): PhaseMarkerAction {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.phaseName = "";
        message.isStart = false;
        if (value !== undefined)
            reflectionMergePartial<PhaseMarkerAction>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PhaseMarkerAction): PhaseMarkerAction {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string phase_name */ 1:
                    message.phaseName = reader.string();
                    break;
                case /* bool is_start */ 2:
                    message.isStart = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PhaseMarkerAction, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string phase_name = 1; */
        if (message.phaseName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.phaseName);
        /* bool is_start = 2; */
        if (message.isStart !== false)
            writer.tag(2, WireType.Varint).bool(message.isStart);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.experiment.PhaseMarkerAction
 */
export const PhaseMarkerAction = new PhaseMarkerAction$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Metadata$Type extends MessageType<Metadata> {
    constructor() {
        super("enose.experiment.Metadata", [
            { no: 1, name: "author", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "created_at", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "updated_at", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "tags", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "notes", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Metadata>): Metadata {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.author = "";
        message.createdAt = "";
        message.updatedAt = "";
        message.tags = [];
        message.notes = "";
        if (value !== undefined)
            reflectionMergePartial<Metadata>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Metadata): Metadata {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string author */ 1:
                    message.author = reader.string();
                    break;
                case /* string created_at */ 2:
                    message.createdAt = reader.string();
                    break;
                case /* string updated_at */ 3:
                    message.updatedAt = reader.string();
                    break;
                case /* repeated string tags */ 4:
                    message.tags.push(reader.string());
                    break;
                case /* string notes */ 5:
                    message.notes = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Metadata, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string author = 1; */
        if (message.author !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.author);
        /* string created_at = 2; */
        if (message.createdAt !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.createdAt);
        /* string updated_at = 3; */
        if (message.updatedAt !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.updatedAt);
        /* repeated string tags = 4; */
        for (let i = 0; i < message.tags.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.tags[i]);
        /* string notes = 5; */
        if (message.notes !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.notes);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.experiment.Metadata
 */
export const Metadata = new Metadata$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ValidationResult$Type extends MessageType<ValidationResult> {
    constructor() {
        super("enose.experiment.ValidationResult", [
            { no: 1, name: "valid", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "errors", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ValidationError },
            { no: 3, name: "warnings", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ValidationError },
            { no: 4, name: "estimate", kind: "message", T: () => ResourceEstimate }
        ]);
    }
    create(value?: PartialMessage<ValidationResult>): ValidationResult {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.valid = false;
        message.errors = [];
        message.warnings = [];
        if (value !== undefined)
            reflectionMergePartial<ValidationResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ValidationResult): ValidationResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool valid */ 1:
                    message.valid = reader.bool();
                    break;
                case /* repeated enose.experiment.ValidationError errors */ 2:
                    message.errors.push(ValidationError.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated enose.experiment.ValidationError warnings */ 3:
                    message.warnings.push(ValidationError.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* enose.experiment.ResourceEstimate estimate */ 4:
                    message.estimate = ResourceEstimate.internalBinaryRead(reader, reader.uint32(), options, message.estimate);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ValidationResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool valid = 1; */
        if (message.valid !== false)
            writer.tag(1, WireType.Varint).bool(message.valid);
        /* repeated enose.experiment.ValidationError errors = 2; */
        for (let i = 0; i < message.errors.length; i++)
            ValidationError.internalBinaryWrite(message.errors[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated enose.experiment.ValidationError warnings = 3; */
        for (let i = 0; i < message.warnings.length; i++)
            ValidationError.internalBinaryWrite(message.warnings[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* enose.experiment.ResourceEstimate estimate = 4; */
        if (message.estimate)
            ResourceEstimate.internalBinaryWrite(message.estimate, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.experiment.ValidationResult
 */
export const ValidationResult = new ValidationResult$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ValidationError$Type extends MessageType<ValidationError> {
    constructor() {
        super("enose.experiment.ValidationError", [
            { no: 1, name: "path", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "code", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "severity", kind: "enum", T: () => ["enose.experiment.ValidationError.Severity", ValidationError_Severity] }
        ]);
    }
    create(value?: PartialMessage<ValidationError>): ValidationError {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.path = "";
        message.code = "";
        message.message = "";
        message.severity = 0;
        if (value !== undefined)
            reflectionMergePartial<ValidationError>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ValidationError): ValidationError {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string path */ 1:
                    message.path = reader.string();
                    break;
                case /* string code */ 2:
                    message.code = reader.string();
                    break;
                case /* string message */ 3:
                    message.message = reader.string();
                    break;
                case /* enose.experiment.ValidationError.Severity severity */ 4:
                    message.severity = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ValidationError, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string path = 1; */
        if (message.path !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.path);
        /* string code = 2; */
        if (message.code !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.code);
        /* string message = 3; */
        if (message.message !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.message);
        /* enose.experiment.ValidationError.Severity severity = 4; */
        if (message.severity !== 0)
            writer.tag(4, WireType.Varint).int32(message.severity);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.experiment.ValidationError
 */
export const ValidationError = new ValidationError$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResourceEstimate$Type extends MessageType<ResourceEstimate> {
    constructor() {
        super("enose.experiment.ResourceEstimate", [
            { no: 1, name: "pump_consumption_ml", kind: "map", K: 5 /*ScalarType.INT32*/, V: { kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ } },
            { no: 2, name: "peak_liquid_level_ml", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "estimated_duration_s", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 4, name: "heater_cycles", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "liquid_consumption", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => LiquidConsumption }
        ]);
    }
    create(value?: PartialMessage<ResourceEstimate>): ResourceEstimate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.pumpConsumptionMl = {};
        message.peakLiquidLevelMl = 0;
        message.estimatedDurationS = 0;
        message.heaterCycles = 0;
        message.liquidConsumption = [];
        if (value !== undefined)
            reflectionMergePartial<ResourceEstimate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResourceEstimate): ResourceEstimate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<int32, double> pump_consumption_ml */ 1:
                    this.binaryReadMap1(message.pumpConsumptionMl, reader, options);
                    break;
                case /* double peak_liquid_level_ml */ 2:
                    message.peakLiquidLevelMl = reader.double();
                    break;
                case /* double estimated_duration_s */ 3:
                    message.estimatedDurationS = reader.double();
                    break;
                case /* int32 heater_cycles */ 4:
                    message.heaterCycles = reader.int32();
                    break;
                case /* repeated enose.experiment.LiquidConsumption liquid_consumption */ 5:
                    message.liquidConsumption.push(LiquidConsumption.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: ResourceEstimate["pumpConsumptionMl"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof ResourceEstimate["pumpConsumptionMl"] | undefined, val: ResourceEstimate["pumpConsumptionMl"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int32();
                    break;
                case 2:
                    val = reader.double();
                    break;
                default: throw new globalThis.Error("unknown map entry field for enose.experiment.ResourceEstimate.pump_consumption_ml");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    internalBinaryWrite(message: ResourceEstimate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<int32, double> pump_consumption_ml = 1; */
        for (let k of globalThis.Object.keys(message.pumpConsumptionMl))
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int32(parseInt(k)).tag(2, WireType.Bit64).double(message.pumpConsumptionMl[k as any]).join();
        /* double peak_liquid_level_ml = 2; */
        if (message.peakLiquidLevelMl !== 0)
            writer.tag(2, WireType.Bit64).double(message.peakLiquidLevelMl);
        /* double estimated_duration_s = 3; */
        if (message.estimatedDurationS !== 0)
            writer.tag(3, WireType.Bit64).double(message.estimatedDurationS);
        /* int32 heater_cycles = 4; */
        if (message.heaterCycles !== 0)
            writer.tag(4, WireType.Varint).int32(message.heaterCycles);
        /* repeated enose.experiment.LiquidConsumption liquid_consumption = 5; */
        for (let i = 0; i < message.liquidConsumption.length; i++)
            LiquidConsumption.internalBinaryWrite(message.liquidConsumption[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.experiment.ResourceEstimate
 */
export const ResourceEstimate = new ResourceEstimate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LiquidConsumption$Type extends MessageType<LiquidConsumption> {
    constructor() {
        super("enose.experiment.LiquidConsumption", [
            { no: 1, name: "liquid_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "liquid_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "pump_index", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "required_ml", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 5, name: "available_ml", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 6, name: "sufficient", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<LiquidConsumption>): LiquidConsumption {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.liquidId = "";
        message.liquidName = "";
        message.pumpIndex = 0;
        message.requiredMl = 0;
        message.availableMl = 0;
        message.sufficient = false;
        if (value !== undefined)
            reflectionMergePartial<LiquidConsumption>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LiquidConsumption): LiquidConsumption {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string liquid_id */ 1:
                    message.liquidId = reader.string();
                    break;
                case /* string liquid_name */ 2:
                    message.liquidName = reader.string();
                    break;
                case /* int32 pump_index */ 3:
                    message.pumpIndex = reader.int32();
                    break;
                case /* double required_ml */ 4:
                    message.requiredMl = reader.double();
                    break;
                case /* double available_ml */ 5:
                    message.availableMl = reader.double();
                    break;
                case /* bool sufficient */ 6:
                    message.sufficient = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LiquidConsumption, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string liquid_id = 1; */
        if (message.liquidId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.liquidId);
        /* string liquid_name = 2; */
        if (message.liquidName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.liquidName);
        /* int32 pump_index = 3; */
        if (message.pumpIndex !== 0)
            writer.tag(3, WireType.Varint).int32(message.pumpIndex);
        /* double required_ml = 4; */
        if (message.requiredMl !== 0)
            writer.tag(4, WireType.Bit64).double(message.requiredMl);
        /* double available_ml = 5; */
        if (message.availableMl !== 0)
            writer.tag(5, WireType.Bit64).double(message.availableMl);
        /* bool sufficient = 6; */
        if (message.sufficient !== false)
            writer.tag(6, WireType.Varint).bool(message.sufficient);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.experiment.LiquidConsumption
 */
export const LiquidConsumption = new LiquidConsumption$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ValidateProgramRequest$Type extends MessageType<ValidateProgramRequest> {
    constructor() {
        super("enose.experiment.ValidateProgramRequest", [
            { no: 1, name: "program", kind: "message", oneof: "source", T: () => ExperimentProgram },
            { no: 2, name: "yaml_content", kind: "scalar", oneof: "source", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ValidateProgramRequest>): ValidateProgramRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.source = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<ValidateProgramRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ValidateProgramRequest): ValidateProgramRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* enose.experiment.ExperimentProgram program */ 1:
                    message.source = {
                        oneofKind: "program",
                        program: ExperimentProgram.internalBinaryRead(reader, reader.uint32(), options, (message.source as any).program)
                    };
                    break;
                case /* string yaml_content */ 2:
                    message.source = {
                        oneofKind: "yamlContent",
                        yamlContent: reader.string()
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ValidateProgramRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* enose.experiment.ExperimentProgram program = 1; */
        if (message.source.oneofKind === "program")
            ExperimentProgram.internalBinaryWrite(message.source.program, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string yaml_content = 2; */
        if (message.source.oneofKind === "yamlContent")
            writer.tag(2, WireType.LengthDelimited).string(message.source.yamlContent);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.experiment.ValidateProgramRequest
 */
export const ValidateProgramRequest = new ValidateProgramRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LoadProgramRequest$Type extends MessageType<LoadProgramRequest> {
    constructor() {
        super("enose.experiment.LoadProgramRequest", [
            { no: 1, name: "program", kind: "message", oneof: "source", T: () => ExperimentProgram },
            { no: 2, name: "yaml_content", kind: "scalar", oneof: "source", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<LoadProgramRequest>): LoadProgramRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.source = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<LoadProgramRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LoadProgramRequest): LoadProgramRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* enose.experiment.ExperimentProgram program */ 1:
                    message.source = {
                        oneofKind: "program",
                        program: ExperimentProgram.internalBinaryRead(reader, reader.uint32(), options, (message.source as any).program)
                    };
                    break;
                case /* string yaml_content */ 2:
                    message.source = {
                        oneofKind: "yamlContent",
                        yamlContent: reader.string()
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LoadProgramRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* enose.experiment.ExperimentProgram program = 1; */
        if (message.source.oneofKind === "program")
            ExperimentProgram.internalBinaryWrite(message.source.program, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string yaml_content = 2; */
        if (message.source.oneofKind === "yamlContent")
            writer.tag(2, WireType.LengthDelimited).string(message.source.yamlContent);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.experiment.LoadProgramRequest
 */
export const LoadProgramRequest = new LoadProgramRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LoadProgramResponse$Type extends MessageType<LoadProgramResponse> {
    constructor() {
        super("enose.experiment.LoadProgramResponse", [
            { no: 1, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "validation", kind: "message", T: () => ValidationResult },
            { no: 3, name: "error_message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<LoadProgramResponse>): LoadProgramResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.success = false;
        message.errorMessage = "";
        if (value !== undefined)
            reflectionMergePartial<LoadProgramResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LoadProgramResponse): LoadProgramResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool success */ 1:
                    message.success = reader.bool();
                    break;
                case /* enose.experiment.ValidationResult validation */ 2:
                    message.validation = ValidationResult.internalBinaryRead(reader, reader.uint32(), options, message.validation);
                    break;
                case /* string error_message */ 3:
                    message.errorMessage = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LoadProgramResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool success = 1; */
        if (message.success !== false)
            writer.tag(1, WireType.Varint).bool(message.success);
        /* enose.experiment.ValidationResult validation = 2; */
        if (message.validation)
            ValidationResult.internalBinaryWrite(message.validation, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string error_message = 3; */
        if (message.errorMessage !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.errorMessage);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.experiment.LoadProgramResponse
 */
export const LoadProgramResponse = new LoadProgramResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExperimentStatusResponse$Type extends MessageType<ExperimentStatusResponse> {
    constructor() {
        super("enose.experiment.ExperimentStatusResponse", [
            { no: 1, name: "state", kind: "enum", T: () => ["enose.experiment.ExperimentState", ExperimentState] },
            { no: 2, name: "program_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "current_step_index", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "current_step_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "loop_iteration", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "loop_total", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "progress_percent", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "elapsed_s", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 9, name: "remaining_s", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 10, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "logs", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "error", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ExperimentStatusResponse>): ExperimentStatusResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.state = 0;
        message.programId = "";
        message.currentStepIndex = 0;
        message.currentStepName = "";
        message.loopIteration = 0;
        message.loopTotal = 0;
        message.progressPercent = 0;
        message.elapsedS = 0;
        message.remainingS = 0;
        message.message = "";
        message.logs = [];
        message.error = "";
        if (value !== undefined)
            reflectionMergePartial<ExperimentStatusResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExperimentStatusResponse): ExperimentStatusResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* enose.experiment.ExperimentState state */ 1:
                    message.state = reader.int32();
                    break;
                case /* string program_id */ 2:
                    message.programId = reader.string();
                    break;
                case /* int32 current_step_index */ 3:
                    message.currentStepIndex = reader.int32();
                    break;
                case /* string current_step_name */ 4:
                    message.currentStepName = reader.string();
                    break;
                case /* int32 loop_iteration */ 5:
                    message.loopIteration = reader.int32();
                    break;
                case /* int32 loop_total */ 6:
                    message.loopTotal = reader.int32();
                    break;
                case /* int32 progress_percent */ 7:
                    message.progressPercent = reader.int32();
                    break;
                case /* double elapsed_s */ 8:
                    message.elapsedS = reader.double();
                    break;
                case /* double remaining_s */ 9:
                    message.remainingS = reader.double();
                    break;
                case /* string message */ 10:
                    message.message = reader.string();
                    break;
                case /* repeated string logs */ 11:
                    message.logs.push(reader.string());
                    break;
                case /* string error */ 12:
                    message.error = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExperimentStatusResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* enose.experiment.ExperimentState state = 1; */
        if (message.state !== 0)
            writer.tag(1, WireType.Varint).int32(message.state);
        /* string program_id = 2; */
        if (message.programId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.programId);
        /* int32 current_step_index = 3; */
        if (message.currentStepIndex !== 0)
            writer.tag(3, WireType.Varint).int32(message.currentStepIndex);
        /* string current_step_name = 4; */
        if (message.currentStepName !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.currentStepName);
        /* int32 loop_iteration = 5; */
        if (message.loopIteration !== 0)
            writer.tag(5, WireType.Varint).int32(message.loopIteration);
        /* int32 loop_total = 6; */
        if (message.loopTotal !== 0)
            writer.tag(6, WireType.Varint).int32(message.loopTotal);
        /* int32 progress_percent = 7; */
        if (message.progressPercent !== 0)
            writer.tag(7, WireType.Varint).int32(message.progressPercent);
        /* double elapsed_s = 8; */
        if (message.elapsedS !== 0)
            writer.tag(8, WireType.Bit64).double(message.elapsedS);
        /* double remaining_s = 9; */
        if (message.remainingS !== 0)
            writer.tag(9, WireType.Bit64).double(message.remainingS);
        /* string message = 10; */
        if (message.message !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.message);
        /* repeated string logs = 11; */
        for (let i = 0; i < message.logs.length; i++)
            writer.tag(11, WireType.LengthDelimited).string(message.logs[i]);
        /* string error = 12; */
        if (message.error !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.error);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.experiment.ExperimentStatusResponse
 */
export const ExperimentStatusResponse = new ExperimentStatusResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExperimentEvent$Type extends MessageType<ExperimentEvent> {
    constructor() {
        super("enose.experiment.ExperimentEvent", [
            { no: 1, name: "timestamp", kind: "message", T: () => Timestamp },
            { no: 2, name: "type", kind: "enum", T: () => ["enose.experiment.ExperimentEvent.EventType", ExperimentEvent_EventType] },
            { no: 3, name: "step_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "phase_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "data", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } }
        ]);
    }
    create(value?: PartialMessage<ExperimentEvent>): ExperimentEvent {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = 0;
        message.stepName = "";
        message.phaseName = "";
        message.message = "";
        message.data = {};
        if (value !== undefined)
            reflectionMergePartial<ExperimentEvent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExperimentEvent): ExperimentEvent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Timestamp timestamp */ 1:
                    message.timestamp = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.timestamp);
                    break;
                case /* enose.experiment.ExperimentEvent.EventType type */ 2:
                    message.type = reader.int32();
                    break;
                case /* string step_name */ 3:
                    message.stepName = reader.string();
                    break;
                case /* string phase_name */ 4:
                    message.phaseName = reader.string();
                    break;
                case /* string message */ 5:
                    message.message = reader.string();
                    break;
                case /* map<string, string> data */ 10:
                    this.binaryReadMap10(message.data, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap10(map: ExperimentEvent["data"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof ExperimentEvent["data"] | undefined, val: ExperimentEvent["data"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for enose.experiment.ExperimentEvent.data");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: ExperimentEvent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.Timestamp timestamp = 1; */
        if (message.timestamp)
            Timestamp.internalBinaryWrite(message.timestamp, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* enose.experiment.ExperimentEvent.EventType type = 2; */
        if (message.type !== 0)
            writer.tag(2, WireType.Varint).int32(message.type);
        /* string step_name = 3; */
        if (message.stepName !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.stepName);
        /* string phase_name = 4; */
        if (message.phaseName !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.phaseName);
        /* string message = 5; */
        if (message.message !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.message);
        /* map<string, string> data = 10; */
        for (let k of globalThis.Object.keys(message.data))
            writer.tag(10, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.data[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.experiment.ExperimentEvent
 */
export const ExperimentEvent = new ExperimentEvent$Type();
/**
 * @generated ServiceType for protobuf service enose.experiment.ExperimentService
 */
export const ExperimentService = new ServiceType("enose.experiment.ExperimentService", [
    { name: "ValidateProgram", options: {}, I: ValidateProgramRequest, O: ValidationResult },
    { name: "LoadProgram", options: {}, I: LoadProgramRequest, O: LoadProgramResponse },
    { name: "StartExperiment", options: {}, I: Empty, O: ExperimentStatusResponse },
    { name: "StopExperiment", options: {}, I: Empty, O: ExperimentStatusResponse },
    { name: "PauseExperiment", options: {}, I: Empty, O: ExperimentStatusResponse },
    { name: "ResumeExperiment", options: {}, I: Empty, O: ExperimentStatusResponse },
    { name: "GetExperimentStatus", options: {}, I: Empty, O: ExperimentStatusResponse },
    { name: "SubscribeExperimentEvents", serverStreaming: true, options: {}, I: Empty, O: ExperimentEvent }
]);
