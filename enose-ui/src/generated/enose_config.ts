// @generated by protobuf-ts 2.11.1 with parameter long_type_string,generate_dependencies,client_grpc1,server_grpc1
// @generated from protobuf file "enose_config.proto" (package "enose.config", syntax proto3)
// tslint:disable
//
// 电子鼻配置数据结构定义
// 使用 Protobuf 定义，支持 C++/Python/TypeScript 代码生成
// 配置文件使用 JSON 格式存储，人类可读
// 使用 buf validate 进行字段约束验证
//
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * ============================================================
 * 加热器配置 (HeaterProfile)
 * BME688 使用多步加热器温度曲线
 * ============================================================
 *
 * @generated from protobuf message enose.config.HeaterProfile
 */
export interface HeaterProfile {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * @generated from protobuf field: string name = 2
     */
    name: string;
    /**
     * @generated from protobuf field: string description = 3
     */
    description: string;
    /**
     * 时基: 每步持续时间 = time_base_ms × duration_multiplier
     *
     * @generated from protobuf field: int32 time_base_ms = 4
     */
    timeBaseMs: number;
    /**
     * 加热器步骤: 1-10 步
     *
     * @generated from protobuf field: repeated enose.config.HeaterProfile.HeaterStep steps = 5
     */
    steps: HeaterProfile_HeaterStep[];
}
/**
 * @generated from protobuf message enose.config.HeaterProfile.HeaterStep
 */
export interface HeaterProfile_HeaterStep {
    /**
     * 目标温度: 100-400°C
     *
     * @generated from protobuf field: int32 temp_c = 1
     */
    tempC: number;
    /**
     * 持续时间乘数: 实际时间 = time_base_ms × duration_mult
     *
     * @generated from protobuf field: int32 duration_mult = 2
     */
    durationMult: number;
}
/**
 * @generated from protobuf message enose.config.HeaterProfileList
 */
export interface HeaterProfileList {
    /**
     * @generated from protobuf field: repeated enose.config.HeaterProfile heaters = 1
     */
    heaters: HeaterProfile[];
}
/**
 * ============================================================
 * 传感器板定义 (SensorBoard)
 * 抽象不同类型的传感器硬件
 * ============================================================
 *
 * @generated from protobuf message enose.config.SensorBoard
 */
export interface SensorBoard {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * @generated from protobuf field: string name = 2
     */
    name: string;
    /**
     * @generated from protobuf field: string vendor = 3
     */
    vendor: string;
    /**
     * @generated from protobuf field: string firmware_version = 4
     */
    firmwareVersion: string;
    /**
     * @generated from protobuf field: string description = 5
     */
    description: string;
    /**
     * 板子类型 (建议仅作为参考，实际配置以 sensors 列表为准)
     *
     * @generated from protobuf field: enose.config.SensorBoard.BoardType board_type = 6
     */
    boardType: SensorBoard_BoardType;
    /**
     * 通信配置
     *
     * @generated from protobuf field: enose.config.SensorBoard.CommunicationConfig communication = 7
     */
    communication?: SensorBoard_CommunicationConfig;
    /**
     * 传感器阵列配置
     * 替代旧的 ChannelConfig，支持异构传感器定义
     *
     * @generated from protobuf field: repeated enose.config.SensorBoard.SensorDefinition sensors = 8
     */
    sensors: SensorBoard_SensorDefinition[];
    /**
     * 采样配置
     *
     * @generated from protobuf field: enose.config.SensorBoard.SamplingConfig sampling = 9
     */
    sampling?: SensorBoard_SamplingConfig;
    /**
     * 时间戳配置
     *
     * @generated from protobuf field: enose.config.SensorBoard.TimestampConfig timestamp = 10
     */
    timestamp?: SensorBoard_TimestampConfig;
}
/**
 * @generated from protobuf message enose.config.SensorBoard.CommunicationConfig
 */
export interface SensorBoard_CommunicationConfig {
    /**
     * @generated from protobuf field: string protocol = 1
     */
    protocol: string; // serial, i2c, spi    /**
     * @generated from protobuf field: int32 baudrate = 2
     */
    baudrate: number; // 串口波特率    /**
     * @generated from protobuf field: string data_format = 3
     */
    dataFormat: string; // json, binary    /**
     * @generated from protobuf field: int32 timeout_ms = 4
     */
    timeoutMs: number;
}
/**
 * 单个物理传感器的定义
 *
 * @generated from protobuf message enose.config.SensorBoard.SensorDefinition
 */
export interface SensorBoard_SensorDefinition {
    /**
     * 传感器唯一标识 (在板内唯一)
     *
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * 传感器型号
     *
     * @generated from protobuf field: string model = 2
     */
    model: string; // e.g. "BME688", "TGS2602", "SGP40"    /**
     * 传感器类型
     *
     * @generated from protobuf field: string type = 3
     */
    type: string; // e.g. "mox", "pid", "ec"    /**
     * 该传感器支持的测量维度
     *
     * @generated from protobuf field: repeated enose.config.SensorBoard.MeasurementType capabilities = 4
     */
    capabilities: SensorBoard_MeasurementType[];
    /**
     * 元数据 (如位置信息)
     *
     * @generated from protobuf field: map<string, string> metadata = 5
     */
    metadata: {
        [key: string]: string;
    };
}
/**
 * @generated from protobuf message enose.config.SensorBoard.SamplingConfig
 */
export interface SensorBoard_SamplingConfig {
    /**
     * @generated from protobuf field: enose.config.SensorBoard.SamplingConfig.SamplingMode mode = 1
     */
    mode: SensorBoard_SamplingConfig_SamplingMode;
    /**
     * 基础采样率 (Hz)
     *
     * @generated from protobuf field: double base_rate_hz = 2
     */
    baseRateHz: number;
    /**
     * 加热器步数 (仅 heater_cycle 模式)
     *
     * @generated from protobuf field: int32 heater_steps = 3
     */
    heaterSteps: number;
    /**
     * 单次循环时长 (ms)
     *
     * @generated from protobuf field: int32 cycle_duration_ms = 4
     */
    cycleDurationMs: number;
}
/**
 * @generated from protobuf enum enose.config.SensorBoard.SamplingConfig.SamplingMode
 */
export enum SensorBoard_SamplingConfig_SamplingMode {
    /**
     * @generated from protobuf enum value: SAMPLING_MODE_UNSPECIFIED = 0;
     */
    SAMPLING_MODE_UNSPECIFIED = 0,
    /**
     * 连续采样
     *
     * @generated from protobuf enum value: CONTINUOUS = 1;
     */
    CONTINUOUS = 1,
    /**
     * 加热器循环
     *
     * @generated from protobuf enum value: HEATER_CYCLE = 2;
     */
    HEATER_CYCLE = 2,
    /**
     * 按需/单次
     *
     * @generated from protobuf enum value: ON_DEMAND = 3;
     */
    ON_DEMAND = 3
}
/**
 * @generated from protobuf message enose.config.SensorBoard.TimestampConfig
 */
export interface SensorBoard_TimestampConfig {
    /**
     * @generated from protobuf field: enose.config.SensorBoard.TimestampConfig.SyncMethod sync_method = 1
     */
    syncMethod: SensorBoard_TimestampConfig_SyncMethod;
    /**
     * 时间戳分辨率 (微秒)
     *
     * @generated from protobuf field: int32 resolution_us = 2
     */
    resolutionUs: number;
    /**
     * 最大允许漂移 (毫秒)
     *
     * @generated from protobuf field: int32 max_drift_ms = 3
     */
    maxDriftMs: number;
}
/**
 * @generated from protobuf enum enose.config.SensorBoard.TimestampConfig.SyncMethod
 */
export enum SensorBoard_TimestampConfig_SyncMethod {
    /**
     * @generated from protobuf enum value: SYNC_METHOD_UNSPECIFIED = 0;
     */
    SYNC_METHOD_UNSPECIFIED = 0,
    /**
     * 使用设备 tick
     *
     * @generated from protobuf enum value: DEVICE_TICK = 1;
     */
    DEVICE_TICK = 1,
    /**
     * 主机插值
     *
     * @generated from protobuf enum value: HOST_INTERPOLATE = 2;
     */
    HOST_INTERPOLATE = 2,
    /**
     * NTP 同步
     *
     * @generated from protobuf enum value: NTP_SYNC = 3;
     */
    NTP_SYNC = 3
}
/**
 * @generated from protobuf enum enose.config.SensorBoard.BoardType
 */
export enum SensorBoard_BoardType {
    /**
     * @generated from protobuf enum value: BOARD_TYPE_UNSPECIFIED = 0;
     */
    BOARD_TYPE_UNSPECIFIED = 0,
    /**
     * Bosch BME688 开发套件
     *
     * @generated from protobuf enum value: BME688_DEVKIT = 1;
     */
    BME688_DEVKIT = 1,
    /**
     * Sensirion SGP40 阵列
     *
     * @generated from protobuf enum value: SGP40_ARRAY = 2;
     */
    SGP40_ARRAY = 2,
    /**
     * 自定义 MOX 阵列
     *
     * @generated from protobuf enum value: CUSTOM_MOX = 3;
     */
    CUSTOM_MOX = 3
}
/**
 * @generated from protobuf enum enose.config.SensorBoard.MeasurementType
 */
export enum SensorBoard_MeasurementType {
    /**
     * @generated from protobuf enum value: MEASUREMENT_TYPE_UNSPECIFIED = 0;
     */
    MEASUREMENT_TYPE_UNSPECIFIED = 0,
    /**
     * 气体电阻 (Ohm)
     *
     * @generated from protobuf enum value: GAS_RESISTANCE = 1;
     */
    GAS_RESISTANCE = 1,
    /**
     * 电压 (V) - 用于 PID 等
     *
     * @generated from protobuf enum value: VOLTAGE = 2;
     */
    VOLTAGE = 2,
    /**
     * 电流 (A) - 用于 EC 等
     *
     * @generated from protobuf enum value: CURRENT = 3;
     */
    CURRENT = 3,
    /**
     * 温度 (Celsius)
     *
     * @generated from protobuf enum value: TEMPERATURE = 4;
     */
    TEMPERATURE = 4,
    /**
     * 相对湿度 (%RH)
     *
     * @generated from protobuf enum value: HUMIDITY = 5;
     */
    HUMIDITY = 5,
    /**
     * 气压 (hPa)
     *
     * @generated from protobuf enum value: PRESSURE = 6;
     */
    PRESSURE = 6,
    /**
     * 气体指数 (无量纲)
     *
     * @generated from protobuf enum value: GAS_INDEX = 7;
     */
    GAS_INDEX = 7,
    /**
     * 浓度 (ppb/ppm)
     *
     * @generated from protobuf enum value: CONCENTRATION = 8;
     */
    CONCENTRATION = 8
}
/**
 * @generated from protobuf message enose.config.SensorBoardList
 */
export interface SensorBoardList {
    /**
     * @generated from protobuf field: repeated enose.config.SensorBoard boards = 1
     */
    boards: SensorBoard[];
}
/**
 * ============================================================
 * 板子通道配置实例 (BoardChannelConfig)
 * 指定每个通道使用的加热器和占空比配置
 * ============================================================
 *
 * @generated from protobuf message enose.config.BoardChannelConfig
 */
export interface BoardChannelConfig {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * @generated from protobuf field: string name = 2
     */
    name: string;
    /**
     * @generated from protobuf field: string description = 3
     */
    description: string;
    /**
     * 引用传感器板
     *
     * @generated from protobuf field: string board_id = 4
     */
    boardId: string;
    /**
     * 通道分配: 指定哪些通道使用哪个加热器/占空比
     *
     * @generated from protobuf field: repeated enose.config.BoardChannelConfig.ChannelAssignment assignments = 5
     */
    assignments: BoardChannelConfig_ChannelAssignment[];
}
/**
 * @generated from protobuf message enose.config.BoardChannelConfig.ChannelAssignment
 */
export interface BoardChannelConfig_ChannelAssignment {
    /**
     * 传感器ID列表 (对应 SensorBoard.sensors.id)
     *
     * @generated from protobuf field: repeated string sensor_ids = 1
     */
    sensorIds: string[];
    /**
     * 引用加热器配置 (可选，对于无需加热的传感器可为空)
     *
     * @generated from protobuf field: string heater_profile_id = 2
     */
    heaterProfileId: string;
}
/**
 * @generated from protobuf message enose.config.BoardChannelConfigList
 */
export interface BoardChannelConfigList {
    /**
     * @generated from protobuf field: repeated enose.config.BoardChannelConfig configs = 1
     */
    configs: BoardChannelConfig[];
}
/**
 * ============================================================
 * 终止条件 (TerminationCondition)
 * 用于采集和基线恢复等阶段
 * ============================================================
 *
 * @generated from protobuf message enose.config.TerminationCondition
 */
export interface TerminationCondition {
    /**
     * @generated from protobuf field: enose.config.TerminationCondition.TerminationType type = 1
     */
    type: TerminationCondition_TerminationType;
    /**
     * 固定时间参数
     *
     * @generated from protobuf field: int32 duration_s = 2
     */
    durationS: number;
    /**
     * 加热器循环次数参数
     *
     * @generated from protobuf field: int32 heater_cycles = 3
     */
    heaterCycles: number;
    /**
     * 基线/稳态跟踪参数
     *
     * @generated from protobuf field: enose.config.TerminationCondition.TrackingParams tracking = 4
     */
    tracking?: TerminationCondition_TrackingParams;
    /**
     * 最大等待时间 (防止无限等待)
     *
     * @generated from protobuf field: int32 max_duration_s = 5
     */
    maxDurationS: number;
    /**
     * 最小等待时间
     *
     * @generated from protobuf field: int32 min_duration_s = 6
     */
    minDurationS: number;
}
/**
 * @generated from protobuf message enose.config.TerminationCondition.TrackingParams
 */
export interface TerminationCondition_TrackingParams {
    /**
     * 稳定性窗口 (秒)
     *
     * @generated from protobuf field: int32 window_s = 1
     */
    windowS: number;
    /**
     * 稳定性阈值: 窗口内变化率 (%)
     *
     * @generated from protobuf field: double threshold_percent = 2
     */
    thresholdPercent: number;
    /**
     * 基线偏差容差 (%)
     *
     * @generated from protobuf field: double baseline_tolerance_percent = 3
     */
    baselineTolerancePercent: number;
}
/**
 * @generated from protobuf enum enose.config.TerminationCondition.TerminationType
 */
export enum TerminationCondition_TerminationType {
    /**
     * @generated from protobuf enum value: TERMINATION_TYPE_UNSPECIFIED = 0;
     */
    TERMINATION_TYPE_UNSPECIFIED = 0,
    /**
     * 固定时间
     *
     * @generated from protobuf enum value: FIXED_DURATION = 1;
     */
    FIXED_DURATION = 1,
    /**
     * 加热器循环次数
     *
     * @generated from protobuf enum value: HEATER_CYCLES = 2;
     */
    HEATER_CYCLES = 2,
    /**
     * 基线跟踪 (等待回到基线)
     *
     * @generated from protobuf enum value: BASELINE_TRACKING = 3;
     */
    BASELINE_TRACKING = 3,
    /**
     * 稳态跟踪 (等待信号稳定)
     *
     * @generated from protobuf enum value: STEADY_STATE = 4;
     */
    STEADY_STATE = 4,
    /**
     * 斜率阈值 (变化率低于阈值)
     *
     * @generated from protobuf enum value: SLOPE_THRESHOLD = 5;
     */
    SLOPE_THRESHOLD = 5
}
/**
 * ============================================================
 * 液体定义 (Liquid)
 * ============================================================
 *
 * @generated from protobuf message enose.config.Liquid
 */
export interface Liquid {
    /**
     * 液体唯一标识: 小写字母开头，只能包含小写字母、数字、下划线
     *
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * 液体名称: 1-128 字符
     *
     * @generated from protobuf field: string name = 2
     */
    name: string;
    /**
     * @generated from protobuf field: string description = 3
     */
    description: string; // 液体描述 (可选)    /**
     * 泵编号: 0=清洗泵, 1-7=样品泵
     *
     * @generated from protobuf field: int32 pump_index = 4
     */
    pumpIndex: number;
    /**
     * 液体类型: 必须指定
     *
     * @generated from protobuf field: enose.config.Liquid.LiquidType type = 5
     */
    type: Liquid_LiquidType;
    /**
     * 密度: 0.5 - 2.0 g/ml
     *
     * @generated from protobuf field: double density_g_ml = 6
     */
    densityGMl: number;
    /**
     * @generated from protobuf field: enose.config.Liquid.Viscosity viscosity = 7
     */
    viscosity: Liquid_Viscosity; // 粘度等级}
/**
 * @generated from protobuf enum enose.config.Liquid.LiquidType
 */
export enum Liquid_LiquidType {
    /**
     * @generated from protobuf enum value: LIQUID_TYPE_UNSPECIFIED = 0;
     */
    LIQUID_TYPE_UNSPECIFIED = 0,
    /**
     * 清洗液
     *
     * @generated from protobuf enum value: RINSE = 1;
     */
    RINSE = 1,
    /**
     * 样品液
     *
     * @generated from protobuf enum value: SAMPLE = 2;
     */
    SAMPLE = 2,
    /**
     * 标定液
     *
     * @generated from protobuf enum value: CALIBRATION = 3;
     */
    CALIBRATION = 3
}
/**
 * @generated from protobuf enum enose.config.Liquid.Viscosity
 */
export enum Liquid_Viscosity {
    /**
     * @generated from protobuf enum value: VISCOSITY_UNSPECIFIED = 0;
     */
    VISCOSITY_UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: LOW = 1;
     */
    LOW = 1,
    /**
     * @generated from protobuf enum value: MEDIUM = 2;
     */
    MEDIUM = 2,
    /**
     * @generated from protobuf enum value: HIGH = 3;
     */
    HIGH = 3
}
/**
 * @generated from protobuf message enose.config.LiquidList
 */
export interface LiquidList {
    /**
     * @generated from protobuf field: repeated enose.config.Liquid liquids = 1
     */
    liquids: Liquid[];
}
/**
 * ============================================================
 * 待测物定义 (Substance)
 * 待测物 = 不同配比的液体组合
 * ============================================================
 *
 * @generated from protobuf message enose.config.Substance
 */
export interface Substance {
    /**
     * 待测物唯一标识
     *
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * @generated from protobuf field: string name = 2
     */
    name: string;
    /**
     * @generated from protobuf field: string description = 3
     */
    description: string;
    /**
     * @generated from protobuf field: string category = 4
     */
    category: string; // 分类标签    /**
     * 配方组成: 至少包含一种液体
     *
     * @generated from protobuf field: repeated enose.config.Substance.Component components = 5
     */
    components: Substance_Component[];
    /**
     * @generated from protobuf oneof: default_amount
     */
    defaultAmount: {
        oneofKind: "totalVolumeMl";
        /**
         * 默认总体积: 1-100 ml
         *
         * @generated from protobuf field: double total_volume_ml = 6
         */
        totalVolumeMl: number;
    } | {
        oneofKind: "totalWeightG";
        /**
         * 默认总重量: 1-100 g
         *
         * @generated from protobuf field: double total_weight_g = 7
         */
        totalWeightG: number;
    } | {
        oneofKind: undefined;
    };
    /**
     * @generated from protobuf field: repeated string tags = 8
     */
    tags: string[];
}
/**
 * @generated from protobuf message enose.config.Substance.Component
 */
export interface Substance_Component {
    /**
     * 引用液体ID
     *
     * @generated from protobuf field: string liquid_id = 1
     */
    liquidId: string;
    /**
     * 体积比例: 0-1 之间
     *
     * @generated from protobuf field: double ratio = 2
     */
    ratio: number;
}
/**
 * @generated from protobuf message enose.config.SubstanceList
 */
export interface SubstanceList {
    /**
     * @generated from protobuf field: repeated enose.config.Substance substances = 1
     */
    substances: Substance[];
}
/**
 * ============================================================
 * 工作流定义 (Workflow)
 * Workflow = 不同时序配置的自动化流程
 * ============================================================
 *
 * @generated from protobuf message enose.config.Workflow
 */
export interface Workflow {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * @generated from protobuf field: string name = 2
     */
    name: string;
    /**
     * @generated from protobuf field: string description = 3
     */
    description: string;
    /**
     * 版本号: 语义化版本格式
     *
     * @generated from protobuf field: string version = 4
     */
    version: string;
    /**
     * 阶段配置: 必须指定
     *
     * @generated from protobuf field: enose.config.Workflow.PhaseConfig phases = 5
     */
    phases?: Workflow_PhaseConfig;
    /**
     * @generated from protobuf field: enose.config.Workflow.GlobalParams global = 6
     */
    global?: Workflow_GlobalParams; // 全局参数}
/**
 * 阶段配置
 *
 * @generated from protobuf message enose.config.Workflow.PhaseConfig
 */
export interface Workflow_PhaseConfig {
    /**
     * @generated from protobuf field: enose.config.Workflow.DoseConfig dose = 1
     */
    dose?: Workflow_DoseConfig;
    /**
     * @generated from protobuf field: enose.config.Workflow.EquilibrateConfig equilibrate = 2
     */
    equilibrate?: Workflow_EquilibrateConfig;
    /**
     * @generated from protobuf field: enose.config.Workflow.AcquireConfig acquire = 3
     */
    acquire?: Workflow_AcquireConfig;
    /**
     * @generated from protobuf field: enose.config.Workflow.CleanupConfig cleanup = 4
     */
    cleanup?: Workflow_CleanupConfig;
    /**
     * @generated from protobuf field: enose.config.Workflow.BaselineRecoveryConfig baseline_recovery = 5
     */
    baselineRecovery?: Workflow_BaselineRecoveryConfig;
}
/**
 * 进样阶段配置
 *
 * @generated from protobuf message enose.config.Workflow.DoseConfig
 */
export interface Workflow_DoseConfig {
    /**
     * 最大进样时间: 10-300 秒
     *
     * @generated from protobuf field: int32 max_duration_s = 1
     */
    maxDurationS: number;
    /**
     * 流速: 0.5-20 ml/min
     *
     * @generated from protobuf field: double flow_rate_ml_min = 2
     */
    flowRateMlMin: number;
    /**
     * 称重容差: 0.1-5 g
     *
     * @generated from protobuf field: double weight_tolerance_g = 3
     */
    weightToleranceG: number;
    /**
     * @generated from protobuf field: enose.config.Workflow.DoseConfig.ControlMode control_mode = 4
     */
    controlMode: Workflow_DoseConfig_ControlMode; // 控制模式}
/**
 * @generated from protobuf enum enose.config.Workflow.DoseConfig.ControlMode
 */
export enum Workflow_DoseConfig_ControlMode {
    /**
     * @generated from protobuf enum value: CONTROL_MODE_UNSPECIFIED = 0;
     */
    CONTROL_MODE_UNSPECIFIED = 0,
    /**
     * 称重闭环
     *
     * @generated from protobuf enum value: WEIGHT_FEEDBACK = 1;
     */
    WEIGHT_FEEDBACK = 1,
    /**
     * 时间控制
     *
     * @generated from protobuf enum value: TIME_BASED = 2;
     */
    TIME_BASED = 2,
    /**
     * 体积控制
     *
     * @generated from protobuf enum value: VOLUME_BASED = 3;
     */
    VOLUME_BASED = 3
}
/**
 * 平衡/混合阶段配置
 * 通过进气鼓泡让液体均匀混合，此时三通阀连通环境而非传感器
 *
 * @generated from protobuf message enose.config.Workflow.EquilibrateConfig
 */
export interface Workflow_EquilibrateConfig {
    /**
     * 混合时间: 5-300 秒
     *
     * @generated from protobuf field: int32 duration_s = 1
     */
    durationS: number;
    /**
     * 气泵 PWM: 0-100% (用于鼓泡混合)
     *
     * @generated from protobuf field: int32 gas_pump_pwm_percent = 2
     */
    gasPumpPwmPercent: number;
    /**
     * 三通阀设置: true=连通环境, false=连通传感器
     *
     * @generated from protobuf field: bool vent_to_ambient = 3
     */
    ventToAmbient: boolean;
}
/**
 * 采集阶段配置
 * 支持多种终止条件: 固定时间/加热器循环/基线跟踪/稳态跟踪
 *
 * @generated from protobuf message enose.config.Workflow.AcquireConfig
 */
export interface Workflow_AcquireConfig {
    /**
     * 终止条件
     *
     * @generated from protobuf field: enose.config.TerminationCondition termination = 1
     */
    termination?: TerminationCondition;
    /**
     * 气泵 PWM: 0-100%
     *
     * @generated from protobuf field: int32 gas_pump_pwm_percent = 2
     */
    gasPumpPwmPercent: number;
}
/**
 * 清洗阶段配置
 *
 * @generated from protobuf message enose.config.Workflow.CleanupConfig
 */
export interface Workflow_CleanupConfig {
    /**
     * 清洗循环次数: 1-10
     *
     * @generated from protobuf field: int32 cycles = 1
     */
    cycles: number;
    /**
     * 每次清洗液体积: 5-50 ml
     *
     * @generated from protobuf field: double rinse_volume_ml = 2
     */
    rinseVolumeMl: number;
    /**
     * 每次排废时间: 5-60 秒
     *
     * @generated from protobuf field: int32 drain_duration_s = 3
     */
    drainDurationS: number;
}
/**
 * 基线恢复配置
 * 空瓶进气恢复基线，支持多种终止条件
 *
 * @generated from protobuf message enose.config.Workflow.BaselineRecoveryConfig
 */
export interface Workflow_BaselineRecoveryConfig {
    /**
     * 终止条件
     *
     * @generated from protobuf field: enose.config.TerminationCondition termination = 1
     */
    termination?: TerminationCondition;
    /**
     * 气泵 PWM: 0-100%
     *
     * @generated from protobuf field: int32 gas_pump_pwm_percent = 2
     */
    gasPumpPwmPercent: number;
}
/**
 * 全局参数
 *
 * @generated from protobuf message enose.config.Workflow.GlobalParams
 */
export interface Workflow_GlobalParams {
    /**
     * 引用板子通道配置 (包含加热器设置)
     *
     * @generated from protobuf field: string board_channel_config_id = 1
     */
    boardChannelConfigId: string;
    /**
     * 预热温度: 30-80°C
     *
     * @generated from protobuf field: double heater_preheat_temp_c = 2
     */
    heaterPreheatTempC: number;
    /**
     * 默认气流: 20-200 ml/min
     *
     * @generated from protobuf field: double gas_flow_default_ml_min = 3
     */
    gasFlowDefaultMlMin: number;
}
/**
 * @generated from protobuf message enose.config.WorkflowList
 */
export interface WorkflowList {
    /**
     * @generated from protobuf field: repeated enose.config.Workflow workflows = 1
     */
    workflows: Workflow[];
}
/**
 * ============================================================
 * 实验定义 (Experiment)
 * Experiment = Workflow + Substance 的组合
 * ============================================================
 *
 * @generated from protobuf message enose.config.Experiment
 */
export interface Experiment {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * @generated from protobuf field: string name = 2
     */
    name: string;
    /**
     * @generated from protobuf field: string description = 3
     */
    description: string;
    /**
     * 引用工作流ID: 必须指定
     *
     * @generated from protobuf field: string workflow_id = 4
     */
    workflowId: string;
    /**
     * 引用待测物ID: 必须指定
     *
     * @generated from protobuf field: string substance_id = 5
     */
    substanceId: string;
    /**
     * @generated from protobuf field: enose.config.Experiment.Overrides overrides = 6
     */
    overrides?: Experiment_Overrides; // 参数覆盖    /**
     * @generated from protobuf field: enose.config.Experiment.Metadata metadata = 7
     */
    metadata?: Experiment_Metadata; // 元数据}
/**
 * 参数覆盖
 *
 * @generated from protobuf message enose.config.Experiment.Overrides
 */
export interface Experiment_Overrides {
    /**
     * @generated from protobuf field: optional double total_volume_ml = 1
     */
    totalVolumeMl?: number;
    /**
     * @generated from protobuf field: optional double total_weight_g = 2
     */
    totalWeightG?: number;
    /**
     * 覆盖板子通道配置
     *
     * @generated from protobuf field: optional string board_channel_config_id = 3
     */
    boardChannelConfigId?: string;
}
/**
 * 元数据
 *
 * @generated from protobuf message enose.config.Experiment.Metadata
 */
export interface Experiment_Metadata {
    /**
     * @generated from protobuf field: string author = 1
     */
    author: string;
    /**
     * @generated from protobuf field: string created_at = 2
     */
    createdAt: string; // ISO 8601 格式    /**
     * @generated from protobuf field: repeated string tags = 3
     */
    tags: string[];
}
/**
 * @generated from protobuf message enose.config.ExperimentList
 */
export interface ExperimentList {
    /**
     * @generated from protobuf field: repeated enose.config.Experiment experiments = 1
     */
    experiments: Experiment[];
}
/**
 * ============================================================
 * 样本定义 (Sample)
 * Sample = 实验的一次执行记录
 * ============================================================
 *
 * @generated from protobuf message enose.config.Sample
 */
export interface Sample {
    /**
     * UUID 格式
     *
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * 引用实验ID: 必须指定
     *
     * @generated from protobuf field: string experiment_id = 2
     */
    experimentId: string;
    /**
     * 重复次数: >= 1
     *
     * @generated from protobuf field: int32 run_index = 3
     */
    runIndex: number;
    /**
     * @generated from protobuf field: enose.config.Sample.Runtime runtime = 4
     */
    runtime?: Sample_Runtime; // 运行时数据    /**
     * @generated from protobuf field: enose.config.Sample.DataFiles data_files = 5
     */
    dataFiles?: Sample_DataFiles; // 数据文件引用    /**
     * @generated from protobuf field: enose.config.Sample.Quality quality = 6
     */
    quality?: Sample_Quality; // 质检结果}
/**
 * 运行时数据
 *
 * @generated from protobuf message enose.config.Sample.Runtime
 */
export interface Sample_Runtime {
    /**
     * @generated from protobuf field: string started_at = 1
     */
    startedAt: string; // ISO 8601    /**
     * @generated from protobuf field: string finished_at = 2
     */
    finishedAt: string; // ISO 8601    /**
     * @generated from protobuf field: enose.config.Sample.SampleStatus status = 3
     */
    status: Sample_SampleStatus;
    /**
     * @generated from protobuf field: double actual_weight_g = 4
     */
    actualWeightG: number;
    /**
     * @generated from protobuf field: double actual_volume_ml = 5
     */
    actualVolumeMl: number;
}
/**
 * 数据文件引用
 *
 * @generated from protobuf message enose.config.Sample.DataFiles
 */
export interface Sample_DataFiles {
    /**
     * @generated from protobuf field: string sensor_data = 1
     */
    sensorData: string; // 传感器数据文件路径    /**
     * @generated from protobuf field: string log_file = 2
     */
    logFile: string; // 日志文件路径}
/**
 * 质检结果
 *
 * @generated from protobuf message enose.config.Sample.Quality
 */
export interface Sample_Quality {
    /**
     * @generated from protobuf field: bool passed = 1
     */
    passed: boolean;
    /**
     * @generated from protobuf field: repeated string flags = 2
     */
    flags: string[];
    /**
     * @generated from protobuf field: string notes = 3
     */
    notes: string;
}
/**
 * @generated from protobuf enum enose.config.Sample.SampleStatus
 */
export enum Sample_SampleStatus {
    /**
     * @generated from protobuf enum value: SAMPLE_STATUS_UNSPECIFIED = 0;
     */
    SAMPLE_STATUS_UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: PENDING = 1;
     */
    PENDING = 1,
    /**
     * @generated from protobuf enum value: RUNNING = 2;
     */
    RUNNING = 2,
    /**
     * @generated from protobuf enum value: COMPLETED = 3;
     */
    COMPLETED = 3,
    /**
     * @generated from protobuf enum value: FAILED = 4;
     */
    FAILED = 4,
    /**
     * @generated from protobuf enum value: ABORTED = 5;
     */
    ABORTED = 5
}
/**
 * @generated from protobuf message enose.config.SampleList
 */
export interface SampleList {
    /**
     * @generated from protobuf field: repeated enose.config.Sample samples = 1
     */
    samples: Sample[];
}
// @generated message type with reflection information, may provide speed optimized methods
class HeaterProfile$Type extends MessageType<HeaterProfile> {
    constructor() {
        super("enose.config.HeaterProfile", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "buf.validate.field": { string: { minLen: "1", maxLen: "64", pattern: "^[a-z][a-z0-9_]*$" } } } },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "buf.validate.field": { string: { minLen: "1", maxLen: "128" } } } },
            { no: 3, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "time_base_ms", kind: "scalar", T: 5 /*ScalarType.INT32*/, options: { "buf.validate.field": { int32: { lte: 1000, gte: 1 } } } },
            { no: 5, name: "steps", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => HeaterProfile_HeaterStep, options: { "buf.validate.field": { repeated: { minItems: "1", maxItems: "10" } } } }
        ]);
    }
    create(value?: PartialMessage<HeaterProfile>): HeaterProfile {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.name = "";
        message.description = "";
        message.timeBaseMs = 0;
        message.steps = [];
        if (value !== undefined)
            reflectionMergePartial<HeaterProfile>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HeaterProfile): HeaterProfile {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* string description */ 3:
                    message.description = reader.string();
                    break;
                case /* int32 time_base_ms */ 4:
                    message.timeBaseMs = reader.int32();
                    break;
                case /* repeated enose.config.HeaterProfile.HeaterStep steps */ 5:
                    message.steps.push(HeaterProfile_HeaterStep.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HeaterProfile, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* string description = 3; */
        if (message.description !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.description);
        /* int32 time_base_ms = 4; */
        if (message.timeBaseMs !== 0)
            writer.tag(4, WireType.Varint).int32(message.timeBaseMs);
        /* repeated enose.config.HeaterProfile.HeaterStep steps = 5; */
        for (let i = 0; i < message.steps.length; i++)
            HeaterProfile_HeaterStep.internalBinaryWrite(message.steps[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.config.HeaterProfile
 */
export const HeaterProfile = new HeaterProfile$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HeaterProfile_HeaterStep$Type extends MessageType<HeaterProfile_HeaterStep> {
    constructor() {
        super("enose.config.HeaterProfile.HeaterStep", [
            { no: 1, name: "temp_c", kind: "scalar", T: 5 /*ScalarType.INT32*/, options: { "buf.validate.field": { int32: { lte: 400, gte: 100 } } } },
            { no: 2, name: "duration_mult", kind: "scalar", T: 5 /*ScalarType.INT32*/, options: { "buf.validate.field": { int32: { lte: 1000, gte: 1 } } } }
        ]);
    }
    create(value?: PartialMessage<HeaterProfile_HeaterStep>): HeaterProfile_HeaterStep {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tempC = 0;
        message.durationMult = 0;
        if (value !== undefined)
            reflectionMergePartial<HeaterProfile_HeaterStep>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HeaterProfile_HeaterStep): HeaterProfile_HeaterStep {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 temp_c */ 1:
                    message.tempC = reader.int32();
                    break;
                case /* int32 duration_mult */ 2:
                    message.durationMult = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HeaterProfile_HeaterStep, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 temp_c = 1; */
        if (message.tempC !== 0)
            writer.tag(1, WireType.Varint).int32(message.tempC);
        /* int32 duration_mult = 2; */
        if (message.durationMult !== 0)
            writer.tag(2, WireType.Varint).int32(message.durationMult);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.config.HeaterProfile.HeaterStep
 */
export const HeaterProfile_HeaterStep = new HeaterProfile_HeaterStep$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HeaterProfileList$Type extends MessageType<HeaterProfileList> {
    constructor() {
        super("enose.config.HeaterProfileList", [
            { no: 1, name: "heaters", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => HeaterProfile }
        ]);
    }
    create(value?: PartialMessage<HeaterProfileList>): HeaterProfileList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.heaters = [];
        if (value !== undefined)
            reflectionMergePartial<HeaterProfileList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HeaterProfileList): HeaterProfileList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated enose.config.HeaterProfile heaters */ 1:
                    message.heaters.push(HeaterProfile.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HeaterProfileList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated enose.config.HeaterProfile heaters = 1; */
        for (let i = 0; i < message.heaters.length; i++)
            HeaterProfile.internalBinaryWrite(message.heaters[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.config.HeaterProfileList
 */
export const HeaterProfileList = new HeaterProfileList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SensorBoard$Type extends MessageType<SensorBoard> {
    constructor() {
        super("enose.config.SensorBoard", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "buf.validate.field": { string: { minLen: "1", maxLen: "64", pattern: "^[a-z][a-z0-9_-]*$" } } } },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "buf.validate.field": { string: { minLen: "1" } } } },
            { no: 3, name: "vendor", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "firmware_version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "board_type", kind: "enum", T: () => ["enose.config.SensorBoard.BoardType", SensorBoard_BoardType] },
            { no: 7, name: "communication", kind: "message", T: () => SensorBoard_CommunicationConfig },
            { no: 8, name: "sensors", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => SensorBoard_SensorDefinition },
            { no: 9, name: "sampling", kind: "message", T: () => SensorBoard_SamplingConfig },
            { no: 10, name: "timestamp", kind: "message", T: () => SensorBoard_TimestampConfig }
        ]);
    }
    create(value?: PartialMessage<SensorBoard>): SensorBoard {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.name = "";
        message.vendor = "";
        message.firmwareVersion = "";
        message.description = "";
        message.boardType = 0;
        message.sensors = [];
        if (value !== undefined)
            reflectionMergePartial<SensorBoard>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SensorBoard): SensorBoard {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* string vendor */ 3:
                    message.vendor = reader.string();
                    break;
                case /* string firmware_version */ 4:
                    message.firmwareVersion = reader.string();
                    break;
                case /* string description */ 5:
                    message.description = reader.string();
                    break;
                case /* enose.config.SensorBoard.BoardType board_type */ 6:
                    message.boardType = reader.int32();
                    break;
                case /* enose.config.SensorBoard.CommunicationConfig communication */ 7:
                    message.communication = SensorBoard_CommunicationConfig.internalBinaryRead(reader, reader.uint32(), options, message.communication);
                    break;
                case /* repeated enose.config.SensorBoard.SensorDefinition sensors */ 8:
                    message.sensors.push(SensorBoard_SensorDefinition.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* enose.config.SensorBoard.SamplingConfig sampling */ 9:
                    message.sampling = SensorBoard_SamplingConfig.internalBinaryRead(reader, reader.uint32(), options, message.sampling);
                    break;
                case /* enose.config.SensorBoard.TimestampConfig timestamp */ 10:
                    message.timestamp = SensorBoard_TimestampConfig.internalBinaryRead(reader, reader.uint32(), options, message.timestamp);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SensorBoard, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* string vendor = 3; */
        if (message.vendor !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.vendor);
        /* string firmware_version = 4; */
        if (message.firmwareVersion !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.firmwareVersion);
        /* string description = 5; */
        if (message.description !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.description);
        /* enose.config.SensorBoard.BoardType board_type = 6; */
        if (message.boardType !== 0)
            writer.tag(6, WireType.Varint).int32(message.boardType);
        /* enose.config.SensorBoard.CommunicationConfig communication = 7; */
        if (message.communication)
            SensorBoard_CommunicationConfig.internalBinaryWrite(message.communication, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* repeated enose.config.SensorBoard.SensorDefinition sensors = 8; */
        for (let i = 0; i < message.sensors.length; i++)
            SensorBoard_SensorDefinition.internalBinaryWrite(message.sensors[i], writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* enose.config.SensorBoard.SamplingConfig sampling = 9; */
        if (message.sampling)
            SensorBoard_SamplingConfig.internalBinaryWrite(message.sampling, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* enose.config.SensorBoard.TimestampConfig timestamp = 10; */
        if (message.timestamp)
            SensorBoard_TimestampConfig.internalBinaryWrite(message.timestamp, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.config.SensorBoard
 */
export const SensorBoard = new SensorBoard$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SensorBoard_CommunicationConfig$Type extends MessageType<SensorBoard_CommunicationConfig> {
    constructor() {
        super("enose.config.SensorBoard.CommunicationConfig", [
            { no: 1, name: "protocol", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "baudrate", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "data_format", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "timeout_ms", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<SensorBoard_CommunicationConfig>): SensorBoard_CommunicationConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.protocol = "";
        message.baudrate = 0;
        message.dataFormat = "";
        message.timeoutMs = 0;
        if (value !== undefined)
            reflectionMergePartial<SensorBoard_CommunicationConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SensorBoard_CommunicationConfig): SensorBoard_CommunicationConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string protocol */ 1:
                    message.protocol = reader.string();
                    break;
                case /* int32 baudrate */ 2:
                    message.baudrate = reader.int32();
                    break;
                case /* string data_format */ 3:
                    message.dataFormat = reader.string();
                    break;
                case /* int32 timeout_ms */ 4:
                    message.timeoutMs = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SensorBoard_CommunicationConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string protocol = 1; */
        if (message.protocol !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.protocol);
        /* int32 baudrate = 2; */
        if (message.baudrate !== 0)
            writer.tag(2, WireType.Varint).int32(message.baudrate);
        /* string data_format = 3; */
        if (message.dataFormat !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.dataFormat);
        /* int32 timeout_ms = 4; */
        if (message.timeoutMs !== 0)
            writer.tag(4, WireType.Varint).int32(message.timeoutMs);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.config.SensorBoard.CommunicationConfig
 */
export const SensorBoard_CommunicationConfig = new SensorBoard_CommunicationConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SensorBoard_SensorDefinition$Type extends MessageType<SensorBoard_SensorDefinition> {
    constructor() {
        super("enose.config.SensorBoard.SensorDefinition", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "buf.validate.field": { string: { minLen: "1", maxLen: "32", pattern: "^[a-z0-9_]+$" } } } },
            { no: 2, name: "model", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "capabilities", kind: "enum", repeat: 1 /*RepeatType.PACKED*/, T: () => ["enose.config.SensorBoard.MeasurementType", SensorBoard_MeasurementType] },
            { no: 5, name: "metadata", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } }
        ]);
    }
    create(value?: PartialMessage<SensorBoard_SensorDefinition>): SensorBoard_SensorDefinition {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.model = "";
        message.type = "";
        message.capabilities = [];
        message.metadata = {};
        if (value !== undefined)
            reflectionMergePartial<SensorBoard_SensorDefinition>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SensorBoard_SensorDefinition): SensorBoard_SensorDefinition {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string model */ 2:
                    message.model = reader.string();
                    break;
                case /* string type */ 3:
                    message.type = reader.string();
                    break;
                case /* repeated enose.config.SensorBoard.MeasurementType capabilities */ 4:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.capabilities.push(reader.int32());
                    else
                        message.capabilities.push(reader.int32());
                    break;
                case /* map<string, string> metadata */ 5:
                    this.binaryReadMap5(message.metadata, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap5(map: SensorBoard_SensorDefinition["metadata"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof SensorBoard_SensorDefinition["metadata"] | undefined, val: SensorBoard_SensorDefinition["metadata"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for enose.config.SensorBoard.SensorDefinition.metadata");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: SensorBoard_SensorDefinition, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string model = 2; */
        if (message.model !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.model);
        /* string type = 3; */
        if (message.type !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.type);
        /* repeated enose.config.SensorBoard.MeasurementType capabilities = 4; */
        if (message.capabilities.length) {
            writer.tag(4, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.capabilities.length; i++)
                writer.int32(message.capabilities[i]);
            writer.join();
        }
        /* map<string, string> metadata = 5; */
        for (let k of globalThis.Object.keys(message.metadata))
            writer.tag(5, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.metadata[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.config.SensorBoard.SensorDefinition
 */
export const SensorBoard_SensorDefinition = new SensorBoard_SensorDefinition$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SensorBoard_SamplingConfig$Type extends MessageType<SensorBoard_SamplingConfig> {
    constructor() {
        super("enose.config.SensorBoard.SamplingConfig", [
            { no: 1, name: "mode", kind: "enum", T: () => ["enose.config.SensorBoard.SamplingConfig.SamplingMode", SensorBoard_SamplingConfig_SamplingMode] },
            { no: 2, name: "base_rate_hz", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/, options: { "buf.validate.field": { double: { gt: 0 } } } },
            { no: 3, name: "heater_steps", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "cycle_duration_ms", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<SensorBoard_SamplingConfig>): SensorBoard_SamplingConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.mode = 0;
        message.baseRateHz = 0;
        message.heaterSteps = 0;
        message.cycleDurationMs = 0;
        if (value !== undefined)
            reflectionMergePartial<SensorBoard_SamplingConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SensorBoard_SamplingConfig): SensorBoard_SamplingConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* enose.config.SensorBoard.SamplingConfig.SamplingMode mode */ 1:
                    message.mode = reader.int32();
                    break;
                case /* double base_rate_hz */ 2:
                    message.baseRateHz = reader.double();
                    break;
                case /* int32 heater_steps */ 3:
                    message.heaterSteps = reader.int32();
                    break;
                case /* int32 cycle_duration_ms */ 4:
                    message.cycleDurationMs = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SensorBoard_SamplingConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* enose.config.SensorBoard.SamplingConfig.SamplingMode mode = 1; */
        if (message.mode !== 0)
            writer.tag(1, WireType.Varint).int32(message.mode);
        /* double base_rate_hz = 2; */
        if (message.baseRateHz !== 0)
            writer.tag(2, WireType.Bit64).double(message.baseRateHz);
        /* int32 heater_steps = 3; */
        if (message.heaterSteps !== 0)
            writer.tag(3, WireType.Varint).int32(message.heaterSteps);
        /* int32 cycle_duration_ms = 4; */
        if (message.cycleDurationMs !== 0)
            writer.tag(4, WireType.Varint).int32(message.cycleDurationMs);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.config.SensorBoard.SamplingConfig
 */
export const SensorBoard_SamplingConfig = new SensorBoard_SamplingConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SensorBoard_TimestampConfig$Type extends MessageType<SensorBoard_TimestampConfig> {
    constructor() {
        super("enose.config.SensorBoard.TimestampConfig", [
            { no: 1, name: "sync_method", kind: "enum", T: () => ["enose.config.SensorBoard.TimestampConfig.SyncMethod", SensorBoard_TimestampConfig_SyncMethod] },
            { no: 2, name: "resolution_us", kind: "scalar", T: 5 /*ScalarType.INT32*/, options: { "buf.validate.field": { int32: { gt: 0 } } } },
            { no: 3, name: "max_drift_ms", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<SensorBoard_TimestampConfig>): SensorBoard_TimestampConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.syncMethod = 0;
        message.resolutionUs = 0;
        message.maxDriftMs = 0;
        if (value !== undefined)
            reflectionMergePartial<SensorBoard_TimestampConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SensorBoard_TimestampConfig): SensorBoard_TimestampConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* enose.config.SensorBoard.TimestampConfig.SyncMethod sync_method */ 1:
                    message.syncMethod = reader.int32();
                    break;
                case /* int32 resolution_us */ 2:
                    message.resolutionUs = reader.int32();
                    break;
                case /* int32 max_drift_ms */ 3:
                    message.maxDriftMs = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SensorBoard_TimestampConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* enose.config.SensorBoard.TimestampConfig.SyncMethod sync_method = 1; */
        if (message.syncMethod !== 0)
            writer.tag(1, WireType.Varint).int32(message.syncMethod);
        /* int32 resolution_us = 2; */
        if (message.resolutionUs !== 0)
            writer.tag(2, WireType.Varint).int32(message.resolutionUs);
        /* int32 max_drift_ms = 3; */
        if (message.maxDriftMs !== 0)
            writer.tag(3, WireType.Varint).int32(message.maxDriftMs);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.config.SensorBoard.TimestampConfig
 */
export const SensorBoard_TimestampConfig = new SensorBoard_TimestampConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SensorBoardList$Type extends MessageType<SensorBoardList> {
    constructor() {
        super("enose.config.SensorBoardList", [
            { no: 1, name: "boards", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => SensorBoard }
        ]);
    }
    create(value?: PartialMessage<SensorBoardList>): SensorBoardList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.boards = [];
        if (value !== undefined)
            reflectionMergePartial<SensorBoardList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SensorBoardList): SensorBoardList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated enose.config.SensorBoard boards */ 1:
                    message.boards.push(SensorBoard.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SensorBoardList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated enose.config.SensorBoard boards = 1; */
        for (let i = 0; i < message.boards.length; i++)
            SensorBoard.internalBinaryWrite(message.boards[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.config.SensorBoardList
 */
export const SensorBoardList = new SensorBoardList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BoardChannelConfig$Type extends MessageType<BoardChannelConfig> {
    constructor() {
        super("enose.config.BoardChannelConfig", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "buf.validate.field": { string: { minLen: "1", maxLen: "64", pattern: "^[a-z][a-z0-9_]*$" } } } },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "board_id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "buf.validate.field": { string: { minLen: "1" } } } },
            { no: 5, name: "assignments", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => BoardChannelConfig_ChannelAssignment }
        ]);
    }
    create(value?: PartialMessage<BoardChannelConfig>): BoardChannelConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.name = "";
        message.description = "";
        message.boardId = "";
        message.assignments = [];
        if (value !== undefined)
            reflectionMergePartial<BoardChannelConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BoardChannelConfig): BoardChannelConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* string description */ 3:
                    message.description = reader.string();
                    break;
                case /* string board_id */ 4:
                    message.boardId = reader.string();
                    break;
                case /* repeated enose.config.BoardChannelConfig.ChannelAssignment assignments */ 5:
                    message.assignments.push(BoardChannelConfig_ChannelAssignment.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BoardChannelConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* string description = 3; */
        if (message.description !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.description);
        /* string board_id = 4; */
        if (message.boardId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.boardId);
        /* repeated enose.config.BoardChannelConfig.ChannelAssignment assignments = 5; */
        for (let i = 0; i < message.assignments.length; i++)
            BoardChannelConfig_ChannelAssignment.internalBinaryWrite(message.assignments[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.config.BoardChannelConfig
 */
export const BoardChannelConfig = new BoardChannelConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BoardChannelConfig_ChannelAssignment$Type extends MessageType<BoardChannelConfig_ChannelAssignment> {
    constructor() {
        super("enose.config.BoardChannelConfig.ChannelAssignment", [
            { no: 1, name: "sensor_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "buf.validate.field": { repeated: { minItems: "1", maxItems: "64" } } } },
            { no: 2, name: "heater_profile_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<BoardChannelConfig_ChannelAssignment>): BoardChannelConfig_ChannelAssignment {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sensorIds = [];
        message.heaterProfileId = "";
        if (value !== undefined)
            reflectionMergePartial<BoardChannelConfig_ChannelAssignment>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BoardChannelConfig_ChannelAssignment): BoardChannelConfig_ChannelAssignment {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string sensor_ids */ 1:
                    message.sensorIds.push(reader.string());
                    break;
                case /* string heater_profile_id */ 2:
                    message.heaterProfileId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BoardChannelConfig_ChannelAssignment, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string sensor_ids = 1; */
        for (let i = 0; i < message.sensorIds.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.sensorIds[i]);
        /* string heater_profile_id = 2; */
        if (message.heaterProfileId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.heaterProfileId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.config.BoardChannelConfig.ChannelAssignment
 */
export const BoardChannelConfig_ChannelAssignment = new BoardChannelConfig_ChannelAssignment$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BoardChannelConfigList$Type extends MessageType<BoardChannelConfigList> {
    constructor() {
        super("enose.config.BoardChannelConfigList", [
            { no: 1, name: "configs", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => BoardChannelConfig }
        ]);
    }
    create(value?: PartialMessage<BoardChannelConfigList>): BoardChannelConfigList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.configs = [];
        if (value !== undefined)
            reflectionMergePartial<BoardChannelConfigList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BoardChannelConfigList): BoardChannelConfigList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated enose.config.BoardChannelConfig configs */ 1:
                    message.configs.push(BoardChannelConfig.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BoardChannelConfigList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated enose.config.BoardChannelConfig configs = 1; */
        for (let i = 0; i < message.configs.length; i++)
            BoardChannelConfig.internalBinaryWrite(message.configs[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.config.BoardChannelConfigList
 */
export const BoardChannelConfigList = new BoardChannelConfigList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TerminationCondition$Type extends MessageType<TerminationCondition> {
    constructor() {
        super("enose.config.TerminationCondition", [
            { no: 1, name: "type", kind: "enum", T: () => ["enose.config.TerminationCondition.TerminationType", TerminationCondition_TerminationType] },
            { no: 2, name: "duration_s", kind: "scalar", T: 5 /*ScalarType.INT32*/, options: { "buf.validate.field": { int32: { lte: 3600, gte: 1 } } } },
            { no: 3, name: "heater_cycles", kind: "scalar", T: 5 /*ScalarType.INT32*/, options: { "buf.validate.field": { int32: { lte: 100, gte: 1 } } } },
            { no: 4, name: "tracking", kind: "message", T: () => TerminationCondition_TrackingParams },
            { no: 5, name: "max_duration_s", kind: "scalar", T: 5 /*ScalarType.INT32*/, options: { "buf.validate.field": { int32: { lte: 3600, gte: 10 } } } },
            { no: 6, name: "min_duration_s", kind: "scalar", T: 5 /*ScalarType.INT32*/, options: { "buf.validate.field": { int32: { gte: 0 } } } }
        ]);
    }
    create(value?: PartialMessage<TerminationCondition>): TerminationCondition {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = 0;
        message.durationS = 0;
        message.heaterCycles = 0;
        message.maxDurationS = 0;
        message.minDurationS = 0;
        if (value !== undefined)
            reflectionMergePartial<TerminationCondition>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TerminationCondition): TerminationCondition {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* enose.config.TerminationCondition.TerminationType type */ 1:
                    message.type = reader.int32();
                    break;
                case /* int32 duration_s */ 2:
                    message.durationS = reader.int32();
                    break;
                case /* int32 heater_cycles */ 3:
                    message.heaterCycles = reader.int32();
                    break;
                case /* enose.config.TerminationCondition.TrackingParams tracking */ 4:
                    message.tracking = TerminationCondition_TrackingParams.internalBinaryRead(reader, reader.uint32(), options, message.tracking);
                    break;
                case /* int32 max_duration_s */ 5:
                    message.maxDurationS = reader.int32();
                    break;
                case /* int32 min_duration_s */ 6:
                    message.minDurationS = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TerminationCondition, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* enose.config.TerminationCondition.TerminationType type = 1; */
        if (message.type !== 0)
            writer.tag(1, WireType.Varint).int32(message.type);
        /* int32 duration_s = 2; */
        if (message.durationS !== 0)
            writer.tag(2, WireType.Varint).int32(message.durationS);
        /* int32 heater_cycles = 3; */
        if (message.heaterCycles !== 0)
            writer.tag(3, WireType.Varint).int32(message.heaterCycles);
        /* enose.config.TerminationCondition.TrackingParams tracking = 4; */
        if (message.tracking)
            TerminationCondition_TrackingParams.internalBinaryWrite(message.tracking, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* int32 max_duration_s = 5; */
        if (message.maxDurationS !== 0)
            writer.tag(5, WireType.Varint).int32(message.maxDurationS);
        /* int32 min_duration_s = 6; */
        if (message.minDurationS !== 0)
            writer.tag(6, WireType.Varint).int32(message.minDurationS);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.config.TerminationCondition
 */
export const TerminationCondition = new TerminationCondition$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TerminationCondition_TrackingParams$Type extends MessageType<TerminationCondition_TrackingParams> {
    constructor() {
        super("enose.config.TerminationCondition.TrackingParams", [
            { no: 1, name: "window_s", kind: "scalar", T: 5 /*ScalarType.INT32*/, options: { "buf.validate.field": { int32: { lte: 300, gte: 5 } } } },
            { no: 2, name: "threshold_percent", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/, options: { "buf.validate.field": { double: { lte: 10, gt: 0 } } } },
            { no: 3, name: "baseline_tolerance_percent", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/, options: { "buf.validate.field": { double: { lte: 20, gt: 0 } } } }
        ]);
    }
    create(value?: PartialMessage<TerminationCondition_TrackingParams>): TerminationCondition_TrackingParams {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.windowS = 0;
        message.thresholdPercent = 0;
        message.baselineTolerancePercent = 0;
        if (value !== undefined)
            reflectionMergePartial<TerminationCondition_TrackingParams>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TerminationCondition_TrackingParams): TerminationCondition_TrackingParams {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 window_s */ 1:
                    message.windowS = reader.int32();
                    break;
                case /* double threshold_percent */ 2:
                    message.thresholdPercent = reader.double();
                    break;
                case /* double baseline_tolerance_percent */ 3:
                    message.baselineTolerancePercent = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TerminationCondition_TrackingParams, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 window_s = 1; */
        if (message.windowS !== 0)
            writer.tag(1, WireType.Varint).int32(message.windowS);
        /* double threshold_percent = 2; */
        if (message.thresholdPercent !== 0)
            writer.tag(2, WireType.Bit64).double(message.thresholdPercent);
        /* double baseline_tolerance_percent = 3; */
        if (message.baselineTolerancePercent !== 0)
            writer.tag(3, WireType.Bit64).double(message.baselineTolerancePercent);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.config.TerminationCondition.TrackingParams
 */
export const TerminationCondition_TrackingParams = new TerminationCondition_TrackingParams$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Liquid$Type extends MessageType<Liquid> {
    constructor() {
        super("enose.config.Liquid", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "buf.validate.field": { string: { minLen: "1", maxLen: "64", pattern: "^[a-z][a-z0-9_]*$" } } } },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "buf.validate.field": { string: { minLen: "1", maxLen: "128" } } } },
            { no: 3, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "pump_index", kind: "scalar", T: 5 /*ScalarType.INT32*/, options: { "buf.validate.field": { int32: { lte: 7, gte: 0 } } } },
            { no: 5, name: "type", kind: "enum", T: () => ["enose.config.Liquid.LiquidType", Liquid_LiquidType], options: { "buf.validate.field": { enum: { definedOnly: true, notIn: [0] } } } },
            { no: 6, name: "density_g_ml", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/, options: { "buf.validate.field": { double: { lte: 2, gte: 0.5 } } } },
            { no: 7, name: "viscosity", kind: "enum", T: () => ["enose.config.Liquid.Viscosity", Liquid_Viscosity] }
        ]);
    }
    create(value?: PartialMessage<Liquid>): Liquid {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.name = "";
        message.description = "";
        message.pumpIndex = 0;
        message.type = 0;
        message.densityGMl = 0;
        message.viscosity = 0;
        if (value !== undefined)
            reflectionMergePartial<Liquid>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Liquid): Liquid {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* string description */ 3:
                    message.description = reader.string();
                    break;
                case /* int32 pump_index */ 4:
                    message.pumpIndex = reader.int32();
                    break;
                case /* enose.config.Liquid.LiquidType type */ 5:
                    message.type = reader.int32();
                    break;
                case /* double density_g_ml */ 6:
                    message.densityGMl = reader.double();
                    break;
                case /* enose.config.Liquid.Viscosity viscosity */ 7:
                    message.viscosity = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Liquid, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* string description = 3; */
        if (message.description !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.description);
        /* int32 pump_index = 4; */
        if (message.pumpIndex !== 0)
            writer.tag(4, WireType.Varint).int32(message.pumpIndex);
        /* enose.config.Liquid.LiquidType type = 5; */
        if (message.type !== 0)
            writer.tag(5, WireType.Varint).int32(message.type);
        /* double density_g_ml = 6; */
        if (message.densityGMl !== 0)
            writer.tag(6, WireType.Bit64).double(message.densityGMl);
        /* enose.config.Liquid.Viscosity viscosity = 7; */
        if (message.viscosity !== 0)
            writer.tag(7, WireType.Varint).int32(message.viscosity);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.config.Liquid
 */
export const Liquid = new Liquid$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LiquidList$Type extends MessageType<LiquidList> {
    constructor() {
        super("enose.config.LiquidList", [
            { no: 1, name: "liquids", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Liquid }
        ]);
    }
    create(value?: PartialMessage<LiquidList>): LiquidList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.liquids = [];
        if (value !== undefined)
            reflectionMergePartial<LiquidList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LiquidList): LiquidList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated enose.config.Liquid liquids */ 1:
                    message.liquids.push(Liquid.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LiquidList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated enose.config.Liquid liquids = 1; */
        for (let i = 0; i < message.liquids.length; i++)
            Liquid.internalBinaryWrite(message.liquids[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.config.LiquidList
 */
export const LiquidList = new LiquidList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Substance$Type extends MessageType<Substance> {
    constructor() {
        super("enose.config.Substance", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "buf.validate.field": { string: { minLen: "1", maxLen: "64", pattern: "^[a-z][a-z0-9_]*$" } } } },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "buf.validate.field": { string: { minLen: "1", maxLen: "128" } } } },
            { no: 3, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "category", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "components", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Substance_Component, options: { "buf.validate.field": { repeated: { minItems: "1", maxItems: "8" } } } },
            { no: 6, name: "total_volume_ml", kind: "scalar", oneof: "defaultAmount", T: 1 /*ScalarType.DOUBLE*/, options: { "buf.validate.field": { double: { lte: 100, gt: 0 } } } },
            { no: 7, name: "total_weight_g", kind: "scalar", oneof: "defaultAmount", T: 1 /*ScalarType.DOUBLE*/, options: { "buf.validate.field": { double: { lte: 100, gt: 0 } } } },
            { no: 8, name: "tags", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "buf.validate.field": { repeated: { maxItems: "20" } } } }
        ]);
    }
    create(value?: PartialMessage<Substance>): Substance {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.name = "";
        message.description = "";
        message.category = "";
        message.components = [];
        message.defaultAmount = { oneofKind: undefined };
        message.tags = [];
        if (value !== undefined)
            reflectionMergePartial<Substance>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Substance): Substance {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* string description */ 3:
                    message.description = reader.string();
                    break;
                case /* string category */ 4:
                    message.category = reader.string();
                    break;
                case /* repeated enose.config.Substance.Component components */ 5:
                    message.components.push(Substance_Component.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* double total_volume_ml */ 6:
                    message.defaultAmount = {
                        oneofKind: "totalVolumeMl",
                        totalVolumeMl: reader.double()
                    };
                    break;
                case /* double total_weight_g */ 7:
                    message.defaultAmount = {
                        oneofKind: "totalWeightG",
                        totalWeightG: reader.double()
                    };
                    break;
                case /* repeated string tags */ 8:
                    message.tags.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Substance, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* string description = 3; */
        if (message.description !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.description);
        /* string category = 4; */
        if (message.category !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.category);
        /* repeated enose.config.Substance.Component components = 5; */
        for (let i = 0; i < message.components.length; i++)
            Substance_Component.internalBinaryWrite(message.components[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* double total_volume_ml = 6; */
        if (message.defaultAmount.oneofKind === "totalVolumeMl")
            writer.tag(6, WireType.Bit64).double(message.defaultAmount.totalVolumeMl);
        /* double total_weight_g = 7; */
        if (message.defaultAmount.oneofKind === "totalWeightG")
            writer.tag(7, WireType.Bit64).double(message.defaultAmount.totalWeightG);
        /* repeated string tags = 8; */
        for (let i = 0; i < message.tags.length; i++)
            writer.tag(8, WireType.LengthDelimited).string(message.tags[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.config.Substance
 */
export const Substance = new Substance$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Substance_Component$Type extends MessageType<Substance_Component> {
    constructor() {
        super("enose.config.Substance.Component", [
            { no: 1, name: "liquid_id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "buf.validate.field": { string: { minLen: "1" } } } },
            { no: 2, name: "ratio", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/, options: { "buf.validate.field": { double: { lte: 1, gt: 0 } } } }
        ]);
    }
    create(value?: PartialMessage<Substance_Component>): Substance_Component {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.liquidId = "";
        message.ratio = 0;
        if (value !== undefined)
            reflectionMergePartial<Substance_Component>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Substance_Component): Substance_Component {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string liquid_id */ 1:
                    message.liquidId = reader.string();
                    break;
                case /* double ratio */ 2:
                    message.ratio = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Substance_Component, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string liquid_id = 1; */
        if (message.liquidId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.liquidId);
        /* double ratio = 2; */
        if (message.ratio !== 0)
            writer.tag(2, WireType.Bit64).double(message.ratio);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.config.Substance.Component
 */
export const Substance_Component = new Substance_Component$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubstanceList$Type extends MessageType<SubstanceList> {
    constructor() {
        super("enose.config.SubstanceList", [
            { no: 1, name: "substances", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Substance }
        ]);
    }
    create(value?: PartialMessage<SubstanceList>): SubstanceList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.substances = [];
        if (value !== undefined)
            reflectionMergePartial<SubstanceList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubstanceList): SubstanceList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated enose.config.Substance substances */ 1:
                    message.substances.push(Substance.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubstanceList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated enose.config.Substance substances = 1; */
        for (let i = 0; i < message.substances.length; i++)
            Substance.internalBinaryWrite(message.substances[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.config.SubstanceList
 */
export const SubstanceList = new SubstanceList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Workflow$Type extends MessageType<Workflow> {
    constructor() {
        super("enose.config.Workflow", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "buf.validate.field": { string: { minLen: "1", maxLen: "64", pattern: "^[a-z][a-z0-9_]*$" } } } },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "buf.validate.field": { string: { minLen: "1", maxLen: "128" } } } },
            { no: 3, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "version", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "buf.validate.field": { string: { pattern: "^\\d+\\.\\d+\\.\\d+$" } } } },
            { no: 5, name: "phases", kind: "message", T: () => Workflow_PhaseConfig, options: { "buf.validate.field": { required: true } } },
            { no: 6, name: "global", kind: "message", T: () => Workflow_GlobalParams }
        ]);
    }
    create(value?: PartialMessage<Workflow>): Workflow {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.name = "";
        message.description = "";
        message.version = "";
        if (value !== undefined)
            reflectionMergePartial<Workflow>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Workflow): Workflow {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* string description */ 3:
                    message.description = reader.string();
                    break;
                case /* string version */ 4:
                    message.version = reader.string();
                    break;
                case /* enose.config.Workflow.PhaseConfig phases */ 5:
                    message.phases = Workflow_PhaseConfig.internalBinaryRead(reader, reader.uint32(), options, message.phases);
                    break;
                case /* enose.config.Workflow.GlobalParams global */ 6:
                    message.global = Workflow_GlobalParams.internalBinaryRead(reader, reader.uint32(), options, message.global);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Workflow, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* string description = 3; */
        if (message.description !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.description);
        /* string version = 4; */
        if (message.version !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.version);
        /* enose.config.Workflow.PhaseConfig phases = 5; */
        if (message.phases)
            Workflow_PhaseConfig.internalBinaryWrite(message.phases, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* enose.config.Workflow.GlobalParams global = 6; */
        if (message.global)
            Workflow_GlobalParams.internalBinaryWrite(message.global, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.config.Workflow
 */
export const Workflow = new Workflow$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Workflow_PhaseConfig$Type extends MessageType<Workflow_PhaseConfig> {
    constructor() {
        super("enose.config.Workflow.PhaseConfig", [
            { no: 1, name: "dose", kind: "message", T: () => Workflow_DoseConfig },
            { no: 2, name: "equilibrate", kind: "message", T: () => Workflow_EquilibrateConfig },
            { no: 3, name: "acquire", kind: "message", T: () => Workflow_AcquireConfig },
            { no: 4, name: "cleanup", kind: "message", T: () => Workflow_CleanupConfig },
            { no: 5, name: "baseline_recovery", kind: "message", T: () => Workflow_BaselineRecoveryConfig }
        ]);
    }
    create(value?: PartialMessage<Workflow_PhaseConfig>): Workflow_PhaseConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Workflow_PhaseConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Workflow_PhaseConfig): Workflow_PhaseConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* enose.config.Workflow.DoseConfig dose */ 1:
                    message.dose = Workflow_DoseConfig.internalBinaryRead(reader, reader.uint32(), options, message.dose);
                    break;
                case /* enose.config.Workflow.EquilibrateConfig equilibrate */ 2:
                    message.equilibrate = Workflow_EquilibrateConfig.internalBinaryRead(reader, reader.uint32(), options, message.equilibrate);
                    break;
                case /* enose.config.Workflow.AcquireConfig acquire */ 3:
                    message.acquire = Workflow_AcquireConfig.internalBinaryRead(reader, reader.uint32(), options, message.acquire);
                    break;
                case /* enose.config.Workflow.CleanupConfig cleanup */ 4:
                    message.cleanup = Workflow_CleanupConfig.internalBinaryRead(reader, reader.uint32(), options, message.cleanup);
                    break;
                case /* enose.config.Workflow.BaselineRecoveryConfig baseline_recovery */ 5:
                    message.baselineRecovery = Workflow_BaselineRecoveryConfig.internalBinaryRead(reader, reader.uint32(), options, message.baselineRecovery);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Workflow_PhaseConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* enose.config.Workflow.DoseConfig dose = 1; */
        if (message.dose)
            Workflow_DoseConfig.internalBinaryWrite(message.dose, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* enose.config.Workflow.EquilibrateConfig equilibrate = 2; */
        if (message.equilibrate)
            Workflow_EquilibrateConfig.internalBinaryWrite(message.equilibrate, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* enose.config.Workflow.AcquireConfig acquire = 3; */
        if (message.acquire)
            Workflow_AcquireConfig.internalBinaryWrite(message.acquire, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* enose.config.Workflow.CleanupConfig cleanup = 4; */
        if (message.cleanup)
            Workflow_CleanupConfig.internalBinaryWrite(message.cleanup, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* enose.config.Workflow.BaselineRecoveryConfig baseline_recovery = 5; */
        if (message.baselineRecovery)
            Workflow_BaselineRecoveryConfig.internalBinaryWrite(message.baselineRecovery, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.config.Workflow.PhaseConfig
 */
export const Workflow_PhaseConfig = new Workflow_PhaseConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Workflow_DoseConfig$Type extends MessageType<Workflow_DoseConfig> {
    constructor() {
        super("enose.config.Workflow.DoseConfig", [
            { no: 1, name: "max_duration_s", kind: "scalar", T: 5 /*ScalarType.INT32*/, options: { "buf.validate.field": { int32: { lte: 300, gte: 10 } } } },
            { no: 2, name: "flow_rate_ml_min", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/, options: { "buf.validate.field": { double: { lte: 20, gte: 0.5 } } } },
            { no: 3, name: "weight_tolerance_g", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/, options: { "buf.validate.field": { double: { lte: 5, gte: 0.1 } } } },
            { no: 4, name: "control_mode", kind: "enum", T: () => ["enose.config.Workflow.DoseConfig.ControlMode", Workflow_DoseConfig_ControlMode] }
        ]);
    }
    create(value?: PartialMessage<Workflow_DoseConfig>): Workflow_DoseConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.maxDurationS = 0;
        message.flowRateMlMin = 0;
        message.weightToleranceG = 0;
        message.controlMode = 0;
        if (value !== undefined)
            reflectionMergePartial<Workflow_DoseConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Workflow_DoseConfig): Workflow_DoseConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 max_duration_s */ 1:
                    message.maxDurationS = reader.int32();
                    break;
                case /* double flow_rate_ml_min */ 2:
                    message.flowRateMlMin = reader.double();
                    break;
                case /* double weight_tolerance_g */ 3:
                    message.weightToleranceG = reader.double();
                    break;
                case /* enose.config.Workflow.DoseConfig.ControlMode control_mode */ 4:
                    message.controlMode = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Workflow_DoseConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 max_duration_s = 1; */
        if (message.maxDurationS !== 0)
            writer.tag(1, WireType.Varint).int32(message.maxDurationS);
        /* double flow_rate_ml_min = 2; */
        if (message.flowRateMlMin !== 0)
            writer.tag(2, WireType.Bit64).double(message.flowRateMlMin);
        /* double weight_tolerance_g = 3; */
        if (message.weightToleranceG !== 0)
            writer.tag(3, WireType.Bit64).double(message.weightToleranceG);
        /* enose.config.Workflow.DoseConfig.ControlMode control_mode = 4; */
        if (message.controlMode !== 0)
            writer.tag(4, WireType.Varint).int32(message.controlMode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.config.Workflow.DoseConfig
 */
export const Workflow_DoseConfig = new Workflow_DoseConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Workflow_EquilibrateConfig$Type extends MessageType<Workflow_EquilibrateConfig> {
    constructor() {
        super("enose.config.Workflow.EquilibrateConfig", [
            { no: 1, name: "duration_s", kind: "scalar", T: 5 /*ScalarType.INT32*/, options: { "buf.validate.field": { int32: { lte: 300, gte: 5 } } } },
            { no: 2, name: "gas_pump_pwm_percent", kind: "scalar", T: 5 /*ScalarType.INT32*/, options: { "buf.validate.field": { int32: { lte: 100, gte: 0 } } } },
            { no: 3, name: "vent_to_ambient", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Workflow_EquilibrateConfig>): Workflow_EquilibrateConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.durationS = 0;
        message.gasPumpPwmPercent = 0;
        message.ventToAmbient = false;
        if (value !== undefined)
            reflectionMergePartial<Workflow_EquilibrateConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Workflow_EquilibrateConfig): Workflow_EquilibrateConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 duration_s */ 1:
                    message.durationS = reader.int32();
                    break;
                case /* int32 gas_pump_pwm_percent */ 2:
                    message.gasPumpPwmPercent = reader.int32();
                    break;
                case /* bool vent_to_ambient */ 3:
                    message.ventToAmbient = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Workflow_EquilibrateConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 duration_s = 1; */
        if (message.durationS !== 0)
            writer.tag(1, WireType.Varint).int32(message.durationS);
        /* int32 gas_pump_pwm_percent = 2; */
        if (message.gasPumpPwmPercent !== 0)
            writer.tag(2, WireType.Varint).int32(message.gasPumpPwmPercent);
        /* bool vent_to_ambient = 3; */
        if (message.ventToAmbient !== false)
            writer.tag(3, WireType.Varint).bool(message.ventToAmbient);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.config.Workflow.EquilibrateConfig
 */
export const Workflow_EquilibrateConfig = new Workflow_EquilibrateConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Workflow_AcquireConfig$Type extends MessageType<Workflow_AcquireConfig> {
    constructor() {
        super("enose.config.Workflow.AcquireConfig", [
            { no: 1, name: "termination", kind: "message", T: () => TerminationCondition },
            { no: 2, name: "gas_pump_pwm_percent", kind: "scalar", T: 5 /*ScalarType.INT32*/, options: { "buf.validate.field": { int32: { lte: 100, gte: 0 } } } }
        ]);
    }
    create(value?: PartialMessage<Workflow_AcquireConfig>): Workflow_AcquireConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.gasPumpPwmPercent = 0;
        if (value !== undefined)
            reflectionMergePartial<Workflow_AcquireConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Workflow_AcquireConfig): Workflow_AcquireConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* enose.config.TerminationCondition termination */ 1:
                    message.termination = TerminationCondition.internalBinaryRead(reader, reader.uint32(), options, message.termination);
                    break;
                case /* int32 gas_pump_pwm_percent */ 2:
                    message.gasPumpPwmPercent = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Workflow_AcquireConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* enose.config.TerminationCondition termination = 1; */
        if (message.termination)
            TerminationCondition.internalBinaryWrite(message.termination, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* int32 gas_pump_pwm_percent = 2; */
        if (message.gasPumpPwmPercent !== 0)
            writer.tag(2, WireType.Varint).int32(message.gasPumpPwmPercent);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.config.Workflow.AcquireConfig
 */
export const Workflow_AcquireConfig = new Workflow_AcquireConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Workflow_CleanupConfig$Type extends MessageType<Workflow_CleanupConfig> {
    constructor() {
        super("enose.config.Workflow.CleanupConfig", [
            { no: 1, name: "cycles", kind: "scalar", T: 5 /*ScalarType.INT32*/, options: { "buf.validate.field": { int32: { lte: 10, gte: 1 } } } },
            { no: 2, name: "rinse_volume_ml", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/, options: { "buf.validate.field": { double: { lte: 50, gte: 5 } } } },
            { no: 3, name: "drain_duration_s", kind: "scalar", T: 5 /*ScalarType.INT32*/, options: { "buf.validate.field": { int32: { lte: 60, gte: 5 } } } }
        ]);
    }
    create(value?: PartialMessage<Workflow_CleanupConfig>): Workflow_CleanupConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.cycles = 0;
        message.rinseVolumeMl = 0;
        message.drainDurationS = 0;
        if (value !== undefined)
            reflectionMergePartial<Workflow_CleanupConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Workflow_CleanupConfig): Workflow_CleanupConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 cycles */ 1:
                    message.cycles = reader.int32();
                    break;
                case /* double rinse_volume_ml */ 2:
                    message.rinseVolumeMl = reader.double();
                    break;
                case /* int32 drain_duration_s */ 3:
                    message.drainDurationS = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Workflow_CleanupConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 cycles = 1; */
        if (message.cycles !== 0)
            writer.tag(1, WireType.Varint).int32(message.cycles);
        /* double rinse_volume_ml = 2; */
        if (message.rinseVolumeMl !== 0)
            writer.tag(2, WireType.Bit64).double(message.rinseVolumeMl);
        /* int32 drain_duration_s = 3; */
        if (message.drainDurationS !== 0)
            writer.tag(3, WireType.Varint).int32(message.drainDurationS);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.config.Workflow.CleanupConfig
 */
export const Workflow_CleanupConfig = new Workflow_CleanupConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Workflow_BaselineRecoveryConfig$Type extends MessageType<Workflow_BaselineRecoveryConfig> {
    constructor() {
        super("enose.config.Workflow.BaselineRecoveryConfig", [
            { no: 1, name: "termination", kind: "message", T: () => TerminationCondition },
            { no: 2, name: "gas_pump_pwm_percent", kind: "scalar", T: 5 /*ScalarType.INT32*/, options: { "buf.validate.field": { int32: { lte: 100, gte: 0 } } } }
        ]);
    }
    create(value?: PartialMessage<Workflow_BaselineRecoveryConfig>): Workflow_BaselineRecoveryConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.gasPumpPwmPercent = 0;
        if (value !== undefined)
            reflectionMergePartial<Workflow_BaselineRecoveryConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Workflow_BaselineRecoveryConfig): Workflow_BaselineRecoveryConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* enose.config.TerminationCondition termination */ 1:
                    message.termination = TerminationCondition.internalBinaryRead(reader, reader.uint32(), options, message.termination);
                    break;
                case /* int32 gas_pump_pwm_percent */ 2:
                    message.gasPumpPwmPercent = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Workflow_BaselineRecoveryConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* enose.config.TerminationCondition termination = 1; */
        if (message.termination)
            TerminationCondition.internalBinaryWrite(message.termination, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* int32 gas_pump_pwm_percent = 2; */
        if (message.gasPumpPwmPercent !== 0)
            writer.tag(2, WireType.Varint).int32(message.gasPumpPwmPercent);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.config.Workflow.BaselineRecoveryConfig
 */
export const Workflow_BaselineRecoveryConfig = new Workflow_BaselineRecoveryConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Workflow_GlobalParams$Type extends MessageType<Workflow_GlobalParams> {
    constructor() {
        super("enose.config.Workflow.GlobalParams", [
            { no: 1, name: "board_channel_config_id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "buf.validate.field": { string: { minLen: "1" } } } },
            { no: 2, name: "heater_preheat_temp_c", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/, options: { "buf.validate.field": { double: { lte: 80, gte: 30 } } } },
            { no: 3, name: "gas_flow_default_ml_min", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/, options: { "buf.validate.field": { double: { lte: 200, gte: 20 } } } }
        ]);
    }
    create(value?: PartialMessage<Workflow_GlobalParams>): Workflow_GlobalParams {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.boardChannelConfigId = "";
        message.heaterPreheatTempC = 0;
        message.gasFlowDefaultMlMin = 0;
        if (value !== undefined)
            reflectionMergePartial<Workflow_GlobalParams>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Workflow_GlobalParams): Workflow_GlobalParams {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string board_channel_config_id */ 1:
                    message.boardChannelConfigId = reader.string();
                    break;
                case /* double heater_preheat_temp_c */ 2:
                    message.heaterPreheatTempC = reader.double();
                    break;
                case /* double gas_flow_default_ml_min */ 3:
                    message.gasFlowDefaultMlMin = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Workflow_GlobalParams, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string board_channel_config_id = 1; */
        if (message.boardChannelConfigId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.boardChannelConfigId);
        /* double heater_preheat_temp_c = 2; */
        if (message.heaterPreheatTempC !== 0)
            writer.tag(2, WireType.Bit64).double(message.heaterPreheatTempC);
        /* double gas_flow_default_ml_min = 3; */
        if (message.gasFlowDefaultMlMin !== 0)
            writer.tag(3, WireType.Bit64).double(message.gasFlowDefaultMlMin);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.config.Workflow.GlobalParams
 */
export const Workflow_GlobalParams = new Workflow_GlobalParams$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WorkflowList$Type extends MessageType<WorkflowList> {
    constructor() {
        super("enose.config.WorkflowList", [
            { no: 1, name: "workflows", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Workflow }
        ]);
    }
    create(value?: PartialMessage<WorkflowList>): WorkflowList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.workflows = [];
        if (value !== undefined)
            reflectionMergePartial<WorkflowList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WorkflowList): WorkflowList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated enose.config.Workflow workflows */ 1:
                    message.workflows.push(Workflow.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WorkflowList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated enose.config.Workflow workflows = 1; */
        for (let i = 0; i < message.workflows.length; i++)
            Workflow.internalBinaryWrite(message.workflows[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.config.WorkflowList
 */
export const WorkflowList = new WorkflowList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Experiment$Type extends MessageType<Experiment> {
    constructor() {
        super("enose.config.Experiment", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "buf.validate.field": { string: { minLen: "1", maxLen: "64", pattern: "^[a-z][a-z0-9_]*$" } } } },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "buf.validate.field": { string: { minLen: "1", maxLen: "128" } } } },
            { no: 3, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "workflow_id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "buf.validate.field": { string: { minLen: "1" } } } },
            { no: 5, name: "substance_id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "buf.validate.field": { string: { minLen: "1" } } } },
            { no: 6, name: "overrides", kind: "message", T: () => Experiment_Overrides },
            { no: 7, name: "metadata", kind: "message", T: () => Experiment_Metadata }
        ]);
    }
    create(value?: PartialMessage<Experiment>): Experiment {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.name = "";
        message.description = "";
        message.workflowId = "";
        message.substanceId = "";
        if (value !== undefined)
            reflectionMergePartial<Experiment>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Experiment): Experiment {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* string description */ 3:
                    message.description = reader.string();
                    break;
                case /* string workflow_id */ 4:
                    message.workflowId = reader.string();
                    break;
                case /* string substance_id */ 5:
                    message.substanceId = reader.string();
                    break;
                case /* enose.config.Experiment.Overrides overrides */ 6:
                    message.overrides = Experiment_Overrides.internalBinaryRead(reader, reader.uint32(), options, message.overrides);
                    break;
                case /* enose.config.Experiment.Metadata metadata */ 7:
                    message.metadata = Experiment_Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Experiment, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* string description = 3; */
        if (message.description !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.description);
        /* string workflow_id = 4; */
        if (message.workflowId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.workflowId);
        /* string substance_id = 5; */
        if (message.substanceId !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.substanceId);
        /* enose.config.Experiment.Overrides overrides = 6; */
        if (message.overrides)
            Experiment_Overrides.internalBinaryWrite(message.overrides, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* enose.config.Experiment.Metadata metadata = 7; */
        if (message.metadata)
            Experiment_Metadata.internalBinaryWrite(message.metadata, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.config.Experiment
 */
export const Experiment = new Experiment$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Experiment_Overrides$Type extends MessageType<Experiment_Overrides> {
    constructor() {
        super("enose.config.Experiment.Overrides", [
            { no: 1, name: "total_volume_ml", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "total_weight_g", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "board_channel_config_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Experiment_Overrides>): Experiment_Overrides {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Experiment_Overrides>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Experiment_Overrides): Experiment_Overrides {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional double total_volume_ml */ 1:
                    message.totalVolumeMl = reader.double();
                    break;
                case /* optional double total_weight_g */ 2:
                    message.totalWeightG = reader.double();
                    break;
                case /* optional string board_channel_config_id */ 3:
                    message.boardChannelConfigId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Experiment_Overrides, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional double total_volume_ml = 1; */
        if (message.totalVolumeMl !== undefined)
            writer.tag(1, WireType.Bit64).double(message.totalVolumeMl);
        /* optional double total_weight_g = 2; */
        if (message.totalWeightG !== undefined)
            writer.tag(2, WireType.Bit64).double(message.totalWeightG);
        /* optional string board_channel_config_id = 3; */
        if (message.boardChannelConfigId !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.boardChannelConfigId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.config.Experiment.Overrides
 */
export const Experiment_Overrides = new Experiment_Overrides$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Experiment_Metadata$Type extends MessageType<Experiment_Metadata> {
    constructor() {
        super("enose.config.Experiment.Metadata", [
            { no: 1, name: "author", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "created_at", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "tags", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Experiment_Metadata>): Experiment_Metadata {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.author = "";
        message.createdAt = "";
        message.tags = [];
        if (value !== undefined)
            reflectionMergePartial<Experiment_Metadata>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Experiment_Metadata): Experiment_Metadata {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string author */ 1:
                    message.author = reader.string();
                    break;
                case /* string created_at */ 2:
                    message.createdAt = reader.string();
                    break;
                case /* repeated string tags */ 3:
                    message.tags.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Experiment_Metadata, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string author = 1; */
        if (message.author !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.author);
        /* string created_at = 2; */
        if (message.createdAt !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.createdAt);
        /* repeated string tags = 3; */
        for (let i = 0; i < message.tags.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.tags[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.config.Experiment.Metadata
 */
export const Experiment_Metadata = new Experiment_Metadata$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExperimentList$Type extends MessageType<ExperimentList> {
    constructor() {
        super("enose.config.ExperimentList", [
            { no: 1, name: "experiments", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Experiment }
        ]);
    }
    create(value?: PartialMessage<ExperimentList>): ExperimentList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.experiments = [];
        if (value !== undefined)
            reflectionMergePartial<ExperimentList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExperimentList): ExperimentList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated enose.config.Experiment experiments */ 1:
                    message.experiments.push(Experiment.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExperimentList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated enose.config.Experiment experiments = 1; */
        for (let i = 0; i < message.experiments.length; i++)
            Experiment.internalBinaryWrite(message.experiments[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.config.ExperimentList
 */
export const ExperimentList = new ExperimentList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Sample$Type extends MessageType<Sample> {
    constructor() {
        super("enose.config.Sample", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "buf.validate.field": { string: { uuid: true } } } },
            { no: 2, name: "experiment_id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "buf.validate.field": { string: { minLen: "1" } } } },
            { no: 3, name: "run_index", kind: "scalar", T: 5 /*ScalarType.INT32*/, options: { "buf.validate.field": { int32: { gte: 1 } } } },
            { no: 4, name: "runtime", kind: "message", T: () => Sample_Runtime },
            { no: 5, name: "data_files", kind: "message", T: () => Sample_DataFiles },
            { no: 6, name: "quality", kind: "message", T: () => Sample_Quality }
        ]);
    }
    create(value?: PartialMessage<Sample>): Sample {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.experimentId = "";
        message.runIndex = 0;
        if (value !== undefined)
            reflectionMergePartial<Sample>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Sample): Sample {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string experiment_id */ 2:
                    message.experimentId = reader.string();
                    break;
                case /* int32 run_index */ 3:
                    message.runIndex = reader.int32();
                    break;
                case /* enose.config.Sample.Runtime runtime */ 4:
                    message.runtime = Sample_Runtime.internalBinaryRead(reader, reader.uint32(), options, message.runtime);
                    break;
                case /* enose.config.Sample.DataFiles data_files */ 5:
                    message.dataFiles = Sample_DataFiles.internalBinaryRead(reader, reader.uint32(), options, message.dataFiles);
                    break;
                case /* enose.config.Sample.Quality quality */ 6:
                    message.quality = Sample_Quality.internalBinaryRead(reader, reader.uint32(), options, message.quality);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Sample, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string experiment_id = 2; */
        if (message.experimentId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.experimentId);
        /* int32 run_index = 3; */
        if (message.runIndex !== 0)
            writer.tag(3, WireType.Varint).int32(message.runIndex);
        /* enose.config.Sample.Runtime runtime = 4; */
        if (message.runtime)
            Sample_Runtime.internalBinaryWrite(message.runtime, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* enose.config.Sample.DataFiles data_files = 5; */
        if (message.dataFiles)
            Sample_DataFiles.internalBinaryWrite(message.dataFiles, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* enose.config.Sample.Quality quality = 6; */
        if (message.quality)
            Sample_Quality.internalBinaryWrite(message.quality, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.config.Sample
 */
export const Sample = new Sample$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Sample_Runtime$Type extends MessageType<Sample_Runtime> {
    constructor() {
        super("enose.config.Sample.Runtime", [
            { no: 1, name: "started_at", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "finished_at", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "status", kind: "enum", T: () => ["enose.config.Sample.SampleStatus", Sample_SampleStatus] },
            { no: 4, name: "actual_weight_g", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 5, name: "actual_volume_ml", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<Sample_Runtime>): Sample_Runtime {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.startedAt = "";
        message.finishedAt = "";
        message.status = 0;
        message.actualWeightG = 0;
        message.actualVolumeMl = 0;
        if (value !== undefined)
            reflectionMergePartial<Sample_Runtime>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Sample_Runtime): Sample_Runtime {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string started_at */ 1:
                    message.startedAt = reader.string();
                    break;
                case /* string finished_at */ 2:
                    message.finishedAt = reader.string();
                    break;
                case /* enose.config.Sample.SampleStatus status */ 3:
                    message.status = reader.int32();
                    break;
                case /* double actual_weight_g */ 4:
                    message.actualWeightG = reader.double();
                    break;
                case /* double actual_volume_ml */ 5:
                    message.actualVolumeMl = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Sample_Runtime, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string started_at = 1; */
        if (message.startedAt !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.startedAt);
        /* string finished_at = 2; */
        if (message.finishedAt !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.finishedAt);
        /* enose.config.Sample.SampleStatus status = 3; */
        if (message.status !== 0)
            writer.tag(3, WireType.Varint).int32(message.status);
        /* double actual_weight_g = 4; */
        if (message.actualWeightG !== 0)
            writer.tag(4, WireType.Bit64).double(message.actualWeightG);
        /* double actual_volume_ml = 5; */
        if (message.actualVolumeMl !== 0)
            writer.tag(5, WireType.Bit64).double(message.actualVolumeMl);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.config.Sample.Runtime
 */
export const Sample_Runtime = new Sample_Runtime$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Sample_DataFiles$Type extends MessageType<Sample_DataFiles> {
    constructor() {
        super("enose.config.Sample.DataFiles", [
            { no: 1, name: "sensor_data", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "log_file", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Sample_DataFiles>): Sample_DataFiles {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sensorData = "";
        message.logFile = "";
        if (value !== undefined)
            reflectionMergePartial<Sample_DataFiles>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Sample_DataFiles): Sample_DataFiles {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sensor_data */ 1:
                    message.sensorData = reader.string();
                    break;
                case /* string log_file */ 2:
                    message.logFile = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Sample_DataFiles, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sensor_data = 1; */
        if (message.sensorData !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sensorData);
        /* string log_file = 2; */
        if (message.logFile !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.logFile);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.config.Sample.DataFiles
 */
export const Sample_DataFiles = new Sample_DataFiles$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Sample_Quality$Type extends MessageType<Sample_Quality> {
    constructor() {
        super("enose.config.Sample.Quality", [
            { no: 1, name: "passed", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "flags", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "notes", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Sample_Quality>): Sample_Quality {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.passed = false;
        message.flags = [];
        message.notes = "";
        if (value !== undefined)
            reflectionMergePartial<Sample_Quality>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Sample_Quality): Sample_Quality {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool passed */ 1:
                    message.passed = reader.bool();
                    break;
                case /* repeated string flags */ 2:
                    message.flags.push(reader.string());
                    break;
                case /* string notes */ 3:
                    message.notes = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Sample_Quality, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool passed = 1; */
        if (message.passed !== false)
            writer.tag(1, WireType.Varint).bool(message.passed);
        /* repeated string flags = 2; */
        for (let i = 0; i < message.flags.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.flags[i]);
        /* string notes = 3; */
        if (message.notes !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.notes);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.config.Sample.Quality
 */
export const Sample_Quality = new Sample_Quality$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SampleList$Type extends MessageType<SampleList> {
    constructor() {
        super("enose.config.SampleList", [
            { no: 1, name: "samples", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Sample }
        ]);
    }
    create(value?: PartialMessage<SampleList>): SampleList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.samples = [];
        if (value !== undefined)
            reflectionMergePartial<SampleList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SampleList): SampleList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated enose.config.Sample samples */ 1:
                    message.samples.push(Sample.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SampleList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated enose.config.Sample samples = 1; */
        for (let i = 0; i < message.samples.length; i++)
            Sample.internalBinaryWrite(message.samples[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.config.SampleList
 */
export const SampleList = new SampleList$Type();
