// @generated by protobuf-ts 2.11.1 with parameter long_type_string,generate_dependencies,client_grpc1,server_grpc1
// @generated from protobuf file "enose_data.proto" (package "enose.data", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Timestamp } from "./google/protobuf/timestamp";
/**
 * ============================================================
 * 传感器数据帧 (SensorFrame)
 * 实时传输的传感器原始数据
 * ============================================================
 *
 * @generated from protobuf message enose.data.SensorFrame
 */
export interface SensorFrame {
    /**
     * 采集时间戳 (主机时间)
     *
     * @generated from protobuf field: google.protobuf.Timestamp ts = 1
     */
    ts?: Timestamp;
    /**
     * 帧序号
     *
     * @generated from protobuf field: uint64 seq = 2
     */
    seq: string;
    /**
     * 传感器读数列表
     * 对应配置中 SensorBoard.sensors 的顺序
     *
     * @generated from protobuf field: repeated enose.data.SensorReading readings = 3
     */
    readings: SensorReading[];
    /**
     * 运行上下文
     *
     * @generated from protobuf field: string run_id = 10
     */
    runId: string; // 当前运行 ID (Sample ID)    /**
     * @generated from protobuf field: string phase_name = 11
     */
    phaseName: string; // 当前阶段名称 (DOSE, ACQUIRE, etc.)    /**
     * 气体流路状态 (用于标记数据有效性)
     *
     * @generated from protobuf field: enose.data.SensorFrame.GasMode gas_mode = 12
     */
    gasMode: SensorFrame_GasMode;
    /**
     * 加热器状态 (全局或主状态)
     * 如果每个传感器加热状态不同，应放在 SensorReading 中
     *
     * @generated from protobuf field: uint32 heater_step = 13
     */
    heaterStep: number;
    /**
     * 设备标识 (对应 SensorBoard.id)
     * 用于在多板系统中区分数据源
     *
     * @generated from protobuf field: string device_id = 14
     */
    deviceId: string;
    /**
     * 设备原始 Tick (毫秒)
     * 用于调试时间同步和抖动
     *
     * @generated from protobuf field: uint64 device_tick = 15
     */
    deviceTick: string;
}
/**
 * @generated from protobuf enum enose.data.SensorFrame.GasMode
 */
export enum SensorFrame_GasMode {
    /**
     * @generated from protobuf enum value: GAS_MODE_UNSPECIFIED = 0;
     */
    GAS_MODE_UNSPECIFIED = 0,
    /**
     * 气室连通 (正常采集)
     *
     * @generated from protobuf enum value: CHAMBER = 1;
     */
    CHAMBER = 1,
    /**
     * 旁路 (排气)
     *
     * @generated from protobuf enum value: BYPASS = 2;
     */
    BYPASS = 2
}
/**
 * ============================================================
 * 单个物理传感器的读数 (SensorReading)
 * ============================================================
 *
 * @generated from protobuf message enose.data.SensorReading
 */
export interface SensorReading {
    /**
     * 传感器唯一标识 (对应 SensorBoard.sensors.id)
     *
     * @generated from protobuf field: string sensor_id = 1
     */
    sensorId: string;
    // 基础测量值    // 根据传感器类型，只有相关字段会有值

    /**
     * @generated from protobuf field: double gas_resistance = 2
     */
    gasResistance: number; // 气体电阻 (Ohm)    /**
     * @generated from protobuf field: double voltage = 3
     */
    voltage: number; // 电压值 (V)    /**
     * @generated from protobuf field: double current = 4
     */
    current: number; // 电流值 (A)    /**
     * @generated from protobuf field: double concentration = 5
     */
    concentration: number; // 浓度 (ppb/ppm)    /**
     * 传感器板载环境数据 (如果传感器支持)
     * 例如 BME688 自带 T/H/P
     *
     * @generated from protobuf field: optional double temperature = 6
     */
    temperature?: number;
    /**
     * @generated from protobuf field: optional double humidity = 7
     */
    humidity?: number;
    /**
     * @generated from protobuf field: optional double pressure = 8
     */
    pressure?: number;
    /**
     * 计算指标 (如 BSEC 输出的 IAQ)
     *
     * @generated from protobuf field: optional double gas_index = 9
     */
    gasIndex?: number;
    /**
     * 状态标志
     *
     * @generated from protobuf field: uint32 status_flags = 10
     */
    statusFlags: number; // 0=OK, others=Error code    /**
     * 传感器特定的加热器步进索引 (如果是加热循环模式)
     *
     * @generated from protobuf field: optional uint32 heater_step = 11
     */
    heaterStep?: number;
    /**
     * 扩展数据
     *
     * @generated from protobuf field: map<string, double> extra = 15
     */
    extra: {
        [key: string]: number;
    };
}
/**
 * ============================================================
 * 分析结果 (AnalysisResult)
 * 实时分析服务的输出结果
 * ============================================================
 *
 * @generated from protobuf message enose.data.AnalysisResult
 */
export interface AnalysisResult {
    /**
     * 分析时间戳
     *
     * @generated from protobuf field: google.protobuf.Timestamp ts = 1
     */
    ts?: Timestamp;
    /**
     * 关联的传感器帧序号
     *
     * @generated from protobuf field: uint64 sensor_seq = 2
     */
    sensorSeq: string;
    /**
     * 计算指标
     *
     * @generated from protobuf field: repeated enose.data.AnalysisResult.Metric metrics = 3
     */
    metrics: AnalysisResult_Metric[];
    /**
     * 质量标志
     *
     * @generated from protobuf field: repeated enose.data.AnalysisResult.QualityFlag flags = 4
     */
    flags: AnalysisResult_QualityFlag[];
    /**
     * 建议操作
     *
     * @generated from protobuf field: repeated string recommendations = 10
     */
    recommendations: string[];
    /**
     * 设备标识 (对应产生原始数据的 SensorFrame.device_id)
     *
     * @generated from protobuf field: string device_id = 11
     */
    deviceId: string;
}
/**
 * @generated from protobuf message enose.data.AnalysisResult.Metric
 */
export interface AnalysisResult_Metric {
    /**
     * @generated from protobuf field: string name = 1
     */
    name: string;
    /**
     * @generated from protobuf field: double value = 2
     */
    value: number;
    /**
     * @generated from protobuf field: string unit = 3
     */
    unit: string;
}
/**
 * @generated from protobuf enum enose.data.AnalysisResult.QualityFlag
 */
export enum AnalysisResult_QualityFlag {
    /**
     * @generated from protobuf enum value: QUALITY_FLAG_UNSPECIFIED = 0;
     */
    QUALITY_FLAG_UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: QF_OK = 1;
     */
    QF_OK = 1,
    /**
     * 基线不稳
     *
     * @generated from protobuf enum value: QF_BASELINE_UNSTABLE = 2;
     */
    QF_BASELINE_UNSTABLE = 2,
    /**
     * 传感器饱和
     *
     * @generated from protobuf enum value: QF_SENSOR_SATURATION = 3;
     */
    QF_SENSOR_SATURATION = 3,
    /**
     * 噪声过大
     *
     * @generated from protobuf enum value: QF_EXCESS_NOISE = 4;
     */
    QF_EXCESS_NOISE = 4,
    /**
     * 湿度异常
     *
     * @generated from protobuf enum value: QF_HUMIDITY_OUT_OF_RANGE = 5;
     */
    QF_HUMIDITY_OUT_OF_RANGE = 5,
    /**
     * 温度异常
     *
     * @generated from protobuf enum value: QF_TEMP_OUT_OF_RANGE = 6;
     */
    QF_TEMP_OUT_OF_RANGE = 6,
    /**
     * 流量异常
     *
     * @generated from protobuf enum value: QF_FLOW_SUSPECTED = 7;
     */
    QF_FLOW_SUSPECTED = 7
}
/**
 * ============================================================
 * 系统事件 (Event)
 * 运行过程中的日志和状态变更
 * ============================================================
 *
 * @generated from protobuf message enose.data.Event
 */
export interface Event {
    /**
     * @generated from protobuf field: google.protobuf.Timestamp ts = 1
     */
    ts?: Timestamp;
    /**
     * @generated from protobuf field: uint64 seq = 2
     */
    seq: string;
    /**
     * @generated from protobuf field: enose.data.Event.EventType type = 3
     */
    type: Event_EventType;
    /**
     * @generated from protobuf field: enose.data.Event.Severity severity = 4
     */
    severity: Event_Severity;
    /**
     * @generated from protobuf field: string text = 5
     */
    text: string;
    /**
     * @generated from protobuf field: repeated enose.data.Event.KeyValue fields = 6
     */
    fields: Event_KeyValue[];
}
/**
 * @generated from protobuf message enose.data.Event.KeyValue
 */
export interface Event_KeyValue {
    /**
     * @generated from protobuf field: string key = 1
     */
    key: string;
    /**
     * @generated from protobuf field: string value = 2
     */
    value: string;
}
/**
 * @generated from protobuf enum enose.data.Event.EventType
 */
export enum Event_EventType {
    /**
     * @generated from protobuf enum value: EVENT_TYPE_UNSPECIFIED = 0;
     */
    EVENT_TYPE_UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: SYSTEM_STARTUP = 1;
     */
    SYSTEM_STARTUP = 1,
    /**
     * @generated from protobuf enum value: PHASE_CHANGED = 2;
     */
    PHASE_CHANGED = 2,
    /**
     * @generated from protobuf enum value: ERROR_OCCURRED = 3;
     */
    ERROR_OCCURRED = 3,
    /**
     * @generated from protobuf enum value: USER_INTERACTION = 4;
     */
    USER_INTERACTION = 4,
    /**
     * @generated from protobuf enum value: DEVICE_STATUS = 5;
     */
    DEVICE_STATUS = 5
}
/**
 * @generated from protobuf enum enose.data.Event.Severity
 */
export enum Event_Severity {
    /**
     * @generated from protobuf enum value: SEVERITY_UNSPECIFIED = 0;
     */
    SEVERITY_UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: INFO = 1;
     */
    INFO = 1,
    /**
     * @generated from protobuf enum value: WARNING = 2;
     */
    WARNING = 2,
    /**
     * @generated from protobuf enum value: ERROR = 3;
     */
    ERROR = 3,
    /**
     * @generated from protobuf enum value: CRITICAL = 4;
     */
    CRITICAL = 4
}
// @generated message type with reflection information, may provide speed optimized methods
class SensorFrame$Type extends MessageType<SensorFrame> {
    constructor() {
        super("enose.data.SensorFrame", [
            { no: 1, name: "ts", kind: "message", T: () => Timestamp },
            { no: 2, name: "seq", kind: "scalar", T: 4 /*ScalarType.UINT64*/ },
            { no: 3, name: "readings", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => SensorReading },
            { no: 10, name: "run_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "phase_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "gas_mode", kind: "enum", T: () => ["enose.data.SensorFrame.GasMode", SensorFrame_GasMode] },
            { no: 13, name: "heater_step", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 14, name: "device_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 15, name: "device_tick", kind: "scalar", T: 4 /*ScalarType.UINT64*/ }
        ]);
    }
    create(value?: PartialMessage<SensorFrame>): SensorFrame {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.seq = "0";
        message.readings = [];
        message.runId = "";
        message.phaseName = "";
        message.gasMode = 0;
        message.heaterStep = 0;
        message.deviceId = "";
        message.deviceTick = "0";
        if (value !== undefined)
            reflectionMergePartial<SensorFrame>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SensorFrame): SensorFrame {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Timestamp ts */ 1:
                    message.ts = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.ts);
                    break;
                case /* uint64 seq */ 2:
                    message.seq = reader.uint64().toString();
                    break;
                case /* repeated enose.data.SensorReading readings */ 3:
                    message.readings.push(SensorReading.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string run_id */ 10:
                    message.runId = reader.string();
                    break;
                case /* string phase_name */ 11:
                    message.phaseName = reader.string();
                    break;
                case /* enose.data.SensorFrame.GasMode gas_mode */ 12:
                    message.gasMode = reader.int32();
                    break;
                case /* uint32 heater_step */ 13:
                    message.heaterStep = reader.uint32();
                    break;
                case /* string device_id */ 14:
                    message.deviceId = reader.string();
                    break;
                case /* uint64 device_tick */ 15:
                    message.deviceTick = reader.uint64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SensorFrame, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.Timestamp ts = 1; */
        if (message.ts)
            Timestamp.internalBinaryWrite(message.ts, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint64 seq = 2; */
        if (message.seq !== "0")
            writer.tag(2, WireType.Varint).uint64(message.seq);
        /* repeated enose.data.SensorReading readings = 3; */
        for (let i = 0; i < message.readings.length; i++)
            SensorReading.internalBinaryWrite(message.readings[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* string run_id = 10; */
        if (message.runId !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.runId);
        /* string phase_name = 11; */
        if (message.phaseName !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.phaseName);
        /* enose.data.SensorFrame.GasMode gas_mode = 12; */
        if (message.gasMode !== 0)
            writer.tag(12, WireType.Varint).int32(message.gasMode);
        /* uint32 heater_step = 13; */
        if (message.heaterStep !== 0)
            writer.tag(13, WireType.Varint).uint32(message.heaterStep);
        /* string device_id = 14; */
        if (message.deviceId !== "")
            writer.tag(14, WireType.LengthDelimited).string(message.deviceId);
        /* uint64 device_tick = 15; */
        if (message.deviceTick !== "0")
            writer.tag(15, WireType.Varint).uint64(message.deviceTick);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.data.SensorFrame
 */
export const SensorFrame = new SensorFrame$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SensorReading$Type extends MessageType<SensorReading> {
    constructor() {
        super("enose.data.SensorReading", [
            { no: 1, name: "sensor_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "gas_resistance", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "voltage", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 4, name: "current", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 5, name: "concentration", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 6, name: "temperature", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 7, name: "humidity", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 8, name: "pressure", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 9, name: "gas_index", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 10, name: "status_flags", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "heater_step", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 15, name: "extra", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ } }
        ]);
    }
    create(value?: PartialMessage<SensorReading>): SensorReading {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sensorId = "";
        message.gasResistance = 0;
        message.voltage = 0;
        message.current = 0;
        message.concentration = 0;
        message.statusFlags = 0;
        message.extra = {};
        if (value !== undefined)
            reflectionMergePartial<SensorReading>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SensorReading): SensorReading {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sensor_id */ 1:
                    message.sensorId = reader.string();
                    break;
                case /* double gas_resistance */ 2:
                    message.gasResistance = reader.double();
                    break;
                case /* double voltage */ 3:
                    message.voltage = reader.double();
                    break;
                case /* double current */ 4:
                    message.current = reader.double();
                    break;
                case /* double concentration */ 5:
                    message.concentration = reader.double();
                    break;
                case /* optional double temperature */ 6:
                    message.temperature = reader.double();
                    break;
                case /* optional double humidity */ 7:
                    message.humidity = reader.double();
                    break;
                case /* optional double pressure */ 8:
                    message.pressure = reader.double();
                    break;
                case /* optional double gas_index */ 9:
                    message.gasIndex = reader.double();
                    break;
                case /* uint32 status_flags */ 10:
                    message.statusFlags = reader.uint32();
                    break;
                case /* optional uint32 heater_step */ 11:
                    message.heaterStep = reader.uint32();
                    break;
                case /* map<string, double> extra */ 15:
                    this.binaryReadMap15(message.extra, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap15(map: SensorReading["extra"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof SensorReading["extra"] | undefined, val: SensorReading["extra"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.double();
                    break;
                default: throw new globalThis.Error("unknown map entry field for enose.data.SensorReading.extra");
            }
        }
        map[key ?? ""] = val ?? 0;
    }
    internalBinaryWrite(message: SensorReading, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sensor_id = 1; */
        if (message.sensorId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sensorId);
        /* double gas_resistance = 2; */
        if (message.gasResistance !== 0)
            writer.tag(2, WireType.Bit64).double(message.gasResistance);
        /* double voltage = 3; */
        if (message.voltage !== 0)
            writer.tag(3, WireType.Bit64).double(message.voltage);
        /* double current = 4; */
        if (message.current !== 0)
            writer.tag(4, WireType.Bit64).double(message.current);
        /* double concentration = 5; */
        if (message.concentration !== 0)
            writer.tag(5, WireType.Bit64).double(message.concentration);
        /* optional double temperature = 6; */
        if (message.temperature !== undefined)
            writer.tag(6, WireType.Bit64).double(message.temperature);
        /* optional double humidity = 7; */
        if (message.humidity !== undefined)
            writer.tag(7, WireType.Bit64).double(message.humidity);
        /* optional double pressure = 8; */
        if (message.pressure !== undefined)
            writer.tag(8, WireType.Bit64).double(message.pressure);
        /* optional double gas_index = 9; */
        if (message.gasIndex !== undefined)
            writer.tag(9, WireType.Bit64).double(message.gasIndex);
        /* uint32 status_flags = 10; */
        if (message.statusFlags !== 0)
            writer.tag(10, WireType.Varint).uint32(message.statusFlags);
        /* optional uint32 heater_step = 11; */
        if (message.heaterStep !== undefined)
            writer.tag(11, WireType.Varint).uint32(message.heaterStep);
        /* map<string, double> extra = 15; */
        for (let k of globalThis.Object.keys(message.extra))
            writer.tag(15, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.Bit64).double(message.extra[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.data.SensorReading
 */
export const SensorReading = new SensorReading$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AnalysisResult$Type extends MessageType<AnalysisResult> {
    constructor() {
        super("enose.data.AnalysisResult", [
            { no: 1, name: "ts", kind: "message", T: () => Timestamp },
            { no: 2, name: "sensor_seq", kind: "scalar", T: 4 /*ScalarType.UINT64*/ },
            { no: 3, name: "metrics", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => AnalysisResult_Metric },
            { no: 4, name: "flags", kind: "enum", repeat: 1 /*RepeatType.PACKED*/, T: () => ["enose.data.AnalysisResult.QualityFlag", AnalysisResult_QualityFlag] },
            { no: 10, name: "recommendations", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "device_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AnalysisResult>): AnalysisResult {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sensorSeq = "0";
        message.metrics = [];
        message.flags = [];
        message.recommendations = [];
        message.deviceId = "";
        if (value !== undefined)
            reflectionMergePartial<AnalysisResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AnalysisResult): AnalysisResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Timestamp ts */ 1:
                    message.ts = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.ts);
                    break;
                case /* uint64 sensor_seq */ 2:
                    message.sensorSeq = reader.uint64().toString();
                    break;
                case /* repeated enose.data.AnalysisResult.Metric metrics */ 3:
                    message.metrics.push(AnalysisResult_Metric.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated enose.data.AnalysisResult.QualityFlag flags */ 4:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.flags.push(reader.int32());
                    else
                        message.flags.push(reader.int32());
                    break;
                case /* repeated string recommendations */ 10:
                    message.recommendations.push(reader.string());
                    break;
                case /* string device_id */ 11:
                    message.deviceId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AnalysisResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.Timestamp ts = 1; */
        if (message.ts)
            Timestamp.internalBinaryWrite(message.ts, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint64 sensor_seq = 2; */
        if (message.sensorSeq !== "0")
            writer.tag(2, WireType.Varint).uint64(message.sensorSeq);
        /* repeated enose.data.AnalysisResult.Metric metrics = 3; */
        for (let i = 0; i < message.metrics.length; i++)
            AnalysisResult_Metric.internalBinaryWrite(message.metrics[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated enose.data.AnalysisResult.QualityFlag flags = 4; */
        if (message.flags.length) {
            writer.tag(4, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.flags.length; i++)
                writer.int32(message.flags[i]);
            writer.join();
        }
        /* repeated string recommendations = 10; */
        for (let i = 0; i < message.recommendations.length; i++)
            writer.tag(10, WireType.LengthDelimited).string(message.recommendations[i]);
        /* string device_id = 11; */
        if (message.deviceId !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.deviceId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.data.AnalysisResult
 */
export const AnalysisResult = new AnalysisResult$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AnalysisResult_Metric$Type extends MessageType<AnalysisResult_Metric> {
    constructor() {
        super("enose.data.AnalysisResult.Metric", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "value", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "unit", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AnalysisResult_Metric>): AnalysisResult_Metric {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.value = 0;
        message.unit = "";
        if (value !== undefined)
            reflectionMergePartial<AnalysisResult_Metric>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AnalysisResult_Metric): AnalysisResult_Metric {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* double value */ 2:
                    message.value = reader.double();
                    break;
                case /* string unit */ 3:
                    message.unit = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AnalysisResult_Metric, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* double value = 2; */
        if (message.value !== 0)
            writer.tag(2, WireType.Bit64).double(message.value);
        /* string unit = 3; */
        if (message.unit !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.unit);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.data.AnalysisResult.Metric
 */
export const AnalysisResult_Metric = new AnalysisResult_Metric$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Event$Type extends MessageType<Event> {
    constructor() {
        super("enose.data.Event", [
            { no: 1, name: "ts", kind: "message", T: () => Timestamp },
            { no: 2, name: "seq", kind: "scalar", T: 4 /*ScalarType.UINT64*/ },
            { no: 3, name: "type", kind: "enum", T: () => ["enose.data.Event.EventType", Event_EventType] },
            { no: 4, name: "severity", kind: "enum", T: () => ["enose.data.Event.Severity", Event_Severity] },
            { no: 5, name: "text", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "fields", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Event_KeyValue }
        ]);
    }
    create(value?: PartialMessage<Event>): Event {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.seq = "0";
        message.type = 0;
        message.severity = 0;
        message.text = "";
        message.fields = [];
        if (value !== undefined)
            reflectionMergePartial<Event>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Event): Event {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Timestamp ts */ 1:
                    message.ts = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.ts);
                    break;
                case /* uint64 seq */ 2:
                    message.seq = reader.uint64().toString();
                    break;
                case /* enose.data.Event.EventType type */ 3:
                    message.type = reader.int32();
                    break;
                case /* enose.data.Event.Severity severity */ 4:
                    message.severity = reader.int32();
                    break;
                case /* string text */ 5:
                    message.text = reader.string();
                    break;
                case /* repeated enose.data.Event.KeyValue fields */ 6:
                    message.fields.push(Event_KeyValue.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Event, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.Timestamp ts = 1; */
        if (message.ts)
            Timestamp.internalBinaryWrite(message.ts, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint64 seq = 2; */
        if (message.seq !== "0")
            writer.tag(2, WireType.Varint).uint64(message.seq);
        /* enose.data.Event.EventType type = 3; */
        if (message.type !== 0)
            writer.tag(3, WireType.Varint).int32(message.type);
        /* enose.data.Event.Severity severity = 4; */
        if (message.severity !== 0)
            writer.tag(4, WireType.Varint).int32(message.severity);
        /* string text = 5; */
        if (message.text !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.text);
        /* repeated enose.data.Event.KeyValue fields = 6; */
        for (let i = 0; i < message.fields.length; i++)
            Event_KeyValue.internalBinaryWrite(message.fields[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.data.Event
 */
export const Event = new Event$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Event_KeyValue$Type extends MessageType<Event_KeyValue> {
    constructor() {
        super("enose.data.Event.KeyValue", [
            { no: 1, name: "key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "value", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Event_KeyValue>): Event_KeyValue {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.key = "";
        message.value = "";
        if (value !== undefined)
            reflectionMergePartial<Event_KeyValue>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Event_KeyValue): Event_KeyValue {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string key */ 1:
                    message.key = reader.string();
                    break;
                case /* string value */ 2:
                    message.value = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Event_KeyValue, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string key = 1; */
        if (message.key !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.key);
        /* string value = 2; */
        if (message.value !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message enose.data.Event.KeyValue
 */
export const Event_KeyValue = new Event_KeyValue$Type();
